<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RxJava操作符合集</title>
    <link href="/Blog/2020/11/23/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%90%88%E9%9B%86/"/>
    <url>/Blog/2020/11/23/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="RxJava2-只看这一篇文章就够了"><a href="#RxJava2-只看这一篇文章就够了" class="headerlink" title="RxJava2 只看这一篇文章就够了"></a>RxJava2 只看这一篇文章就够了</h1><blockquote><p>本文由 <a href="http://renyugang.io/post/75">玉刚说写作平台</a> 提供写作赞助</p><p>原作者：<code>ZedeChan</code></p><p>版权声明：本文版权归微信公众号 <code>玉刚说</code> 所有，未经许可，不得以任何形式转载</p></blockquote><h1 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h1><p>RxJava 其实就是提供一套异步编程的 API，这套 API 是基于观察者模式的，而且是链式调用的，所以使用 RxJava 编写的代码的逻辑会非常简洁。</p><p>RxJava 有以下三个基本的元素：</p><ol><li>被观察者（Observable）</li><li>观察者（Observer）</li><li>订阅（subscribe）</li></ol><p>下面来说说以上三者是如何协作的：</p><p>首先在 gradle 文件中添加依赖：</p><pre><code class="hljs clean"><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;io.reactivex.rxjava2:rxjava:2.1.4&#x27;</span><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;io.reactivex.rxjava2:rxandroid:2.0.2&#x27;</span>复制代码</code></pre><ol><li>创建被观察者：</li></ol><pre><code class="hljs reasonml">Observable observable = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;<span class="hljs-literal">()</span> &#123;    @Override    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=========================currentThread name: &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);        e.on<span class="hljs-constructor">Next(1)</span>;        e.on<span class="hljs-constructor">Next(2)</span>;        e.on<span class="hljs-constructor">Next(3)</span>;        e.on<span class="hljs-constructor">Complete()</span>;    &#125;&#125;);复制代码</code></pre><ol><li>创建观察者：</li></ol><pre><code class="hljs lasso">Observer observer = <span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;;复制代码</code></pre><ol><li>订阅</li></ol><pre><code class="hljs abnf">observable.subscribe(observer)<span class="hljs-comment">;</span>复制代码</code></pre><p>这里其实也可以使用链式调用：</p><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=========================currentThread name: &quot;</span> + <span class="hljs-keyword">Thread</span>.currentThread().getName());        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>被观察者发送的事件有以下几种，总结如下表：</p><table><thead><tr><th>事件种类</th><th>作用</th></tr></thead><tbody><tr><td>onNext()</td><td>发送该事件时，观察者会回调 onNext() 方法</td></tr><tr><td>onError()</td><td>发送该事件时，观察者会回调 onError() 方法，当发送该事件之后，其他事件将不会继续发送</td></tr><tr><td>onComplete()</td><td>发送该事件时，观察者会回调 onComplete() 方法，当发送该事件之后，其他事件将不会继续发送</td></tr></tbody></table><p>其实可以把 RxJava 比喻成一个做果汁，家里有很多种水果（要发送的原始数据），你想榨点水果汁喝一下，这时候你就要想究竟要喝什么水果汁呢？如果你想喝牛油果雪梨柠檬汁，那你就要把这三种水果混在一起榨汁（使用各种操作符变换你想发送给观察者的数据），榨完后，你就可以喝上你想要的果汁了（把处理好的数据发送给观察者）。</p><p>总结如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/26/1639a8ee56b13c41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>下面就来讲解 RxJava 各种常见的操作符。</p><h1 id="1-创建操作符"><a href="#1-创建操作符" class="headerlink" title="1. 创建操作符"></a>1. 创建操作符</h1><p>以下就是讲解创建被观察者的各种操作符。</p><h2 id="1-1-create"><a href="#1-1-create" class="headerlink" title="1.1 create()"></a>1.1 create()</h2><h4 id="方法预览："><a href="#方法预览：" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs vim">public static <span class="hljs-symbol">&lt;T&gt;</span> Observable<span class="hljs-symbol">&lt;T&gt;</span> create(ObservableOnSubscribe<span class="hljs-symbol">&lt;T&gt;</span> <span class="hljs-keyword">source</span>)复制代码</code></pre><h4 id="有什么用："><a href="#有什么用：" class="headerlink" title="有什么用："></a>有什么用：</h4><p>创建一个被观察者</p><h4 id="怎么用："><a href="#怎么用：" class="headerlink" title="怎么用："></a>怎么用：</h4><pre><code class="hljs php">Observable&lt;<span class="hljs-keyword">String</span>&gt; observable = Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;<span class="hljs-keyword">String</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-keyword">String</span>&gt; e) throws <span class="hljs-built_in">Exception</span> &#123;        e.onNext(<span class="hljs-string">&quot;Hello Observer&quot;</span>);        e.onComplete();    &#125;&#125;);复制代码</code></pre><p>上面的代码非常简单，创建 ObservableOnSubscribe 并重写其 subscribe 方法，就可以通过 ObservableEmitter 发射器向观察者发送事件。</p><p>以下创建一个观察者，来验证这个被观察者是否成功创建。</p><pre><code class="hljs typescript">Observer&lt;<span class="hljs-built_in">String</span>&gt; observer = <span class="hljs-keyword">new</span> Observer&lt;<span class="hljs-built_in">String</span>&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.d(<span class="hljs-string">&quot;chan&quot;</span>,<span class="hljs-string">&quot;=============onNext &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(<span class="hljs-string">&quot;chan&quot;</span>,<span class="hljs-string">&quot;=============onComplete &quot;</span>);    &#125;&#125;;        observable.subscribe(observer);        复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">50.654</span> <span class="hljs-number">22935</span><span class="hljs-number">-22935</span>/com.example.louder.rxjavademo D/chan: =============onNext Hello Observer=============onComplete复制代码</code></pre><h2 id="1-2-just"><a href="#1-2-just" class="headerlink" title="1.2 just()"></a>1.2 just()</h2><h4 id="方法预览：-1"><a href="#方法预览：-1" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs excel">public static &lt;<span class="hljs-built_in">T</span>&gt; Observable&lt;<span class="hljs-built_in">T</span>&gt; just(<span class="hljs-built_in">T</span> item) ......public static &lt;<span class="hljs-built_in">T</span>&gt; Observable&lt;<span class="hljs-built_in">T</span>&gt; just(<span class="hljs-built_in">T</span> item1, <span class="hljs-built_in">T</span> item2, <span class="hljs-built_in">T</span> item3, <span class="hljs-built_in">T</span> item4, <span class="hljs-built_in">T</span> item5, <span class="hljs-built_in">T</span> item6, <span class="hljs-built_in">T</span> item7, <span class="hljs-built_in">T</span> item8, <span class="hljs-built_in">T</span> item9, <span class="hljs-built_in">T</span> item10)复制代码</code></pre><h4 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>创建一个被观察者，并发送事件，发送的事件不可以超过10个以上。</p><h4 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>上面的代码直接使用链式调用，代码也非常简单，这里就不细说了，看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">16</span>:<span class="hljs-number">27</span>:<span class="hljs-number">26.938</span> <span class="hljs-number">23281</span><span class="hljs-number">-23281</span>/? D/chan: =================onSubscribe=================onNext <span class="hljs-number">1</span>=================onNext <span class="hljs-number">2</span>=================onNext <span class="hljs-number">3</span>=================onComplete 复制代码</code></pre><h2 id="1-3-From-操作符"><a href="#1-3-From-操作符" class="headerlink" title="1.3 From 操作符"></a>1.3 From 操作符</h2><h2 id="1-3-1-fromArray"><a href="#1-3-1-fromArray" class="headerlink" title="1.3.1 fromArray()"></a>1.3.1 fromArray()</h2><h4 id="方法预览：-2"><a href="#方法预览：-2" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs pf">public static <span class="hljs-variable">&lt;T&gt;</span> Observable<span class="hljs-variable">&lt;T&gt;</span> <span class="hljs-keyword">from</span>Array(T... items)复制代码</code></pre><h4 id="有什么用？-1"><a href="#有什么用？-1" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量，并且可以传入一个数组。</p><h4 id="怎么用？-1"><a href="#怎么用？-1" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml">Integer <span class="hljs-built_in">array</span><span class="hljs-literal">[]</span> = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>from<span class="hljs-constructor">Array(<span class="hljs-params">array</span>)</span>.subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=================onSubscribe&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Next(Integer <span class="hljs-params">integer</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=================onNext &quot;</span> + integer);    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=================onError &quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>代码和 just() 基本上一样，直接看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">23.797</span> <span class="hljs-number">23574</span><span class="hljs-number">-23574</span>/com.example.louder.rxjavademo D/chan: =================onSubscribe=================onNext <span class="hljs-number">1</span>=================onNext <span class="hljs-number">2</span>=================onNext <span class="hljs-number">3</span>=================onNext <span class="hljs-number">4</span>=================onComplete 复制代码</code></pre><h2 id="1-3-2-fromCallable"><a href="#1-3-2-fromCallable" class="headerlink" title="1.3.2 fromCallable()"></a>1.3.2 fromCallable()</h2><h4 id="方法预览：-3"><a href="#方法预览：-3" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; fromCallable(<span class="hljs-keyword">Callable</span><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; supplier)复制代码</code></pre><h4 id="有什么用？-2"><a href="#有什么用？-2" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这里的 Callable 是 java.util.concurrent 中的 Callable，Callable 和 Runnable 的用法基本一致，只是它会返回一个结果值，这个结果值就是发给观察者的。</p><h4 id="怎么用？-2"><a href="#怎么用？-2" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.fromCallable(<span class="hljs-built_in">new</span> Callable &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">Integer</span> <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;================accept &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">13</span>:<span class="hljs-number">01</span>:<span class="hljs-number">43.009</span> <span class="hljs-number">6890</span><span class="hljs-number">-6890</span>/? D/chan: ================accept <span class="hljs-number">1</span>复制代码</code></pre><h2 id="1-3-3-fromFuture"><a href="#1-3-3-fromFuture" class="headerlink" title="1.3.3 fromFuture()"></a>1.3.3 fromFuture()</h2><h4 id="方法预览：-4"><a href="#方法预览：-4" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Observable&lt;T&gt; fromFuture(<span class="hljs-keyword">Future</span>&lt;? extends T&gt; <span class="hljs-keyword">future</span>)复制代码</code></pre><h4 id="有什么用？-3"><a href="#有什么用？-3" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>参数中的 Future 是 java.util.concurrent 中的 Future，Future 的作用是增加了 cancel() 等方法操作 Callable，它可以通过 get() 方法来获取 Callable 返回的值。</p><h4 id="怎么用？-3"><a href="#怎么用？-3" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs aspectj">FutureTask &lt; String &gt; futureTask = <span class="hljs-keyword">new</span> FutureTask &lt; &gt; (<span class="hljs-keyword">new</span> Callable &lt; String &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;CallableDemo is Running&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回结果&quot;</span>;    &#125;&#125;);Observable.fromFuture(futureTask)    .doOnSubscribe(<span class="hljs-keyword">new</span> Consumer &lt; Disposable &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Disposable disposable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        futureTask.run();    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Consumer &lt; String &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;================accept &quot;</span> + s);    &#125;&#125;);复制代码</code></pre><p>doOnSubscribe() 的作用就是只有订阅时才会发送事件，具体会在下面讲解。</p><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">13</span>:<span class="hljs-number">54</span>:<span class="hljs-number">00.470</span> <span class="hljs-number">14429</span><span class="hljs-number">-14429</span>/com.example.rxjavademo D/chan: CallableDemo <span class="hljs-keyword">is</span> Running================accept 返回结果复制代码</code></pre><h2 id="1-3-4-fromIterable"><a href="#1-3-4-fromIterable" class="headerlink" title="1.3.4 fromIterable()"></a>1.3.4 fromIterable()</h2><h4 id="方法预览：-5"><a href="#方法预览：-5" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; fromIterable(<span class="hljs-keyword">Iterable</span><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source)复制代码</code></pre><h4 id="有什么用？-4"><a href="#有什么用？-4" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>直接发送一个 List 集合数据给观察者</p><h4 id="怎么用？-4"><a href="#怎么用？-4" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<span class="hljs-built_in">list</span>.add(<span class="hljs-number">0</span>);<span class="hljs-built_in">list</span>.add(<span class="hljs-number">1</span>);<span class="hljs-built_in">list</span>.add(<span class="hljs-number">2</span>);<span class="hljs-built_in">list</span>.add(<span class="hljs-number">3</span>);Observable.fromIterable(<span class="hljs-built_in">list</span>).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">28.874</span> <span class="hljs-number">23965</span><span class="hljs-number">-23965</span>/? D/chan: =================onSubscribe=================onNext <span class="hljs-number">0</span>=================onNext <span class="hljs-number">1</span>=================onNext <span class="hljs-number">2</span>=================onNext <span class="hljs-number">3</span>=================onComplete 复制代码</code></pre><h2 id="1-4-defer"><a href="#1-4-defer" class="headerlink" title="1.4 defer()"></a>1.4 defer()</h2><h4 id="方法预览：-6"><a href="#方法预览：-6" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; defer(<span class="hljs-keyword">Callable</span><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;&gt; supplier)复制代码</code></pre><h4 id="有什么用？-5"><a href="#有什么用？-5" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法的作用就是直到被观察者被订阅后才会创建被观察者。</p><h4 id="怎么用？-5"><a href="#怎么用？-5" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs php"><span class="hljs-comment">// i 要定义为成员变量</span><span class="hljs-keyword">Integer</span> i = <span class="hljs-number">100</span>;        Observable&lt;<span class="hljs-keyword">Integer</span>&gt; observable = Observable.defer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">Callable</span>&lt;ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">Integer</span>&gt;&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">Integer</span>&gt; call() throws <span class="hljs-built_in">Exception</span> &#123;        <span class="hljs-keyword">return</span> Observable.just(i);    &#125;&#125;);i = <span class="hljs-number">200</span>;Observer observer = <span class="hljs-keyword">new</span> Observer&lt;<span class="hljs-keyword">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onSubscribe(Disposable d) &#123;    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onNext(<span class="hljs-keyword">Integer</span> <span class="hljs-keyword">integer</span>) &#123;        Log.d(TAG, <span class="hljs-string">&quot;================onNext &quot;</span> + <span class="hljs-keyword">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onError(<span class="hljs-built_in">Throwable</span> e) &#123;    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onComplete() &#123;    &#125;&#125;;observable.subscribe(observer);i = <span class="hljs-number">300</span>;observable.subscribe(observer);复制代码</code></pre><p>打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">01.443</span> <span class="hljs-number">26622</span><span class="hljs-number">-26622</span>/? D/chan: ================onNext <span class="hljs-number">200</span>================onNext <span class="hljs-number">300</span>复制代码</code></pre><p>因为 defer() 只有观察者订阅的时候才会创建新的被观察者，所以每订阅一次就会打印一次，并且都是打印 i 最新的值。</p><h2 id="1-5-timer"><a href="#1-5-timer" class="headerlink" title="1.5 timer()"></a>1.5 timer()</h2><h4 id="方法预览：-7"><a href="#方法预览：-7" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">timer</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> delay, TimeUnit <span class="hljs-built_in">unit</span></span>) </span><span class="hljs-function">......</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-6"><a href="#有什么用？-6" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当到指定时间后就会发送一个 0L 的值给观察者。</p><h4 id="怎么用？-6"><a href="#怎么用？-6" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.timer</span>(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Long &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Long aLong) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===============onNext &quot;</span> + aLong);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">27</span>:<span class="hljs-number">48.004</span> <span class="hljs-number">27204</span><span class="hljs-number">-27259</span>/com.example.louder.rxjavademo D/chan: ===============onNext <span class="hljs-number">0</span>复制代码</code></pre><h2 id="1-6-interval"><a href="#1-6-interval" class="headerlink" title="1.6 interval()"></a>1.6 interval()</h2><h4 id="方法预览：-8"><a href="#方法预览：-8" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">interval</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> period, TimeUnit <span class="hljs-built_in">unit</span></span>)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">interval</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> initialDelay, <span class="hljs-built_in">long</span> period, TimeUnit <span class="hljs-built_in">unit</span></span>)</span><span class="hljs-function">......</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-7"><a href="#有什么用？-7" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。</p><h4 id="怎么用？-7"><a href="#怎么用？-7" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.interval</span>(<span class="hljs-number">4</span>, TimeUnit.SECONDS)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Long &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onSubscribe &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onNext</span>(Long aLong) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onNext &quot;</span> + aLong);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">10.321</span> <span class="hljs-number">28723</span><span class="hljs-number">-28723</span>/com.example.louder.rxjavademo D/chan: ==============onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">14.324</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">0</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">18.324</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">1</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">22.323</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">26.323</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">30.323</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">4</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">34.323</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">5</span>复制代码</code></pre><p>从时间就可以看出每隔4秒就会发出一次数字递增1的事件。这里说下 interval() 第三个方法的 initialDelay 参数，这个参数的意思就是 onSubscribe 回调之后，再次回调 onNext 的间隔时间。</p><h2 id="1-7-intervalRange"><a href="#1-7-intervalRange" class="headerlink" title="1.7 intervalRange()"></a>1.7 intervalRange()</h2><h4 id="方法预览：-9"><a href="#方法预览：-9" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public static Observable&lt;Long&gt; interval<span class="hljs-constructor">Range(<span class="hljs-params">long</span> <span class="hljs-params">start</span>, <span class="hljs-params">long</span> <span class="hljs-params">count</span>, <span class="hljs-params">long</span> <span class="hljs-params">initialDelay</span>, <span class="hljs-params">long</span> <span class="hljs-params">period</span>, TimeUnit <span class="hljs-params">unit</span>)</span>public static Observable&lt;Long&gt; interval<span class="hljs-constructor">Range(<span class="hljs-params">long</span> <span class="hljs-params">start</span>, <span class="hljs-params">long</span> <span class="hljs-params">count</span>, <span class="hljs-params">long</span> <span class="hljs-params">initialDelay</span>, <span class="hljs-params">long</span> <span class="hljs-params">period</span>, TimeUnit <span class="hljs-params">unit</span>, Scheduler <span class="hljs-params">scheduler</span>)</span>复制代码</code></pre><h4 id="有什么用？-8"><a href="#有什么用？-8" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。</p><h4 id="怎么用？-8"><a href="#怎么用？-8" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.intervalRange</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Long &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onSubscribe &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onNext</span>(Long aLong) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onNext &quot;</span> + aLong);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">01.672</span> <span class="hljs-number">2504</span><span class="hljs-number">-2504</span>/com.example.louder.rxjavademo D/chan: ==============onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">03.674</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">04.674</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">05.674</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">4</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">06.673</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">5</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">07.674</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">6</span>复制代码</code></pre><p>可以看出收到5次 onNext 事件，并且是从 2 开始的。</p><h2 id="1-8-range"><a href="#1-8-range" class="headerlink" title="1.8 range()"></a>1.8 range()</h2><h4 id="方法预览：-10"><a href="#方法预览：-10" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> static Observable&lt;<span class="hljs-keyword">Integer</span>&gt; <span class="hljs-built_in">range</span>(<span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> start, <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>)复制代码</code></pre><h4 id="有什么用？-9"><a href="#有什么用？-9" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>同时发送一定范围的事件序列。</p><h4 id="怎么用？-9"><a href="#怎么用？-9" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onSubscribe &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onNext</span>(Integer aLong) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onNext &quot;</span> + aLong);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">09</span>:<span class="hljs-number">17.202</span> <span class="hljs-number">2921</span><span class="hljs-number">-2921</span>/? D/chan: ==============onSubscribe ==============onNext <span class="hljs-number">2</span>==============onNext <span class="hljs-number">3</span>==============onNext <span class="hljs-number">4</span>==============onNext <span class="hljs-number">5</span>==============onNext <span class="hljs-number">6</span>复制代码</code></pre><h2 id="1-9-rangeLong"><a href="#1-9-rangeLong" class="headerlink" title="1.9 rangeLong()"></a>1.9 rangeLong()</h2><h4 id="方法预览：-11"><a href="#方法预览：-11" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">rangeLong</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> start, <span class="hljs-built_in">long</span> count</span>)</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-10"><a href="#有什么用？-10" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>作用与 range() 一样，只是数据类型为 Long</p><h4 id="怎么用？-10"><a href="#怎么用？-10" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>用法与 range() 一样，这里就不再赘述了。</p><h2 id="1-10-empty-amp-never-amp-error"><a href="#1-10-empty-amp-never-amp-error" class="headerlink" title="1.10 empty() &amp; never() &amp; error()"></a>1.10 empty() &amp; never() &amp; error()</h2><h4 id="方法预览：-12"><a href="#方法预览：-12" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">empty</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Observable&lt;T&gt; <span class="hljs-title">never</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Observable&lt;T&gt; <span class="hljs-title">error</span>(<span class="hljs-params">final Throwable exception</span>)</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-11"><a href="#有什么用？-11" class="headerlink" title="有什么用？"></a>有什么用？</h4><ol><li>empty() ： 直接发送 onComplete() 事件</li><li>never()：不发送任何事件</li><li>error()：发送 onError() 事件</li></ol><h4 id="怎么用？-11"><a href="#怎么用？-11" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.empty().subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-built_in">Object</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span> + e);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">06</span>:<span class="hljs-number">11.881</span> <span class="hljs-number">15798</span><span class="hljs-number">-15798</span>/com.example.rxjavademo D/chan: ==================onSubscribe==================onComplete复制代码</code></pre><p>换成 never() 的打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">12</span>:<span class="hljs-number">17.554</span> <span class="hljs-number">16805</span><span class="hljs-number">-16805</span>/com.example.rxjavademo D/chan: ==================onSubscribe复制代码</code></pre><p>换成 error() 的打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">12</span>:<span class="hljs-number">58.483</span> <span class="hljs-number">17817</span><span class="hljs-number">-17817</span>/com.example.rxjavademo D/chan: ==================onSubscribe==================onError java.lang.NullPointerException复制代码</code></pre><h1 id="2-转换操作符"><a href="#2-转换操作符" class="headerlink" title="2. 转换操作符"></a>2. 转换操作符</h1><h2 id="2-1-map"><a href="#2-1-map" class="headerlink" title="2.1 map()"></a>2.1 map()</h2><h4 id="方法预览：-13"><a href="#方法预览：-13" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Observable&lt;R&gt; map(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> R&gt; mapper)复制代码</code></pre><h4 id="有什么用？-12"><a href="#有什么用？-12" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>map 可以将被观察者发送的数据类型转变成其他的类型</p><h4 id="怎么用？-12"><a href="#怎么用？-12" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>以下代码将 Integer 类型的数据转换成 String。</p><pre><code class="hljs typescript">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Integer, <span class="hljs-built_in">String</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Integer integer) throws Exception &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m &quot;</span> + integer;    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-built_in">String</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.e(TAG, <span class="hljs-string">&quot;===================onSubscribe&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.e(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs diff">05-21 09:16:03.490 5700-5700/com.example.rxjavademo E/chan: <span class="hljs-comment">===================onSubscribe</span><span class="hljs-comment">===================onNext I&#x27;m 1</span><span class="hljs-comment">===================onNext I&#x27;m 2</span><span class="hljs-comment">===================onNext I&#x27;m 3</span>复制代码</code></pre><h2 id="2-2-flatMap"><a href="#2-2-flatMap" class="headerlink" title="2.2 flatMap()"></a>2.2 flatMap()</h2><h4 id="方法预览：-14"><a href="#方法预览：-14" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Observable&lt;R&gt; flatMap(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> R&gt;&gt; mapper)<span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span>复制代码</code></pre><h4 id="有什么用？-13"><a href="#有什么用？-13" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。</p><h4 id="怎么用？-13"><a href="#怎么用？-13" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable。现在用一个例子来说明 flatMap() 的用法。</p><p>假设一个有一个 Person 类，这个类的定义如下：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;    <span class="hljs-keyword">private</span> List&lt;Plan&gt; planList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, List&lt;Plan&gt; planList</span>)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.planList = planList;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> List&lt;Plan&gt; <span class="hljs-function"><span class="hljs-title">getPlanList</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> planList;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setPlanList</span>(<span class="hljs-params">List&lt;Plan&gt; planList</span>)</span> &#123;        <span class="hljs-built_in">this</span>.planList = planList;    &#125;&#125;复制代码</code></pre><p>Person 类有一个 name 和 planList 两个变量，分别代表的是人名和计划清单。</p><p>Plan 类的定义如下：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> time;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> content;    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">String</span>&gt; actionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Plan</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> time, <span class="hljs-built_in">String</span> content</span>)</span> &#123;        <span class="hljs-built_in">this</span>.time = time;        <span class="hljs-built_in">this</span>.content = content;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getTime</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> time;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> time</span>)</span> &#123;        <span class="hljs-built_in">this</span>.time = time;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getContent</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> content;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setContent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>)</span> &#123;        <span class="hljs-built_in">this</span>.content = content;    &#125;    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">getActionList</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> actionList;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setActionList</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">String</span>&gt; actionList</span>)</span> &#123;        <span class="hljs-built_in">this</span>.actionList = actionList;    &#125;&#125;复制代码</code></pre><p>现在有一个需求就是要将 Person 集合中的每个元素中的 Plan 的 action 打印出来。 首先用 map() 来实现这个需求看看：</p><pre><code class="hljs typescript">Observable.fromIterable(personList).map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Person, List &lt; Plan &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> List &lt; Plan &gt; apply(Person person) throws Exception &#123;        <span class="hljs-keyword">return</span> person.getPlanList();    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; List &lt; Plan &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">List &lt; Plan &gt; plans</span>)</span> &#123;        <span class="hljs-keyword">for</span> (Plan plan: plans) &#123;            List &lt; <span class="hljs-built_in">String</span> &gt; planActionList = plan.getActionList();            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> action: planActionList) &#123;                Log.d(TAG, <span class="hljs-string">&quot;==================action &quot;</span> + action);            &#125;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;&#125;);复制代码</code></pre><p>可以看到 onNext() 用了嵌套 for 循环来实现，如果代码逻辑复杂起来的话，可能需要多重循环才可以实现。</p><p>现在看下使用 flatMap() 实现：</p><pre><code class="hljs typescript">Observable.fromIterable(personList).flatMap(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Person, ObservableSource &lt; Plan &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> ObservableSource &lt; Plan &gt; <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">Person person</span>)</span> &#123;        <span class="hljs-keyword">return</span> Observable.fromIterable(person.getPlanList());    &#125;&#125;).flatMap(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Plan, ObservableSource &lt; <span class="hljs-built_in">String</span> &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> ObservableSource &lt; <span class="hljs-built_in">String</span> &gt; apply(Plan plan) throws Exception &#123;        <span class="hljs-keyword">return</span> Observable.fromIterable(plan.getActionList());    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-built_in">String</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================action: &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;&#125;);复制代码</code></pre><p>从代码可以看出，只需要两个 flatMap() 就可以完成需求，并且代码逻辑非常清晰。</p><h2 id="2-3-concatMap"><a href="#2-3-concatMap" class="headerlink" title="2.3 concatMap()"></a>2.3 concatMap()</h2><h4 id="方法预览：-15"><a href="#方法预览：-15" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Observable&lt;R&gt; concatMap(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> R&gt;&gt; mapper)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Observable&lt;R&gt; concatMap(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> R&gt;&gt; mapper, <span class="hljs-built_in">int</span> prefetch)复制代码</code></pre><h4 id="有什么用？-14"><a href="#有什么用？-14" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>concatMap() 和 flatMap() 基本上是一样的，只不过 concatMap() 转发出来的事件是有序的，而 flatMap() 是无序的。</p><h4 id="怎么用？-14"><a href="#怎么用？-14" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>还是使用上面 flatMap() 的例子来讲解，首先来试下 flatMap() 来验证发送的事件是否是无序的，代码如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.fromIterable</span>(personList)<span class="hljs-selector-class">.flatMap</span>(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () &#123;    <span class="hljs-variable">@Override</span>    public ObservableSource &lt; Plan &gt; apply(Person person) &#123;        <span class="hljs-selector-tag">if</span> (<span class="hljs-string">&quot;chan&quot;</span>.equals(person.getName())) &#123;            <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.fromIterable</span>(person.getPlanList())<span class="hljs-selector-class">.delay</span>(<span class="hljs-number">10</span>, TimeUnit.MILLISECONDS);        &#125;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.fromIterable</span>(person.getPlanList());    &#125;&#125;)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Plan &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Plan plan) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==================plan &quot;</span> + plan.getContent());    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>为了更好的验证 flatMap 是无序的，使用了一个 delay() 方法来延迟，直接看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">13</span>:<span class="hljs-number">57</span>:<span class="hljs-number">14.031</span> <span class="hljs-number">21616</span><span class="hljs-number">-21616</span>/com.example.rxjavademo D/chan: ==================plan chan 上课==================plan chan 写作业==================plan chan 打篮球<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">13</span>:<span class="hljs-number">57</span>:<span class="hljs-number">14.041</span> <span class="hljs-number">21616</span><span class="hljs-number">-21641</span>/com.example.rxjavademo D/chan: ==================plan Zede 开会==================plan Zede 写代码==================plan Zede 写文章复制代码</code></pre><p>可以看到本来 Zede 的事件发送顺序是排在 chan 事件之前，但是经过延迟后， 这两个事件序列发送顺序互换了。</p><p>现在来验证下 concatMap() 是否是有序的，使用上面同样的代码，只是把 flatMap() 换成 concatMap()，打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">42.917</span> <span class="hljs-number">21799</span><span class="hljs-number">-21823</span>/com.example.rxjavademo D/chan: ==================plan Zede 开会==================plan Zede 写代码==================plan Zede 写文章==================plan chan 上课==================plan chan 写作业==================plan chan 打篮球复制代码</code></pre><p>这就代表 concatMap() 转换后发送的事件序列是有序的了。</p><h2 id="2-4-buffer"><a href="#2-4-buffer" class="headerlink" title="2.4 buffer()"></a>2.4 buffer()</h2><h4 id="方法预览：-16"><a href="#方法预览：-16" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;List&lt;T&gt;&gt; buffer(<span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>, <span class="hljs-built_in">int</span> skip)......复制代码</code></pre><h4 id="有什么用？-15"><a href="#有什么用？-15" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。</p><h4 id="怎么用？-15"><a href="#怎么用？-15" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>buffer 有两个参数，一个是 count，另一个 skip。count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素。这样说可能还是有点抽象，直接看代码：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-selector-class">.buffer</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; List &lt; Integer &gt;&gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(List &lt; Integer &gt; integers) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;================缓冲区大小： &quot;</span> + integers.size());        <span class="hljs-selector-tag">for</span> (Integer <span class="hljs-attribute">i</span>: integers) &#123;            <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;================元素： &quot;</span> + i);        &#125;    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">14</span>:<span class="hljs-number">09</span>:<span class="hljs-number">34.015</span> <span class="hljs-number">22421</span><span class="hljs-number">-22421</span>/com.example.rxjavademo D/chan: ================缓冲区大小： <span class="hljs-number">2</span>================元素： <span class="hljs-number">1</span>================元素： <span class="hljs-number">2</span>================缓冲区大小： <span class="hljs-number">2</span>================元素： <span class="hljs-number">2</span>================元素： <span class="hljs-number">3</span>================缓冲区大小： <span class="hljs-number">2</span>================元素： <span class="hljs-number">3</span>================元素： <span class="hljs-number">4</span>================缓冲区大小： <span class="hljs-number">2</span>================元素： <span class="hljs-number">4</span>================元素： <span class="hljs-number">5</span>================缓冲区大小： <span class="hljs-number">1</span>================元素： <span class="hljs-number">5</span>复制代码</code></pre><p>从结果可以看出，每次发送事件，指针都会往后移动一个元素再取值，直到指针移动到没有元素的时候就会停止取值。</p><h2 id="2-5-groupBy"><a href="#2-5-groupBy" class="headerlink" title="2.5 groupBy()"></a>2.5 groupBy()</h2><h4 id="方法预览：-17"><a href="#方法预览：-17" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> K&gt; keySelector)复制代码</code></pre><h4 id="有什么用？-16"><a href="#有什么用？-16" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将发送的数据进行分组，每个分组都会返回一个被观察者。</p><h4 id="怎么用？-16"><a href="#怎么用？-16" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>).groupBy(<span class="hljs-literal">new</span> Function &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer</span> % <span class="hljs-number">3</span>;    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; GroupedObservable &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt;&gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(GroupedObservable &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt; integerIntegerGroupedObservable) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================onNext &quot;</span>);        integerIntegerGroupedObservable.subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;                <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================GroupedObservable onSubscribe &quot;</span>);            &#125;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;                <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================GroupedObservable onNext  groupName: &quot;</span> + integerIntegerGroupedObservable.getKey() + <span class="hljs-string">&quot; value: &quot;</span> + <span class="hljs-built_in">integer</span>);            &#125;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;                <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================GroupedObservable onError &quot;</span>);            &#125;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;                <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================GroupedObservable onComplete &quot;</span>);            &#125;        &#125;);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>在 groupBy() 方法返回的参数是分组的名字，每返回一个值，那就代表会创建一个组，以上的代码就是将1~10的数据分成3组，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">02.062</span> <span class="hljs-number">21451</span><span class="hljs-number">-21451</span>/com.example.rxjavademo D/chan: ====================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">02.063</span> <span class="hljs-number">21451</span><span class="hljs-number">-21451</span>/com.example.rxjavademo D/chan: ====================onNext ====================GroupedObservable onSubscribe     ====================GroupedObservable onNext  groupName: <span class="hljs-number">2</span> value: <span class="hljs-number">5</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">2</span> value: <span class="hljs-number">2</span>====================onNext ====================GroupedObservable onSubscribe ====================GroupedObservable onNext  groupName: <span class="hljs-number">0</span> value: <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">02.064</span> <span class="hljs-number">21451</span><span class="hljs-number">-21451</span>/com.example.rxjavademo D/chan: ====================onNext ====================GroupedObservable onSubscribe ====================GroupedObservable onNext  groupName: <span class="hljs-number">1</span> value: <span class="hljs-number">4</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">1</span> value: <span class="hljs-number">1</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">0</span> value: <span class="hljs-number">6</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">2</span> value: <span class="hljs-number">8</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">0</span> value: <span class="hljs-number">9</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">1</span> value: <span class="hljs-number">7</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">1</span> value: <span class="hljs-number">10</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">02.065</span> <span class="hljs-number">21451</span><span class="hljs-number">-21451</span>/com.example.rxjavademo D/chan: ====================GroupedObservable onComplete ====================GroupedObservable onComplete ====================GroupedObservable onComplete ====================onComplete 复制代码</code></pre><p>可以看到返回的结果中是有3个组的。</p><h2 id="2-6-scan"><a href="#2-6-scan" class="headerlink" title="2.6 scan()"></a>2.6 scan()</h2><h4 id="方法预览：-18"><a href="#方法预览：-18" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs excel">public final Observable&lt;<span class="hljs-built_in">T</span>&gt; scan(BiFunction&lt;<span class="hljs-built_in">T</span>, <span class="hljs-built_in">T</span>, <span class="hljs-built_in">T</span>&gt; accumulator)复制代码</code></pre><h4 id="有什么用？-17"><a href="#有什么用？-17" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将数据以一定的逻辑聚合起来。</p><h4 id="怎么用？-17"><a href="#怎么用？-17" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).scan(<span class="hljs-literal">new</span> BiFunction &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>, <span class="hljs-built_in">Integer</span> integer2) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================apply &quot;</span>);        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================integer &quot;</span> + <span class="hljs-built_in">integer</span>);        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================integer2 &quot;</span> + integer2);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer</span> + integer2;    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================accept &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">45</span>:<span class="hljs-number">27.784</span> <span class="hljs-number">22519</span><span class="hljs-number">-22519</span>/com.example.rxjavademo D/chan: ====================accept <span class="hljs-number">1</span>====================apply ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">1</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">2</span>====================accept <span class="hljs-number">3</span>====================apply <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">45</span>:<span class="hljs-number">27.785</span> <span class="hljs-number">22519</span><span class="hljs-number">-22519</span>/com.example.rxjavademo D/chan: ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">3</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">3</span>====================accept <span class="hljs-number">6</span>====================apply ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">6</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">4</span>====================accept <span class="hljs-number">10</span>====================apply ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">10</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">5</span>====================accept <span class="hljs-number">15</span>复制代码</code></pre><h2 id="2-7-window"><a href="#2-7-window" class="headerlink" title="2.7 window()"></a>2.7 window()</h2><h4 id="方法预览：-19"><a href="#方法预览：-19" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(<span class="hljs-built_in">long</span> <span class="hljs-keyword">count</span>)......复制代码</code></pre><h4 id="有什么用？-18"><a href="#有什么用？-18" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>发送指定数量的事件时，就将这些事件分为一组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。</p><h4 id="怎么用？-18"><a href="#怎么用？-18" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).window(<span class="hljs-number">2</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Observable &lt; Integer &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=====================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Observable &lt; Integer &gt; integerObservable</span>)</span> &#123;        integerObservable.subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;                Log.d(TAG, <span class="hljs-string">&quot;=====================integerObservable onSubscribe &quot;</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;                Log.d(TAG, <span class="hljs-string">&quot;=====================integerObservable onNext &quot;</span> + integer);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;                Log.d(TAG, <span class="hljs-string">&quot;=====================integerObservable onError &quot;</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;                Log.d(TAG, <span class="hljs-string">&quot;=====================integerObservable onComplete &quot;</span>);            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=====================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=====================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">15</span>:<span class="hljs-number">02</span>:<span class="hljs-number">20.654</span> <span class="hljs-number">25838</span><span class="hljs-number">-25838</span>/com.example.rxjavademo D/chan: =====================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">15</span>:<span class="hljs-number">02</span>:<span class="hljs-number">20.655</span> <span class="hljs-number">25838</span><span class="hljs-number">-25838</span>/com.example.rxjavademo D/chan: =====================<span class="hljs-built_in">int</span>egerObservable onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">15</span>:<span class="hljs-number">02</span>:<span class="hljs-number">20.656</span> <span class="hljs-number">25838</span><span class="hljs-number">-25838</span>/com.example.rxjavademo D/chan: =====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">1</span>=====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">2</span>=====================<span class="hljs-built_in">int</span>egerObservable onComplete =====================<span class="hljs-built_in">int</span>egerObservable onSubscribe =====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">3</span>=====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">4</span>=====================<span class="hljs-built_in">int</span>egerObservable onComplete =====================<span class="hljs-built_in">int</span>egerObservable onSubscribe =====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">5</span>=====================<span class="hljs-built_in">int</span>egerObservable onComplete =====================onComplete 复制代码</code></pre><p>从结果可以发现，window() 将 1~5 的事件分成了3组。</p><h1 id="3-组合操作符"><a href="#3-组合操作符" class="headerlink" title="3. 组合操作符"></a>3. 组合操作符</h1><h2 id="3-1-concat"><a href="#3-1-concat" class="headerlink" title="3.1 concat()"></a>3.1 concat()</h2><h4 id="方法预览：-20"><a href="#方法预览：-20" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source1, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source2, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source3, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source4)......复制代码</code></pre><h4 id="有什么用？-19"><a href="#有什么用？-19" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。</p><h4 id="怎么用？-19"><a href="#怎么用？-19" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.concat</span>(Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),Observable.just(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),Observable.just(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>),Observable.just(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>))<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Integer integer) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;================onNext &quot;</span> + integer);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">26.738</span> <span class="hljs-number">7477</span><span class="hljs-number">-7477</span>/com.example.rxjavademo D/chan: ================onNext <span class="hljs-number">1</span>================onNext <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">26.739</span> <span class="hljs-number">7477</span><span class="hljs-number">-7477</span>/com.example.rxjavademo D/chan: ================onNext <span class="hljs-number">3</span>================onNext <span class="hljs-number">4</span>================onNext <span class="hljs-number">5</span>================onNext <span class="hljs-number">6</span>================onNext <span class="hljs-number">7</span>================onNext <span class="hljs-number">8</span>复制代码</code></pre><h2 id="3-2-concatArray"><a href="#3-2-concatArray" class="headerlink" title="3.2 concatArray()"></a>3.2 concatArray()</h2><h4 id="方法预览：-21"><a href="#方法预览：-21" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; concatArray(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;... sources)复制代码</code></pre><h4 id="有什么用？-20"><a href="#有什么用？-20" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 concat() 作用一样，不过 concatArray() 可以发送多于 4 个被观察者。</p><h4 id="怎么用？-20"><a href="#怎么用？-20" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.concatArray</span>(Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),Observable.just(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),Observable.just(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>),Observable.just(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>),Observable.just(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>))<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Integer integer) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;================onNext &quot;</span> + integer);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">15</span>:<span class="hljs-number">47</span>:<span class="hljs-number">18.581</span> <span class="hljs-number">9129</span><span class="hljs-number">-9129</span>/com.example.rxjavademo D/chan: ================onNext <span class="hljs-number">1</span>================onNext <span class="hljs-number">2</span>================onNext <span class="hljs-number">3</span>================onNext <span class="hljs-number">4</span>================onNext <span class="hljs-number">5</span>================onNext <span class="hljs-number">6</span>================onNext <span class="hljs-number">7</span>================onNext <span class="hljs-number">8</span>================onNext <span class="hljs-number">9</span>================onNext <span class="hljs-number">10</span>复制代码</code></pre><h2 id="3-3-merge"><a href="#3-3-merge" class="headerlink" title="3.3 merge()"></a>3.3 merge()</h2><h4 id="方法预览：-22"><a href="#方法预览：-22" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"> <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; merge(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source1, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source2, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source3, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source4)......复制代码</code></pre><h4 id="有什么用？-21"><a href="#有什么用？-21" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法月 concat() 作用基本一样，知识 concat() 是串行发送事件，而 merge() 并行发送事件。</p><h4 id="怎么用？-21"><a href="#怎么用？-21" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>现在来演示 concat() 和 merge() 的区别。</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.merge</span>(Observable.interval(<span class="hljs-number">1</span>, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () &#123;    <span class="hljs-variable">@Override</span>    public String apply(Long aLong) throws Exception &#123;        return <span class="hljs-string">&quot;A&quot;</span> + aLong;    &#125;&#125;),Observable.interval(<span class="hljs-number">1</span>, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () &#123;    <span class="hljs-variable">@Override</span>    public String apply(Long aLong) throws Exception &#123;        return <span class="hljs-string">&quot;B&quot;</span> + aLong;    &#125;&#125;))    <span class="hljs-selector-class">.subscribe</span>(new Observer &lt; String &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(String s) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;=====================onNext &quot;</span> + s);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">31.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B0<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">31.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A0<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">32.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A1<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">32.126</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B1<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">33.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A2<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">33.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B2<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">34.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A3<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">34.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B3<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">35.124</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A4<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">35.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B4<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">36.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A5<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">36.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B5......复制代码</code></pre><p>从结果可以看出，A 和 B 的事件序列都可以发出，将以上的代码换成 concat() 看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">52.352</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A0<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">53.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A1<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">54.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A2<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">55.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A3<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">56.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A4<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">57.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A5......复制代码</code></pre><p>从结果可以知道，只有等到第一个被观察者发送完事件之后，第二个被观察者才会发送事件。</p><p>mergeArray() 与 merge() 的作用是一样的，只是它可以发送4个以上的被观察者，这里就不再赘述了。</p><h2 id="3-4-concatArrayDelayError-amp-mergeArrayDelayError"><a href="#3-4-concatArrayDelayError-amp-mergeArrayDelayError" class="headerlink" title="3.4 concatArrayDelayError() &amp; mergeArrayDelayError()"></a>3.4 concatArrayDelayError() &amp; mergeArrayDelayError()</h2><h4 id="方法预览：-23"><a href="#方法预览：-23" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; concatArrayDelayError(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;... sources)<span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; mergeArrayDelayError(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;... sources)复制代码</code></pre><h4 id="有什么用？-22"><a href="#有什么用？-22" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在 concatArray() 和 mergeArray() 两个方法当中，如果其中有一个被观察者发送了一个 Error 事件，那么就会停止发送事件，如果你想 onError() 事件延迟到所有被观察者都发送完事件后再执行的话，就可以使用 concatArrayDelayError() 和 mergeArrayDelayError()</p><h4 id="怎么用？-22"><a href="#怎么用？-22" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>首先使用 concatArray() 来验证一下发送 onError() 事件是否会中断其他被观察者发送事件，代码如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.concatArray</span>(Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onError(new NumberFormatException());    &#125;&#125;), Observable.just(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))    <span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Integer integer) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + integer);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onComplete</span>() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">59.725</span> <span class="hljs-number">17985</span><span class="hljs-number">-17985</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">1</span>===================onError 复制代码</code></pre><p>从结果可以知道，确实中断了，现在换用 concatArrayDelayError()，代码如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.concatArrayDelayError</span>(Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onError(new NumberFormatException());    &#125;&#125;), Observable.just(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Integer integer) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + integer);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onComplete</span>() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">59.329</span> <span class="hljs-number">18199</span><span class="hljs-number">-18199</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">1</span>===================onNext <span class="hljs-number">2</span>===================onNext <span class="hljs-number">3</span>===================onNext <span class="hljs-number">4</span>===================onError 复制代码</code></pre><p>从结果可以看到，onError 事件是在所有被观察者发送完事件才发送的。mergeArrayDelayError() 也是有同样的作用，这里不再赘述。</p><h2 id="3-5-zip"><a href="#3-5-zip" class="headerlink" title="3.5 zip()"></a>3.5 zip()</h2><h4 id="方法预览：-24"><a href="#方法预览：-24" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs mipsasm">public static &lt;<span class="hljs-built_in">T1</span>, <span class="hljs-built_in">T2</span>, R&gt; Observable&lt;R&gt; zip(ObservableSource&lt;? <span class="hljs-keyword">extends </span><span class="hljs-built_in">T1</span>&gt; source1, ObservableSource&lt;? <span class="hljs-keyword">extends </span><span class="hljs-built_in">T2</span>&gt; source2, <span class="hljs-keyword">BiFunction&lt;? </span>super <span class="hljs-built_in">T1</span>, ? super <span class="hljs-built_in">T2</span>, ? <span class="hljs-keyword">extends </span>R&gt; zipper)......复制代码</code></pre><h4 id="有什么用？-23"><a href="#有什么用？-23" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。</p><h4 id="怎么用？-23"><a href="#怎么用？-23" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.zip(Observable.intervalRange(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS)    .map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>&lt;Long, <span class="hljs-built_in">String</span>&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Long aLong) throws Exception &#123;            <span class="hljs-built_in">String</span> s1 = <span class="hljs-string">&quot;A&quot;</span> + aLong;            Log.d(TAG, <span class="hljs-string">&quot;===================A 发送的事件 &quot;</span> + s1);            <span class="hljs-keyword">return</span> s1;        &#125;&#125;),        Observable.intervalRange(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS)            .map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>&lt;Long, <span class="hljs-built_in">String</span>&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Long aLong) throws Exception &#123;                <span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;B&quot;</span> + aLong;                Log.d(TAG, <span class="hljs-string">&quot;===================B 发送的事件 &quot;</span> + s2);                <span class="hljs-keyword">return</span> s2;            &#125;        &#125;),        <span class="hljs-keyword">new</span> BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(<span class="hljs-built_in">String</span> s, <span class="hljs-built_in">String</span> s2) throws Exception &#123;                <span class="hljs-built_in">String</span> res = s + s2;                <span class="hljs-keyword">return</span> res;            &#125;        &#125;).subscribe(<span class="hljs-keyword">new</span> Observer&lt;<span class="hljs-built_in">String</span>&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>上面代码中有两个 Observable，第一个发送事件的数量为5个，第二个发送事件的数量为6个。现在来看下打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">39.952</span> <span class="hljs-number">5338</span><span class="hljs-number">-5338</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B1===================onNext A1B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">41.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">41.954</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B2===================onNext A2B2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================onNext A3B3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">43.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">43.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">43.954</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================onNext A4B4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">44.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A5<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">44.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B5<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">44.954</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================onNext A5B5===================onComplete 复制代码</code></pre><p>可以发现最终接收到的事件数量是5，那么为什么第二个 Observable 没有发送第6个事件呢？因为在这之前第一个 Observable 已经发送了 onComplete 事件，所以第二个 Observable 不会再发送事件。</p><h2 id="3-6-combineLatest-amp-combineLatestDelayError"><a href="#3-6-combineLatest-amp-combineLatestDelayError" class="headerlink" title="3.6 combineLatest() &amp; combineLatestDelayError()"></a>3.6 combineLatest() &amp; combineLatestDelayError()</h2><h4 id="方法预览：-25"><a href="#方法预览：-25" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs mipsasm">public static &lt;<span class="hljs-built_in">T1</span>, <span class="hljs-built_in">T2</span>, R&gt; Observable&lt;R&gt; combineLatest(ObservableSource&lt;? <span class="hljs-keyword">extends </span><span class="hljs-built_in">T1</span>&gt; source1, ObservableSource&lt;? <span class="hljs-keyword">extends </span><span class="hljs-built_in">T2</span>&gt; source2, <span class="hljs-keyword">BiFunction&lt;? </span>super <span class="hljs-built_in">T1</span>, ? super <span class="hljs-built_in">T2</span>, ? <span class="hljs-keyword">extends </span>R&gt; combiner)....... 复制代码</code></pre><h4 id="有什么用？-24"><a href="#有什么用？-24" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>combineLatest() 的作用与 zip() 类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送，这样可能还是比较抽象，看看以下例子代码。</p><h4 id="怎么用？-24"><a href="#怎么用？-24" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.combineLatest(Observable.intervalRange(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS)    .map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Long, <span class="hljs-built_in">String</span> &gt; () &#123;<span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Long aLong) throws Exception &#123;        <span class="hljs-built_in">String</span> s1 = <span class="hljs-string">&quot;A&quot;</span> + aLong;        Log.d(TAG, <span class="hljs-string">&quot;===================A 发送的事件 &quot;</span> + s1);        <span class="hljs-keyword">return</span> s1;    &#125;&#125;),Observable.intervalRange(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS)    .map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Long, <span class="hljs-built_in">String</span> &gt; () &#123;<span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Long aLong) throws Exception &#123;        <span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;B&quot;</span> + aLong;        Log.d(TAG, <span class="hljs-string">&quot;===================B 发送的事件 &quot;</span> + s2);        <span class="hljs-keyword">return</span> s2;    &#125;&#125;),<span class="hljs-keyword">new</span> BiFunction &lt; <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span> &gt; () &#123;<span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(<span class="hljs-built_in">String</span> s, <span class="hljs-built_in">String</span> s2) throws Exception &#123;        <span class="hljs-built_in">String</span> res = s + s2;        <span class="hljs-keyword">return</span> res;    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-built_in">String</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================最终接收到的事件 &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>分析上面的代码，Observable A 会每隔1秒就发送一次事件，Observable B 会隔2秒发送一次事件。来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">20.859</span> <span class="hljs-number">15104</span><span class="hljs-number">-15104</span>/? D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">21.859</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">22.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">22.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">22.862</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A2B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">23.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A3===================最终接收到的事件 A3B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">24.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">24.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">24.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">24.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">26.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">26.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">28.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">28.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B5<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B5===================onComplete 复制代码</code></pre><p>分析上述结果可以知道，当发送 A1 事件之后，因为 B 并没有发送任何事件，所以根本不会发生结合。当 B 发送了 B1 事件之后，就会与 A 最近发送的事件 A2 结合成 A2B1，这样只有后面一有被观察者发送事件，这个事件就会与其他被观察者最近发送的事件结合起来了。</p><p>因为 combineLatestDelayError() 就是多了延迟发送 onError() 功能，这里就不再赘述了。</p><h2 id="3-7-reduce"><a href="#3-7-reduce" class="headerlink" title="3.7 reduce()"></a>3.7 reduce()</h2><h4 id="方法预览：-26"><a href="#方法预览：-26" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs excel">public final Maybe&lt;<span class="hljs-built_in">T</span>&gt; reduce(BiFunction&lt;<span class="hljs-built_in">T</span>, <span class="hljs-built_in">T</span>, <span class="hljs-built_in">T</span>&gt; reducer)复制代码</code></pre><h4 id="有什么用？-25"><a href="#有什么用？-25" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 scan() 操作符的作用也是将发送数据以一定逻辑聚合起来，这两个的区别在于 scan() 每处理一次数据就会将事件发送给观察者，而 reduce() 会将所有数据聚合在一起才会发送事件给观察者。</p><h4 id="怎么用？-25"><a href="#怎么用？-25" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reduce(<span class="hljs-literal">new</span> BiFunction &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>, <span class="hljs-built_in">Integer</span> integer2) throws Exception &#123;        int res = <span class="hljs-built_in">integer</span> + integer2;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================integer &quot;</span> + <span class="hljs-built_in">integer</span>);        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================integer2 &quot;</span> + integer2);        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================res &quot;</span> + res);        <span class="hljs-keyword">return</span> res;    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================accept &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">46.042</span> <span class="hljs-number">17775</span><span class="hljs-number">-17775</span>/? D/chan: ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">0</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">1</span>====================res <span class="hljs-number">1</span>====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">1</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">2</span>====================res <span class="hljs-number">3</span>====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">3</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">3</span>====================res <span class="hljs-number">6</span>==================accept <span class="hljs-number">6</span>复制代码</code></pre><p>从结果可以看到，其实就是前2个数据聚合之后，然后再与后1个数据进行聚合，一直到没有数据为止。</p><h2 id="3-8-collect"><a href="#3-8-collect" class="headerlink" title="3.8 collect()"></a>3.8 collect()</h2><h4 id="方法预览：-27"><a href="#方法预览：-27" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;U&gt; Single&lt;U&gt; <span class="hljs-keyword">collect</span>(Callable&lt;? <span class="hljs-keyword">extends</span> U&gt; initialValueSupplier, BiConsumer&lt;? <span class="hljs-keyword">super</span> U, ? <span class="hljs-keyword">super</span> T&gt; collector)复制代码</code></pre><h4 id="有什么用？-26"><a href="#有什么用？-26" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将数据收集到数据结构当中。</p><h4 id="怎么用？-26"><a href="#怎么用？-26" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).collect(<span class="hljs-built_in">new</span> Callable &lt; ArrayList &lt; <span class="hljs-type">Integer</span> &gt;&gt; () &#123;    @Override    <span class="hljs-built_in">public</span> ArrayList &lt; <span class="hljs-type">Integer</span> &gt; <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ArrayList &lt; &gt; ();    &#125;&#125;,<span class="hljs-built_in">new</span> BiConsumer &lt; ArrayList &lt; <span class="hljs-type">Integer</span> &gt; , <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(ArrayList &lt; <span class="hljs-type">Integer</span> &gt; integers, <span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        integers.<span class="hljs-keyword">add</span>(<span class="hljs-type">integer</span>);    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; ArrayList &lt; <span class="hljs-type">Integer</span> &gt;&gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(ArrayList &lt; <span class="hljs-type">Integer</span> &gt; integers) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===============accept &quot; + integers);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">16</span>:<span class="hljs-number">47</span>:<span class="hljs-number">18.257</span> <span class="hljs-number">31361</span><span class="hljs-number">-31361</span>/com.example.rxjavademo D/chan: ===============accept [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]复制代码</code></pre><h2 id="3-9-startWith-amp-startWithArray"><a href="#3-9-startWith-amp-startWithArray" class="headerlink" title="3.9 startWith() &amp; startWithArray()"></a>3.9 startWith() &amp; startWithArray()</h2><h4 id="方法预览：-28"><a href="#方法预览：-28" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; startWith(T item)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; startWithArray(T... items)复制代码</code></pre><h4 id="有什么用？-27"><a href="#有什么用？-27" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。</p><h4 id="怎么用？-27"><a href="#怎么用？-27" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs angelscript">Observable.just(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).startWithArray(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).startWith(<span class="hljs-number">1</span>).subscribe(new Consumer &lt; Integer &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> accept(Integer <span class="hljs-built_in">int</span>eger) throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;================accept &quot;</span> + <span class="hljs-built_in">int</span>eger);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">17</span>:<span class="hljs-number">08</span>:<span class="hljs-number">21.282</span> <span class="hljs-number">4505</span><span class="hljs-number">-4505</span>/com.example.rxjavademo D/chan: ================accept <span class="hljs-number">1</span>================accept <span class="hljs-number">2</span>================accept <span class="hljs-number">3</span>================accept <span class="hljs-number">4</span>================accept <span class="hljs-number">5</span>================accept <span class="hljs-number">6</span>================accept <span class="hljs-number">7</span>复制代码</code></pre><h2 id="3-10-count"><a href="#3-10-count" class="headerlink" title="3.10 count()"></a>3.10 count()</h2><h4 id="方法预览：-29"><a href="#方法预览：-29" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;<span class="hljs-keyword">Long</span>&gt; <span class="hljs-keyword">count</span>()复制代码</code></pre><h4 id="有什么用？-28"><a href="#有什么用？-28" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>返回被观察者发送事件的数量。</p><h4 id="怎么用？-28"><a href="#怎么用？-28" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs gradle">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-keyword">count</span>().subscribe(<span class="hljs-keyword">new</span> Consumer &lt; <span class="hljs-keyword">Long</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> accept(<span class="hljs-keyword">Long</span> aLong) <span class="hljs-keyword">throws</span> Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;=======================aLong &quot;</span> + aLong);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">20</span>:<span class="hljs-number">41</span>:<span class="hljs-number">25.025</span> <span class="hljs-number">14126</span><span class="hljs-number">-14126</span>/? D/chan: =======================aLong <span class="hljs-number">3</span>复制代码</code></pre><h1 id="4-功能操作符"><a href="#4-功能操作符" class="headerlink" title="4. 功能操作符"></a>4. 功能操作符</h1><h2 id="4-1-delay"><a href="#4-1-delay" class="headerlink" title="4.1 delay()"></a>4.1 delay()</h2><h4 id="方法预览：-30"><a href="#方法预览：-30" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> final Observable&lt;T&gt; <span class="hljs-title">delay</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> delay, TimeUnit <span class="hljs-built_in">unit</span></span>)</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-29"><a href="#有什么用？-29" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>延迟一段事件发送事件。</p><h4 id="怎么用？-29"><a href="#怎么用？-29" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).delay(<span class="hljs-number">2</span>, TimeUnit.SECONDS).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=======================onSubscribe&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=======================onNext &quot;</span> + integer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=======================onSubscribe&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>这里延迟了两秒才发送事件，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">43.618</span> <span class="hljs-number">16880</span><span class="hljs-number">-16880</span>/com.example.rxjavademo D/chan: =======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">45.620</span> <span class="hljs-number">16880</span><span class="hljs-number">-16906</span>/com.example.rxjavademo D/chan: =======================onNext <span class="hljs-number">1</span><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">45.621</span> <span class="hljs-number">16880</span><span class="hljs-number">-16906</span>/com.example.rxjavademo D/chan: =======================onNext <span class="hljs-number">2</span>=======================onNext <span class="hljs-number">3</span>=======================onSubscribe复制代码</code></pre><p>从打印结果可以看出 onSubscribe 回调2秒之后 onNext 才会回调。</p><h2 id="4-2-doOnEach"><a href="#4-2-doOnEach" class="headerlink" title="4.2 doOnEach()"></a>4.2 doOnEach()</h2><h4 id="方法预览：-31"><a href="#方法预览：-31" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">OnEach(<span class="hljs-params">final</span> Consumer&lt;? <span class="hljs-params">super</span> Notification&lt;T&gt;&gt; <span class="hljs-params">onNotification</span>)</span>复制代码</code></pre><h4 id="有什么用？-30"><a href="#有什么用？-30" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送一件事件之前都会先回调这个方法。</p><h4 id="怎么用？-30"><a href="#怎么用？-30" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        <span class="hljs-comment">//      e.onError(new NumberFormatException());</span>        e.onComplete();    &#125;&#125;).doOnEach(<span class="hljs-literal">new</span> Consumer &lt; Notification &lt; <span class="hljs-built_in">Integer</span> &gt;&gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(Notification &lt; <span class="hljs-built_in">Integer</span> &gt; integerNotification) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnEach &quot;</span> + integerNotification.getValue());    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">07</span>:<span class="hljs-number">05.547</span> <span class="hljs-number">19867</span><span class="hljs-number">-19867</span>/? D/chan: ==================onSubscribe ==================doOnEach <span class="hljs-number">1</span>==================onNext <span class="hljs-number">1</span>==================doOnEach <span class="hljs-number">2</span>==================onNext <span class="hljs-number">2</span>==================doOnEach <span class="hljs-number">3</span>==================onNext <span class="hljs-number">3</span>==================doOnEach <span class="hljs-literal">null</span>==================onComplete 复制代码</code></pre><p>从结果就可以看出每发送一个事件之前都会回调 doOnEach 方法，并且可以取出 onNext() 发送的值。</p><h2 id="4-3-doOnNext"><a href="#4-3-doOnNext" class="headerlink" title="4.3 doOnNext()"></a>4.3 doOnNext()</h2><h4 id="方法预览：-32"><a href="#方法预览：-32" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">OnNext(Consumer&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">onNext</span>)</span>复制代码</code></pre><h4 id="有什么用？-31"><a href="#有什么用？-31" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onNext() 之前都会先回调这个方法。</p><h4 id="怎么用？-31"><a href="#怎么用？-31" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnNext(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">09</span>:<span class="hljs-number">36.769</span> <span class="hljs-number">20020</span><span class="hljs-number">-20020</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================doOnNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">1</span>==================doOnNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">2</span>==================doOnNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><h2 id="4-4-doAfterNext"><a href="#4-4-doAfterNext" class="headerlink" title="4.4 doAfterNext()"></a>4.4 doAfterNext()</h2><h4 id="方法预览：-33"><a href="#方法预览：-33" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">AfterNext(Consumer&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">onAfterNext</span>)</span>复制代码</code></pre><h4 id="有什么用？-32"><a href="#有什么用？-32" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onNext() 之后都会回调这个方法。</p><h4 id="怎么用？-32"><a href="#怎么用？-32" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doAfterNext(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doAfterNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">15</span>:<span class="hljs-number">49.215</span> <span class="hljs-number">20432</span><span class="hljs-number">-20432</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================doAfterNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================doAfterNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================doAfterNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><h2 id="4-5-doOnComplete"><a href="#4-5-doOnComplete" class="headerlink" title="4.5 doOnComplete()"></a>4.5 doOnComplete()</h2><h4 id="方法预览：-34"><a href="#方法预览：-34" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doOnComplete(<span class="hljs-keyword">Action</span> onComplete)复制代码</code></pre><h4 id="有什么用？-33"><a href="#有什么用？-33" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onComplete() 之前都会回调这个方法。</p><h4 id="怎么用？-33"><a href="#怎么用？-33" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnComplete(<span class="hljs-literal">new</span> Action() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> run() throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnComplete &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">32</span>:<span class="hljs-number">18.031</span> <span class="hljs-number">20751</span><span class="hljs-number">-20751</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================doOnComplete ==================onComplete 复制代码</code></pre><h2 id="4-6-doOnError"><a href="#4-6-doOnError" class="headerlink" title="4.6 doOnError()"></a>4.6 doOnError()</h2><h4 id="方法预览：-35"><a href="#方法预览：-35" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doOnError(Consumer<span class="hljs-meta">&lt;?</span> super <span class="hljs-built_in">Throwable</span>&gt; onError)复制代码</code></pre><h4 id="有什么用？-34"><a href="#有什么用？-34" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onError() 之前都会回调这个方法。</p><h4 id="怎么用？-34"><a href="#怎么用？-34" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-literal">new</span> NullPointerException());    &#125;&#125;).doOnError(<span class="hljs-literal">new</span> Consumer &lt; Throwable &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(Throwable throwable) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnError &quot;</span> + throwable);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">04.150</span> <span class="hljs-number">21051</span><span class="hljs-number">-21051</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================doOnError java.lang.NullPointerException==================onError 复制代码</code></pre><h2 id="4-7-doOnSubscribe"><a href="#4-7-doOnSubscribe" class="headerlink" title="4.7 doOnSubscribe()"></a>4.7 doOnSubscribe()</h2><h4 id="方法预览：-36"><a href="#方法预览：-36" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">OnSubscribe(Consumer&lt;? <span class="hljs-params">super</span> Disposable&gt; <span class="hljs-params">onSubscribe</span>)</span>复制代码</code></pre><h4 id="有什么用？-35"><a href="#有什么用？-35" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onSubscribe() 之前都会回调这个方法。</p><h4 id="怎么用？-35"><a href="#怎么用？-35" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnSubscribe(<span class="hljs-literal">new</span> Consumer &lt; Disposable &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(Disposable disposable) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnSubscribe &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">39</span>:<span class="hljs-number">25.778</span> <span class="hljs-number">21245</span><span class="hljs-number">-21245</span>/? D/chan: ==================doOnSubscribe ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><h2 id="4-8-doOnDispose"><a href="#4-8-doOnDispose" class="headerlink" title="4.8 doOnDispose()"></a>4.8 doOnDispose()</h2><h4 id="方法预览：-37"><a href="#方法预览：-37" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doOnDispose(<span class="hljs-keyword">Action</span> onDispose)复制代码</code></pre><h4 id="有什么用？-36"><a href="#有什么用？-36" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当调用 Disposable 的 dispose() 之后回调该方法。</p><h4 id="怎么用？-36"><a href="#怎么用？-36" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnDispose(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Action</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doOnDispose &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;    <span class="hljs-keyword">private</span> Disposable d;        <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);        <span class="hljs-built_in">this</span>.d = d;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);        d.dispose();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">48.122</span> <span class="hljs-number">22023</span><span class="hljs-number">-22023</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================doOnDispose 复制代码</code></pre><h2 id="4-9-doOnLifecycle"><a href="#4-9-doOnLifecycle" class="headerlink" title="4.9 doOnLifecycle()"></a>4.9 doOnLifecycle()</h2><h4 id="方法预览：-38"><a href="#方法预览：-38" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">OnLifecycle(<span class="hljs-params">final</span> Consumer&lt;? <span class="hljs-params">super</span> Disposable&gt; <span class="hljs-params">onSubscribe</span>, <span class="hljs-params">final</span> Action <span class="hljs-params">onDispose</span>)</span>复制代码</code></pre><h4 id="有什么用？-37"><a href="#有什么用？-37" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅。</p><h4 id="怎么用？-37"><a href="#怎么用？-37" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>doOnLifecycle() 第二个参数的回调方法的作用与 doOnDispose() 是一样的，现在用下面的例子来讲解：</p><pre><code class="hljs aspectj">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnLifecycle(<span class="hljs-keyword">new</span> Consumer&lt;Disposable&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Disposable disposable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doOnLifecycle accept&quot;</span>);    &#125;&#125;, <span class="hljs-keyword">new</span> Action() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doOnLifecycle Action&quot;</span>);    &#125;&#125;).doOnDispose(    <span class="hljs-keyword">new</span> Action() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            Log.d(TAG, <span class="hljs-string">&quot;==================doOnDispose Action&quot;</span>);        &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer&lt;Integer&gt;() &#123;    <span class="hljs-keyword">private</span> Disposable d;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);        <span class="hljs-keyword">this</span>.d = d;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Integer integer)</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);        d.dispose();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;    &#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">20</span>:<span class="hljs-number">36.345</span> <span class="hljs-number">23922</span><span class="hljs-number">-23922</span>/? D/chan: ==================doOnLifecycle accept==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================doOnDispose Action==================doOnLifecycle Action复制代码</code></pre><p>可以看到当在 onNext() 方法进行取消订阅操作后，doOnDispose() 和 doOnLifecycle() 都会被回调。</p><p>如果使用 doOnLifecycle 进行取消订阅，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20.014</span> <span class="hljs-number">24652</span><span class="hljs-number">-24652</span>/com.example.rxjavademo D/chan: ==================doOnLifecycle accept==================onSubscribe 复制代码</code></pre><p>可以发现 doOnDispose Action 和 doOnLifecycle Action 都没有被回调。</p><h2 id="4-10-doOnTerminate-amp-doAfterTerminate"><a href="#4-10-doOnTerminate-amp-doAfterTerminate" class="headerlink" title="4.10 doOnTerminate() &amp; doAfterTerminate()"></a>4.10 doOnTerminate() &amp; doAfterTerminate()</h2><h4 id="方法预览：-39"><a href="#方法预览：-39" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doOnTerminate(<span class="hljs-keyword">final</span> <span class="hljs-keyword">Action</span> onTerminate)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doAfterTerminate(<span class="hljs-keyword">Action</span> onFinally)复制代码</code></pre><h4 id="有什么用？-38"><a href="#有什么用？-38" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。</p><h4 id="怎么用？-38"><a href="#怎么用？-38" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-built_in">Integer</span>&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);<span class="hljs-comment">//      e.onError(new NullPointerException());</span>        e.onComplete();    &#125;&#125;).doOnTerminate(<span class="hljs-literal">new</span> Action() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> run() throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnTerminate &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;    &#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">39.503</span> <span class="hljs-number">22398</span><span class="hljs-number">-22398</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">39.504</span> <span class="hljs-number">22398</span><span class="hljs-number">-22398</span>/com.example.rxjavademo D/chan: ==================onNext <span class="hljs-number">3</span>==================doOnTerminate ==================onComplete 复制代码</code></pre><p>doAfterTerminate 也是差不多，这里就不再赘述。</p><h2 id="4-11-doFinally"><a href="#4-11-doFinally" class="headerlink" title="4.11 doFinally()"></a>4.11 doFinally()</h2><h4 id="方法预览：-40"><a href="#方法预览：-40" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doFinally(<span class="hljs-keyword">Action</span> onFinally)复制代码</code></pre><h4 id="有什么用？-39"><a href="#有什么用？-39" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在所有事件发送完毕之后回调该方法。</p><h4 id="怎么用？-39"><a href="#怎么用？-39" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>这里可能你会有个问题，那就是 doFinally() 和 doAfterTerminate() 到底有什么区别？区别就是在于取消订阅，如果取消订阅之后 doAfterTerminate() 就不会被回调，而 doFinally() 无论怎么样都会被回调，且都会在事件序列的最后。</p><p>现在用以下例子说明下：</p><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doFinally(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Action</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doFinally &quot;</span>);    &#125;&#125;).doOnDispose(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Action</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doOnDispose &quot;</span>);    &#125;&#125;).doAfterTerminate(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Action</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doAfterTerminate &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer&lt;Integer&gt;() &#123;    <span class="hljs-keyword">private</span> Disposable d;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);        <span class="hljs-built_in">this</span>.d = d;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);        d.dispose();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">10</span>:<span class="hljs-number">10.469</span> <span class="hljs-number">23196</span><span class="hljs-number">-23196</span>/? D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">10</span>:<span class="hljs-number">10.470</span> <span class="hljs-number">23196</span><span class="hljs-number">-23196</span>/? D/chan: ==================onNext <span class="hljs-number">1</span>==================doOnDispose ==================doFinally 复制代码</code></pre><p>可以看到如果调用了 dispose() 方法，doAfterTerminate() 不会被回调。</p><p>现在试试把 dispose() 注释掉看看，看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">34.537</span> <span class="hljs-number">23439</span><span class="hljs-number">-23439</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onComplete ==================doAfterTerminate ==================doFinally 复制代码</code></pre><p>doAfterTerminate() 已经成功回调，doFinally() 还是会在事件序列的最后。</p><h2 id="4-12-onErrorReturn"><a href="#4-12-onErrorReturn" class="headerlink" title="4.12 onErrorReturn()"></a>4.12 onErrorReturn()</h2><h4 id="方法预览：-41"><a href="#方法预览：-41" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; onErrorReturn(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super Throwable, ? <span class="hljs-keyword">extends</span> T&gt; valueSupplier)复制代码</code></pre><h4 id="有什么用？-40"><a href="#有什么用？-40" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。</p><h4 id="怎么用？-40"><a href="#怎么用？-40" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-built_in">Integer</span>&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-literal">new</span> NullPointerException());    &#125;&#125;).onErrorReturn(<span class="hljs-literal">new</span> Function&lt;Throwable, <span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(Throwable throwable) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onErrorReturn &quot;</span> + throwable);        <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>;    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">18</span>:<span class="hljs-number">35</span>:<span class="hljs-number">18.175</span> <span class="hljs-number">19239</span><span class="hljs-number">-19239</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onErrorReturn java.lang.NullPointerException==================onNext <span class="hljs-number">404</span>==================onComplete 复制代码</code></pre><h2 id="4-13-onErrorResumeNext"><a href="#4-13-onErrorResumeNext" class="headerlink" title="4.13 onErrorResumeNext()"></a>4.13 onErrorResumeNext()</h2><h4 id="方法预览：-42"><a href="#方法预览：-42" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; onErrorResumeNext(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super Throwable, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> T&gt;&gt; resumeFunction)复制代码</code></pre><h4 id="有什么用？-41"><a href="#有什么用？-41" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。</p><h4 id="怎么用？-41"><a href="#怎么用？-41" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-built_in">Integer</span>&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-literal">new</span> NullPointerException());    &#125;&#125;).onErrorResumeNext(<span class="hljs-literal">new</span> Function&lt;Throwable, ObservableSource&lt;? extends <span class="hljs-built_in">Integer</span>&gt;&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> ObservableSource&lt;? extends <span class="hljs-built_in">Integer</span>&gt; apply(Throwable throwable) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onErrorResumeNext &quot;</span> + throwable);        <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">10.910</span> <span class="hljs-number">26469</span><span class="hljs-number">-26469</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onErrorResumeNext java.lang.NullPointerException==================onNext <span class="hljs-number">4</span>==================onNext <span class="hljs-number">5</span>==================onNext <span class="hljs-number">6</span>==================onComplete 复制代码</code></pre><h2 id="4-14-onExceptionResumeNext"><a href="#4-14-onExceptionResumeNext" class="headerlink" title="4.14 onExceptionResumeNext()"></a>4.14 onExceptionResumeNext()</h2><h4 id="方法预览：-43"><a href="#方法预览：-43" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; onExceptionResumeNext(<span class="hljs-keyword">final</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> T&gt; <span class="hljs-keyword">next</span>)复制代码</code></pre><h4 id="有什么用？-42"><a href="#有什么用？-42" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。</p><h4 id="怎么用？-42"><a href="#怎么用？-42" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>先来试试 onExceptionResumeNext() 是否能捕捉 Error。</p><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;404&quot;</span>));    &#125;&#125;).onExceptionResumeNext(<span class="hljs-keyword">new</span> Observable&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">subscribeActual</span>(<span class="hljs-params">Observer&lt;? <span class="hljs-built_in">super</span> Integer&gt; observer</span>)</span> &#123;        observer.onNext(<span class="hljs-number">333</span>);        observer.onComplete();    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">23</span>:<span class="hljs-number">08.873</span> <span class="hljs-number">1062</span><span class="hljs-number">-1062</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">23</span>:<span class="hljs-number">08.874</span> <span class="hljs-number">1062</span><span class="hljs-number">-1062</span>/com.example.louder.rxjavademo D/chan: ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onError 复制代码</code></pre><p>从打印结果可以知道，观察者收到 onError() 事件，证明 onErrorResumeNext() 不能捕捉 Error 事件。</p><p>将被观察者的 e.onError(new Error(“404”)) 改为 e.onError(new Exception(“404”))，现在看看是否能捕捉 Exception 事件：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">14.563</span> <span class="hljs-number">10487</span><span class="hljs-number">-10487</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">333</span>==================onComplete 复制代码</code></pre><p>从打印结果可以知道，这个方法成功捕获 Exception 事件。</p><h2 id="4-15-retry"><a href="#4-15-retry" class="headerlink" title="4.15 retry()"></a>4.15 retry()</h2><h4 id="方法预览：-44"><a href="#方法预览：-44" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-keyword">retry</span>(<span class="hljs-built_in">long</span> times)......复制代码</code></pre><h4 id="有什么用？-43"><a href="#有什么用？-43" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。</p><h4 id="怎么用？-43"><a href="#怎么用？-43" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-built_in">Integer</span>&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-literal">new</span> Exception(<span class="hljs-string">&quot;404&quot;</span>));    &#125;&#125;).retry(<span class="hljs-number">2</span>).subscribe(<span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18.537</span> <span class="hljs-number">22239</span><span class="hljs-number">-22239</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18.538</span> <span class="hljs-number">22239</span><span class="hljs-number">-22239</span>/com.example.louder.rxjavademo D/chan: ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onError 复制代码</code></pre><h2 id="4-16-retryUntil"><a href="#4-16-retryUntil" class="headerlink" title="4.16 retryUntil()"></a>4.16 retryUntil()</h2><h4 id="方法预览：-45"><a href="#方法预览：-45" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; retryUntil(<span class="hljs-keyword">final</span> BooleanSupplier <span class="hljs-keyword">stop</span>)复制代码</code></pre><h4 id="有什么用？-44"><a href="#有什么用？-44" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>出现错误事件之后，可以通过此方法判断是否继续发送事件。</p><h4 id="怎么用？-44"><a href="#怎么用？-44" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;404&quot;</span>));    &#125;&#125;).retryUntil(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">BooleanSupplier</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> getAsBoolean() throws Exception &#123;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">6</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        i += integer;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">57</span>:<span class="hljs-number">32.905</span> <span class="hljs-number">23063</span><span class="hljs-number">-23063</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">57</span>:<span class="hljs-number">32.906</span> <span class="hljs-number">23063</span><span class="hljs-number">-23063</span>/com.example.louder.rxjavademo D/chan: ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onError 复制代码</code></pre><h2 id="4-17-retryWhen"><a href="#4-17-retryWhen" class="headerlink" title="4.17 retryWhen()"></a>4.17 retryWhen()</h2><h4 id="方法预览：-46"><a href="#方法预览：-46" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> safeSubscribe(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; s)复制代码</code></pre><h4 id="有什么用？-45"><a href="#有什么用？-45" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件。</p><h4 id="怎么用？-45"><a href="#怎么用？-45" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs php">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; <span class="hljs-keyword">String</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-keyword">String</span> &gt; e) throws <span class="hljs-built_in">Exception</span> &#123;        e.onNext(<span class="hljs-string">&quot;chan&quot;</span>);        e.onNext(<span class="hljs-string">&quot;ze&quot;</span>);        e.onNext(<span class="hljs-string">&quot;de&quot;</span>);        e.onError(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&quot;404&quot;</span>));        e.onNext(<span class="hljs-string">&quot;haha&quot;</span>);    &#125;&#125;).retryWhen(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span> &lt; <span class="hljs-title">Observable</span> &lt; <span class="hljs-title">Throwable</span> &gt; , <span class="hljs-title">ObservableSource</span> &lt;? &gt;&gt; (<span class="hljs-params"></span>) </span>&#123;    @Override    <span class="hljs-keyword">public</span> ObservableSource <span class="hljs-meta">&lt;?</span> &gt; apply(Observable &lt; <span class="hljs-built_in">Throwable</span> &gt; throwableObservable) throws <span class="hljs-built_in">Exception</span> &#123;        <span class="hljs-keyword">return</span> throwableObservable.flatMap(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span> &lt; <span class="hljs-title">Throwable</span>, <span class="hljs-title">ObservableSource</span> &lt;? &gt;&gt; (<span class="hljs-params"></span>) </span>&#123;            @Override            <span class="hljs-keyword">public</span> ObservableSource <span class="hljs-meta">&lt;?</span> &gt; apply(<span class="hljs-built_in">Throwable</span> <span class="hljs-built_in">throwable</span>) throws <span class="hljs-built_in">Exception</span> &#123;                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">throwable</span>.toString().equals(<span class="hljs-string">&quot;java.lang.Exception: 404&quot;</span>)) &#123;                    <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-string">&quot;可以忽略的异常&quot;</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span> Observable.<span class="hljs-built_in">error</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Throwable</span>(<span class="hljs-string">&quot;终止啦&quot;</span>));                &#125;            &#125;        &#125;);    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-keyword">String</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onSubscribe(Disposable d) &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onNext(<span class="hljs-keyword">String</span> s) &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + s);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onError(<span class="hljs-built_in">Throwable</span> e) &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span> + e.toString());    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onComplete() &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">09</span>:<span class="hljs-number">13</span>:<span class="hljs-number">25.622</span> <span class="hljs-number">28372</span><span class="hljs-number">-28372</span>/com.example.rxjavademo D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">09</span>:<span class="hljs-number">13</span>:<span class="hljs-number">25.623</span> <span class="hljs-number">28372</span><span class="hljs-number">-28372</span>/com.example.rxjavademo D/chan: ==================onNext chan==================onNext ze==================onNext de<span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">09</span>:<span class="hljs-number">13</span>:<span class="hljs-number">25.624</span> <span class="hljs-number">28372</span><span class="hljs-number">-28372</span>/com.example.rxjavademo D/chan: ==================onError java.lang.Throwable: 终止啦复制代码</code></pre><p>将 onError(new Exception(“404”)) 改为 onError(new Exception(“303”)) 看看打印结果：</p><pre><code class="hljs diff"><span class="hljs-comment">==================onNext chan</span>05-24 09:54:08.653 29694-29694/? D/chan: <span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span><span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span><span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span><span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span><span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span>......复制代码</code></pre><p>从结果可以看出，会不断重复发送消息。</p><h2 id="4-18-repeat"><a href="#4-18-repeat" class="headerlink" title="4.18 repeat()"></a>4.18 repeat()</h2><h4 id="方法预览：-47"><a href="#方法预览：-47" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; repeat(<span class="hljs-keyword">long</span> <span class="hljs-keyword">times</span>)......复制代码</code></pre><h4 id="有什么用？-46"><a href="#有什么用？-46" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>重复发送被观察者的事件，times 为发送次数。</p><h4 id="怎么用？-46"><a href="#怎么用？-46" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).repeat(<span class="hljs-number">2</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + integer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">29.565</span> <span class="hljs-number">8544</span><span class="hljs-number">-8544</span>/com.example.rxjavademo D/chan: ===================onSubscribe ===================onNext <span class="hljs-number">1</span>===================onNext <span class="hljs-number">2</span>===================onNext <span class="hljs-number">3</span>===================onNext <span class="hljs-number">1</span>===================onNext <span class="hljs-number">2</span>===================onNext <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">29.565</span> <span class="hljs-number">8544</span><span class="hljs-number">-8544</span>/com.example.rxjavademo D/chan: ===================onComplete 复制代码</code></pre><p>从结果可以看出，该事件发送了两次。</p><h2 id="4-19-repeatWhen"><a href="#4-19-repeatWhen" class="headerlink" title="4.19 repeatWhen()"></a>4.19 repeatWhen()</h2><h4 id="方法预览：-48"><a href="#方法预览：-48" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; repeatWhen(<span class="hljs-keyword">final</span> Function&lt;? <span class="hljs-keyword">super</span> Observable&lt;Object&gt;, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;?&gt;&gt; <span class="hljs-keyword">handler</span>)复制代码</code></pre><h4 id="有什么用？-47"><a href="#有什么用？-47" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件。</p><h4 id="怎么用？-47"><a href="#怎么用？-47" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>这里分三种情况，如果新的被观察者返回 onComplete 或者 onError 事件，则旧的被观察者不会继续发送事件。如果被观察者返回其他事件，则会重复发送事件。</p><p>现在试验发送 onComplete 事件，代码如下：</p><pre><code class="hljs pgsql">Observable.<span class="hljs-keyword">create</span>(<span class="hljs-built_in">new</span> ObservableOnSubscribe &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-type">Integer</span> &gt; e) throws <span class="hljs-keyword">Exception</span> &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).repeatWhen(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Function</span> &lt; Observable &lt; <span class="hljs-keyword">Object</span> &gt; , ObservableSource &lt;? &gt;&gt; () &#123;    @Override    <span class="hljs-built_in">public</span> ObservableSource &lt;? &gt; apply(Observable &lt; <span class="hljs-keyword">Object</span> &gt; objectObservable) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> Observable.empty();    //  <span class="hljs-keyword">return</span> Observable.error(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Exception</span>(&quot;404&quot;));    //  <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-number">4</span>); <span class="hljs-keyword">null</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Observer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===================onSubscribe &quot;);    &#125;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onNext(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===================onNext &quot; + <span class="hljs-type">integer</span>);    &#125;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===================onError &quot;);    &#125;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===================onComplete &quot;);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">44</span>:<span class="hljs-number">33.486</span> <span class="hljs-number">9379</span><span class="hljs-number">-9379</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">44</span>:<span class="hljs-number">33.487</span> <span class="hljs-number">9379</span><span class="hljs-number">-9379</span>/com.example.rxjavademo D/chan: ===================onComplete 复制代码</code></pre><p>下面直接看看发送 onError 事件和其他事件的打印结果。</p><p>发送 onError 打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">46</span>:<span class="hljs-number">29.507</span> <span class="hljs-number">9561</span><span class="hljs-number">-9561</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">46</span>:<span class="hljs-number">29.508</span> <span class="hljs-number">9561</span><span class="hljs-number">-9561</span>/com.example.rxjavademo D/chan: ===================onError 复制代码</code></pre><p>发送其他事件的打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">35.844</span> <span class="hljs-number">9752</span><span class="hljs-number">-9752</span>/com.example.rxjavademo D/chan: ===================onSubscribe ===================onNext <span class="hljs-number">1</span>===================onNext <span class="hljs-number">2</span>===================onNext <span class="hljs-number">3</span>===================onComplete 复制代码</code></pre><h2 id="4-20-subscribeOn"><a href="#4-20-subscribeOn" class="headerlink" title="4.20 subscribeOn()"></a>4.20 subscribeOn()</h2><h4 id="方法预览：-49"><a href="#方法预览：-49" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; subscribeOn(Scheduler scheduler)复制代码</code></pre><h4 id="有什么用？-48"><a href="#有什么用？-48" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效。</p><h4 id="怎么用？-48"><a href="#怎么用？-48" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=========================currentThread name: &quot;</span> + <span class="hljs-keyword">Thread</span>.currentThread().getName());        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;)<span class="hljs-comment">//.subscribeOn(Schedulers.newThread())</span>.subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>现在不调用 subscribeOn() 方法，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">42.246</span> <span class="hljs-number">21466</span><span class="hljs-number">-21466</span>/? D/chan: ======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">42.247</span> <span class="hljs-number">21466</span><span class="hljs-number">-21466</span>/? D/chan: =========================currentThread name: main======================onNext <span class="hljs-number">1</span>======================onNext <span class="hljs-number">2</span>======================onNext <span class="hljs-number">3</span>======================onComplete复制代码</code></pre><p>可以看到打印被观察者的线程名字是主线程。</p><p>接着调用 subscribeOn(Schedulers.newThread()) 来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">43</span>:<span class="hljs-number">26.964</span> <span class="hljs-number">22530</span><span class="hljs-number">-22530</span>/com.example.rxjavademo D/chan: ======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">43</span>:<span class="hljs-number">26.966</span> <span class="hljs-number">22530</span><span class="hljs-number">-22569</span>/com.example.rxjavademo D/chan: =========================currentThread name: RxNewThreadScheduler<span class="hljs-number">-1</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">43</span>:<span class="hljs-number">26.967</span> <span class="hljs-number">22530</span><span class="hljs-number">-22569</span>/com.example.rxjavademo D/chan: ======================onNext <span class="hljs-number">1</span>======================onNext <span class="hljs-number">2</span>======================onNext <span class="hljs-number">3</span>======================onComplete复制代码</code></pre><p>可以看到打印结果被观察者是在一条新的线程。</p><p>现在看看多次调用会不会有效，代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; Integer &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=========================currentThread name: &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);        e.on<span class="hljs-constructor">Next(1)</span>;        e.on<span class="hljs-constructor">Next(2)</span>;        e.on<span class="hljs-constructor">Next(3)</span>;        e.on<span class="hljs-constructor">Complete()</span>;    &#125;&#125;).subscribe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">computation</span>()</span>).subscribe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">newThread</span>()</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; <span class="hljs-literal">()</span> &#123;@Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Next(Integer <span class="hljs-params">integer</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onNext &quot;</span> + integer);    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">20.925</span> <span class="hljs-number">23590</span><span class="hljs-number">-23590</span>/com.example.rxjavademo D/chan: ======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">20.930</span> <span class="hljs-number">23590</span><span class="hljs-number">-23629</span>/com.example.rxjavademo D/chan: =========================currentThread name: RxComputationThreadPool<span class="hljs-number">-1</span>======================onNext <span class="hljs-number">1</span>======================onNext <span class="hljs-number">2</span>======================onNext <span class="hljs-number">3</span>======================onComplete复制代码</code></pre><p>可以看到第二次调动的 subscribeOn(Schedulers.newThread()) 并没有效果。</p><h2 id="4-21-observeOn"><a href="#4-21-observeOn" class="headerlink" title="4.21 observeOn()"></a>4.21 observeOn()</h2><h4 id="方法预览：-50"><a href="#方法预览：-50" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; observeOn(Scheduler scheduler)复制代码</code></pre><h4 id="有什么用？-49"><a href="#有什么用？-49" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>指定观察者的线程，每指定一次就会生效一次。</p><h4 id="怎么用？-49"><a href="#怎么用？-49" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).observe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">newThread</span>()</span>).flat<span class="hljs-constructor">Map(<span class="hljs-params">new</span> Function &lt; Integer, ObservableSource &lt; String &gt;&gt; ()</span> &#123;    @Override    public ObservableSource &lt; String &gt; apply(Integer integer) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================flatMap Thread name &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-string">&quot;chan&quot;</span> + integer);    &#125;&#125;).observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; String &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Next(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onNext Thread name &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onNext &quot;</span> + s);    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.593</span> <span class="hljs-number">25717</span><span class="hljs-number">-25717</span>/com.example.rxjavademo D/chan: ======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.594</span> <span class="hljs-number">25717</span><span class="hljs-number">-25753</span>/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler<span class="hljs-number">-1</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.595</span> <span class="hljs-number">25717</span><span class="hljs-number">-25753</span>/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler<span class="hljs-number">-1</span>======================flatMap Thread name RxNewThreadScheduler<span class="hljs-number">-1</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.617</span> <span class="hljs-number">25717</span><span class="hljs-number">-25717</span>/com.example.rxjavademo D/chan: ======================onNext Thread name main======================onNext chan1======================onNext Thread name main======================onNext chan2======================onNext Thread name main======================onNext chan3<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.618</span> <span class="hljs-number">25717</span><span class="hljs-number">-25717</span>/com.example.rxjavademo D/chan: ======================onComplete复制代码</code></pre><p>从打印结果可以知道，observeOn 成功切换了线程。</p><p>下表总结了 RxJava 中的调度器：</p><table><thead><tr><th>调度器</th><th>作用</th></tr></thead><tbody><tr><td>Schedulers.computation( )</td><td>用于使用计算任务，如事件循环和回调处理</td></tr><tr><td>Schedulers.immediate( )</td><td>当前线程</td></tr><tr><td>Schedulers.io( )</td><td>用于 IO 密集型任务，如果异步阻塞 IO 操作。</td></tr><tr><td>Schedulers.newThread( )</td><td>创建一个新的线程</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>Android 的 UI 线程，用于操作 UI。</td></tr></tbody></table><h1 id="5-过滤操作符"><a href="#5-过滤操作符" class="headerlink" title="5. 过滤操作符"></a>5. 过滤操作符</h1><h2 id="5-1-filter"><a href="#5-1-filter" class="headerlink" title="5.1 filter()"></a>5.1 filter()</h2><h4 id="方法预览：-51"><a href="#方法预览：-51" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-built_in">filter</span>(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)复制代码</code></pre><h4 id="有什么用？-50"><a href="#有什么用？-50" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送。</p><h4 id="怎么用？-50"><a href="#怎么用？-50" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso"> Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)    .filter(<span class="hljs-literal">new</span> Predicate &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;        @Override        <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> test(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer</span> &lt; <span class="hljs-number">2</span>;        &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>以上代码只有小于2的事件才会发送，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">22</span>:<span class="hljs-number">57</span>:<span class="hljs-number">32.562</span> <span class="hljs-number">12776</span><span class="hljs-number">-12776</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onComplete 复制代码</code></pre><h2 id="5-2-ofType"><a href="#5-2-ofType" class="headerlink" title="5.2 ofType()"></a>5.2 ofType()</h2><h4 id="方法预览：-52"><a href="#方法预览：-52" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs monkey"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;U&gt; Observable&lt;U&gt; ofType(<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">Class</span>&lt;<span class="hljs-title">U</span>&gt; <span class="hljs-title">clazz</span>)</span>复制代码</code></pre><h4 id="有什么用？-51"><a href="#有什么用？-51" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以过滤不符合该类型事件</p><h4 id="怎么用？-51"><a href="#怎么用？-51" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;chan&quot;</span>, <span class="hljs-string">&quot;zhide&quot;</span>).ofType(<span class="hljs-built_in">Integer</span>.class).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">24.752</span> <span class="hljs-number">13229</span><span class="hljs-number">-13229</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">24.753</span> <span class="hljs-number">13229</span><span class="hljs-number">-13229</span>/? D/chan: ==================onComplete 复制代码</code></pre><h2 id="5-3-skip"><a href="#5-3-skip" class="headerlink" title="5.3 skip()"></a>5.3 skip()</h2><h4 id="方法预览：-53"><a href="#方法预览：-53" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; skip(<span class="hljs-built_in">long</span> <span class="hljs-keyword">count</span>).......复制代码</code></pre><h4 id="有什么用？-52"><a href="#有什么用？-52" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>跳过正序某些事件，count 代表跳过事件的数量</p><h4 id="怎么用？-52"><a href="#怎么用？-52" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-keyword">skip</span>(<span class="hljs-number">2</span>).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50.448</span> <span class="hljs-number">13831</span><span class="hljs-number">-13831</span>/? D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50.449</span> <span class="hljs-number">13831</span><span class="hljs-number">-13831</span>/? D/chan: ==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><p>skipLast() 作用也是跳过某些事件，不过它是用来跳过正序的后面的事件，这里就不再讲解了。</p><h2 id="5-4-distinct"><a href="#5-4-distinct" class="headerlink" title="5.4 distinct()"></a>5.4 distinct()</h2><h4 id="方法预览：-54"><a href="#方法预览：-54" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-keyword">distinct</span>() 复制代码</code></pre><h4 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用?"></a>有什么用?</h4><p>过滤事件序列中的重复事件。</p><h4 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>).distinct().subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果:</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">19</span>:<span class="hljs-number">44.334</span> <span class="hljs-number">14206</span><span class="hljs-number">-14206</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><h2 id="5-5-distinctUntilChanged"><a href="#5-5-distinctUntilChanged" class="headerlink" title="5.5 distinctUntilChanged()"></a>5.5 distinctUntilChanged()</h2><h4 id="方法预览：-55"><a href="#方法预览：-55" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; distinctUntilChanged()复制代码</code></pre><h4 id="有什么用？-53"><a href="#有什么用？-53" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>过滤掉连续重复的事件</p><h4 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>).distinctUntilChanged().subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果:</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">22</span>:<span class="hljs-number">35.985</span> <span class="hljs-number">14424</span><span class="hljs-number">-14424</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">1</span>==================onComplete 复制代码</code></pre><p>因为事件序列中连续出现两次3，所以第二次3并不会发出。</p><h2 id="5-6-take"><a href="#5-6-take" class="headerlink" title="5.6 take()"></a>5.6 take()</h2><h4 id="方法预览：-56"><a href="#方法预览：-56" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; take(<span class="hljs-built_in">long</span> <span class="hljs-keyword">count</span>)......复制代码</code></pre><h4 id="有什么用-1"><a href="#有什么用-1" class="headerlink" title="有什么用?"></a>有什么用?</h4><p>控制观察者接收的事件的数量。</p><h4 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).<span class="hljs-keyword">take</span>(<span class="hljs-number">3</span>).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">28</span>:<span class="hljs-number">32.899</span> <span class="hljs-number">14704</span><span class="hljs-number">-14704</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><p>takeLast() 的作用就是控制观察者只能接受事件序列的后面几件事情，这里就不再讲解了，大家可以自己试试。</p><h2 id="5-7-debounce"><a href="#5-7-debounce" class="headerlink" title="5.7 debounce()"></a>5.7 debounce()</h2><h4 id="方法预览：-57"><a href="#方法预览：-57" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> final Observable&lt;T&gt; <span class="hljs-title">debounce</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> timeout, TimeUnit <span class="hljs-built_in">unit</span></span>)</span><span class="hljs-function">......</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-54"><a href="#有什么用？-54" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。</p><h4 id="怎么用？-53"><a href="#怎么用？-53" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        <span class="hljs-keyword">Thread</span>.sleep(<span class="hljs-number">900</span>);        e.onNext(<span class="hljs-number">2</span>);    &#125;&#125;).debounce(<span class="hljs-number">1</span>, TimeUnit.SECONDS).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;===================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;===================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;===================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">39</span>:<span class="hljs-number">10.512</span> <span class="hljs-number">17441</span><span class="hljs-number">-17441</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">39</span>:<span class="hljs-number">12.413</span> <span class="hljs-number">17441</span><span class="hljs-number">-17478</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">2</span>复制代码</code></pre><p>可以看到事件1并没有发送出去，现在将间隔时间改为1000，看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">10.874</span> <span class="hljs-number">18196</span><span class="hljs-number">-18196</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">11.875</span> <span class="hljs-number">18196</span><span class="hljs-number">-18245</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">1</span><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">12.875</span> <span class="hljs-number">18196</span><span class="hljs-number">-18245</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">2</span>复制代码</code></pre><p>throttleWithTimeout() 与此方法的作用一样，这里就不再赘述了。</p><h2 id="5-8-firstElement-amp-amp-lastElement"><a href="#5-8-firstElement-amp-amp-lastElement" class="headerlink" title="5.8 firstElement() &amp;&amp; lastElement()"></a>5.8 firstElement() &amp;&amp; lastElement()</h2><h5 id="方法预览：-58"><a href="#方法预览：-58" class="headerlink" title="方法预览："></a>方法预览：</h5><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Maybe&lt;T&gt; firstElement()<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Maybe&lt;T&gt; lastElement()复制代码</code></pre><h4 id="有什么用？-55"><a href="#有什么用？-55" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素。</p><h4 id="怎么用？-54"><a href="#怎么用？-54" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).firstElement().subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================firstElement &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).lastElement().subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================lastElement &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">47</span>:<span class="hljs-number">22.189</span> <span class="hljs-number">19909</span><span class="hljs-number">-19909</span>/? D/chan: ====================firstElement <span class="hljs-number">1</span>====================lastElement <span class="hljs-number">4</span>复制代码</code></pre><h2 id="5-9-elementAt-amp-elementAtOrError"><a href="#5-9-elementAt-amp-elementAtOrError" class="headerlink" title="5.9 elementAt() &amp; elementAtOrError()"></a>5.9 elementAt() &amp; elementAtOrError()</h2><h4 id="方法预览：-59"><a href="#方法预览：-59" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Maybe&lt;T&gt; elementAt(<span class="hljs-built_in">long</span> <span class="hljs-keyword">index</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;T&gt; elementAtOrError(<span class="hljs-built_in">long</span> <span class="hljs-keyword">index</span>)复制代码</code></pre><h4 id="有什么用？-56"><a href="#有什么用？-56" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 。</p><h4 id="怎么用？-55"><a href="#怎么用？-55" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).elementAt(<span class="hljs-number">0</span>).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================accept &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">56</span>:<span class="hljs-number">22.266</span> <span class="hljs-number">23346</span><span class="hljs-number">-23346</span>/com.example.rxjavademo D/chan: ====================accept <span class="hljs-number">1</span>复制代码</code></pre><p>将 elementAt() 的值改为5，这时是没有打印结果的，因为没有满足条件的元素。</p><p>替换 elementAt() 为 elementAtOrError()，代码如下：</p><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).elementAtOrError(<span class="hljs-number">5</span>).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================accept &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs stylus">io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.exceptions</span>.OnErrorNotImplementedExceptionat io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.functions</span>.Functions<span class="hljs-variable">$OnErrorMissingConsumer</span>.accept(Functions<span class="hljs-selector-class">.java</span>: <span class="hljs-number">704</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.functions</span>.Functions<span class="hljs-variable">$OnErrorMissingConsumer</span>.accept(Functions<span class="hljs-selector-class">.java</span>: <span class="hljs-number">701</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.observers</span><span class="hljs-selector-class">.ConsumerSingleObserver</span>.onError(ConsumerSingleObserver<span class="hljs-selector-class">.java</span>: <span class="hljs-number">47</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span>.ObservableElementAtSingle<span class="hljs-variable">$ElementAtObserver</span>.onComplete(ObservableElementAtSingle<span class="hljs-selector-class">.java</span>: <span class="hljs-number">117</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span>.ObservableFromArray<span class="hljs-variable">$FromArrayDisposable</span>.run(ObservableFromArray<span class="hljs-selector-class">.java</span>: <span class="hljs-number">110</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span><span class="hljs-selector-class">.ObservableFromArray</span>.subscribeActual(ObservableFromArray<span class="hljs-selector-class">.java</span>: <span class="hljs-number">36</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Observable</span>.subscribe(Observable<span class="hljs-selector-class">.java</span>: <span class="hljs-number">10903</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span><span class="hljs-selector-class">.ObservableElementAtSingle</span>.subscribeActual(ObservableElementAtSingle<span class="hljs-selector-class">.java</span>: <span class="hljs-number">37</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2707</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2693</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2664</span>)at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.rxjavademo</span><span class="hljs-selector-class">.MainActivity</span>.onCreate(MainActivity<span class="hljs-selector-class">.java</span>: <span class="hljs-number">103</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Activity</span>.performCreate(Activity<span class="hljs-selector-class">.java</span>: <span class="hljs-number">6942</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Instrumentation</span>.callActivityOnCreate(Instrumentation<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1126</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.performLaunchActivity(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2880</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.handleLaunchActivity(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2988</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>. - wrap14(ActivityThread.java)at android<span class="hljs-selector-class">.app</span>.ActivityThread<span class="hljs-variable">$H</span>.handleMessage(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1631</span>)at android<span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Handler</span>.dispatchMessage(Handler<span class="hljs-selector-class">.java</span>: <span class="hljs-number">102</span>)at android<span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Looper</span>.loop(Looper<span class="hljs-selector-class">.java</span>: <span class="hljs-number">154</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.main(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">6682</span>)at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span>.invoke(Native Method)at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.os</span>.ZygoteInit<span class="hljs-variable">$MethodAndArgsCaller</span>.run(ZygoteInit<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1520</span>)at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.ZygoteInit</span>.main(ZygoteInit<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1410</span>)Caused by: java<span class="hljs-selector-class">.util</span>.NoSuchElementExceptionat io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span>.ObservableElementAtSingle<span class="hljs-variable">$ElementAtObserver</span>.onComplete(ObservableElementAtSingle<span class="hljs-selector-class">.java</span>: <span class="hljs-number">117</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span>.ObservableFromArray<span class="hljs-variable">$FromArrayDisposable</span>.run(ObservableFromArray<span class="hljs-selector-class">.java</span>: <span class="hljs-number">110</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span><span class="hljs-selector-class">.ObservableFromArray</span>.subscribeActual(ObservableFromArray<span class="hljs-selector-class">.java</span>: <span class="hljs-number">36</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Observable</span>.subscribe(Observable<span class="hljs-selector-class">.java</span>: <span class="hljs-number">10903</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span><span class="hljs-selector-class">.ObservableElementAtSingle</span>.subscribeActual(ObservableElementAtSingle<span class="hljs-selector-class">.java</span>: <span class="hljs-number">37</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2707</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2693</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2664</span>) at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.rxjavademo</span><span class="hljs-selector-class">.MainActivity</span>.onCreate(MainActivity<span class="hljs-selector-class">.java</span>: <span class="hljs-number">103</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Activity</span>.performCreate(Activity<span class="hljs-selector-class">.java</span>: <span class="hljs-number">6942</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Instrumentation</span>.callActivityOnCreate(Instrumentation<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1126</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.performLaunchActivity(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2880</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.handleLaunchActivity(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2988</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>. - wrap14(ActivityThread.java) at android<span class="hljs-selector-class">.app</span>.ActivityThread<span class="hljs-variable">$H</span>.handleMessage(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1631</span>) at android<span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Handler</span>.dispatchMessage(Handler<span class="hljs-selector-class">.java</span>: <span class="hljs-number">102</span>) at android<span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Looper</span>.loop(Looper<span class="hljs-selector-class">.java</span>: <span class="hljs-number">154</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.main(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">6682</span>) at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span>.invoke(Native Method) at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.os</span>.ZygoteInit<span class="hljs-variable">$MethodAndArgsCaller</span>.run(ZygoteInit<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1520</span>) at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.ZygoteInit</span>.main(ZygoteInit<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1410</span>) 复制代码</code></pre><p>这时候会抛出 NoSuchElementException 异常。</p><h1 id="6-条件操作符"><a href="#6-条件操作符" class="headerlink" title="6. 条件操作符"></a>6. 条件操作符</h1><h2 id="6-1-all"><a href="#6-1-all" class="headerlink" title="6.1 all()"></a>6.1 all()</h2><h4 id="方法预览：-60"><a href="#方法预览：-60" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; ambWith(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; other)复制代码</code></pre><h4 id="有什么用？-57"><a href="#有什么用？-57" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。</p><h4 id="怎么用？-56"><a href="#怎么用？-56" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).<span class="hljs-keyword">all</span>(<span class="hljs-built_in">new</span> Predicate &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> test(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> &lt; <span class="hljs-number">5</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Boolean</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Boolean</span> aBoolean) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;==================aBoolean &quot; + aBoolean);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">39</span>:<span class="hljs-number">51.644</span> <span class="hljs-number">1482</span><span class="hljs-number">-1482</span>/com.example.rxjavademo D/chan: ==================aBoolean <span class="hljs-literal">true</span>复制代码</code></pre><h2 id="6-2-takeWhile"><a href="#6-2-takeWhile" class="headerlink" title="6.2 takeWhile()"></a>6.2 takeWhile()</h2><h4 id="方法预览：-61"><a href="#方法预览：-61" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; takeWhile(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)复制代码</code></pre><h4 id="有什么用？-58"><a href="#有什么用？-58" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送。</p><h4 id="怎么用？-57"><a href="#怎么用？-57" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).takeWhile(<span class="hljs-built_in">new</span> Predicate &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> test(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> &lt; <span class="hljs-number">3</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================integer &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14.634</span> <span class="hljs-number">3648</span><span class="hljs-number">-3648</span>/com.example.rxjavademo D/chan: ========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">1</span>========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">2</span>复制代码</code></pre><h2 id="6-3-skipWhile"><a href="#6-3-skipWhile" class="headerlink" title="6.3 skipWhile()"></a>6.3 skipWhile()</h2><h4 id="方法预览：-62"><a href="#方法预览：-62" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; skipWhile(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)复制代码</code></pre><h4 id="有什么用？-59"><a href="#有什么用？-59" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当某个数据满足条件时不发送该数据，反之则发送。</p><h4 id="怎么用？-58"><a href="#怎么用？-58" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).skipWhile(<span class="hljs-built_in">new</span> Predicate &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> test(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> &lt; <span class="hljs-number">3</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================integer &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">47</span>:<span class="hljs-number">32.653</span> <span class="hljs-number">4861</span><span class="hljs-number">-4861</span>/com.example.rxjavademo D/chan: ========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">3</span>========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">4</span>复制代码</code></pre><h2 id="6-4-takeUntil"><a href="#6-4-takeUntil" class="headerlink" title="6.4 takeUntil()"></a>6.4 takeUntil()</h2><h4 id="方法预览：-63"><a href="#方法预览：-63" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; takeUntil(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; stopPredicate复制代码</code></pre><h4 id="有什么用？-60"><a href="#有什么用？-60" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了。</p><h4 id="怎么用？-59"><a href="#怎么用？-59" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>).takeUntil(<span class="hljs-built_in">new</span> Predicate &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> test(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> &gt; <span class="hljs-number">3</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================integer &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">12.918</span> <span class="hljs-number">7933</span><span class="hljs-number">-7933</span>/com.example.rxjavademo D/chan: ========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">1</span>========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">12.919</span> <span class="hljs-number">7933</span><span class="hljs-number">-7933</span>/com.example.rxjavademo D/chan: ========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">3</span>========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">4</span>复制代码</code></pre><h2 id="6-5-skipUntil"><a href="#6-5-skipUntil" class="headerlink" title="6.5 skipUntil()"></a>6.5 skipUntil()</h2><h4 id="方法预览：-64"><a href="#方法预览：-64" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs pf">public final <span class="hljs-variable">&lt;U&gt;</span> Observable<span class="hljs-variable">&lt;T&gt;</span> <span class="hljs-keyword">skip</span>Until(ObservableSource<span class="hljs-variable">&lt;U&gt;</span> other)复制代码</code></pre><h4 id="有什么用？-61"><a href="#有什么用？-61" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当 skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者。</p><h4 id="怎么用？-60"><a href="#怎么用？-60" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>interval<span class="hljs-constructor">Range(1, 5, 0, 1, TimeUnit.SECONDS)</span>.skip<span class="hljs-constructor">Until(Observable.<span class="hljs-params">intervalRange</span>(6, 5, 3, 1, TimeUnit.SECONDS)</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Long &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onSubscribe &quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Next(Long <span class="hljs-params">along</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onNext &quot;</span> + along);    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onError &quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50.574</span> <span class="hljs-number">13023</span><span class="hljs-number">-13023</span>/com.example.rxjavademo D/chan: ========================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">08</span>:<span class="hljs-number">53.576</span> <span class="hljs-number">13023</span><span class="hljs-number">-13054</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-number">4</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">08</span>:<span class="hljs-number">54.576</span> <span class="hljs-number">13023</span><span class="hljs-number">-13054</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-number">5</span>========================onComplete 复制代码</code></pre><p>从结果可以看出，skipUntil() 里的 Observable 并不会发送事件给观察者。</p><h2 id="6-6-sequenceEqual"><a href="#6-6-sequenceEqual" class="headerlink" title="6.6 sequenceEqual()"></a>6.6 sequenceEqual()</h2><h4 id="方法预览：-65"><a href="#方法预览：-65" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Single&lt;<span class="hljs-keyword">Boolean</span>&gt; sequenceEqual(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source1, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source2)......复制代码</code></pre><h4 id="有什么用？-62"><a href="#有什么用？-62" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断两个 Observable 发送的事件是否相同。</p><h4 id="怎么用？-61"><a href="#怎么用？-61" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>sequence<span class="hljs-constructor">Equal(Observable.<span class="hljs-params">just</span>(1, 2, 3)</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).subscribe(<span class="hljs-keyword">new</span> Consumer &lt; Boolean &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void accept(Boolean aBoolean) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onNext &quot;</span> + aBoolean);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">11</span>:<span class="hljs-number">45.975</span> <span class="hljs-number">14157</span><span class="hljs-number">-14157</span>/? D/chan: ========================onNext <span class="hljs-literal">true</span>复制代码</code></pre><h2 id="6-7-contains"><a href="#6-7-contains" class="headerlink" title="6.7 contains()"></a>6.7 contains()</h2><h4 id="方法预览：-66"><a href="#方法预览：-66" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;<span class="hljs-keyword">Boolean</span>&gt; contains(<span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span> element)复制代码</code></pre><h4 id="有什么用？-63"><a href="#有什么用？-63" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。</p><h4 id="怎么用？-62"><a href="#怎么用？-62" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).contains(<span class="hljs-number">3</span>).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Boolean</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Boolean</span> aBoolean) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;========================onNext &quot;</span> + aBoolean);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">14</span>:<span class="hljs-number">23.522</span> <span class="hljs-number">15085</span><span class="hljs-number">-15085</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-literal">true</span>复制代码</code></pre><h2 id="6-8-isEmpty"><a href="#6-8-isEmpty" class="headerlink" title="6.8 isEmpty()"></a>6.8 isEmpty()</h2><h4 id="方法预览：-67"><a href="#方法预览：-67" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;<span class="hljs-keyword">Boolean</span>&gt; isEmpty()复制代码</code></pre><h4 id="有什么用？-64"><a href="#有什么用？-64" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列是否为空。</p><h4 id="怎么用？-63"><a href="#怎么用？-63" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.<span class="hljs-keyword">create</span>(<span class="hljs-built_in">new</span> ObservableOnSubscribe &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-type">Integer</span> &gt; e) throws <span class="hljs-keyword">Exception</span> &#123;        e.onComplete();    &#125;&#125;).isEmpty().subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Boolean</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Boolean</span> aBoolean) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================onNext &quot; + aBoolean);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">16.725</span> <span class="hljs-number">16109</span><span class="hljs-number">-16109</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-literal">true</span>复制代码</code></pre><h2 id="6-9-amb"><a href="#6-9-amb" class="headerlink" title="6.9 amb()"></a>6.9 amb()</h2><h4 id="方法预览：-68"><a href="#方法预览：-68" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; amb(<span class="hljs-keyword">Iterable</span><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;&gt; sources)复制代码</code></pre><h4 id="有什么用？-65"><a href="#有什么用？-65" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>amb() 要传入一个 Observable 集合，但是只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃。</p><h4 id="怎么用？-64"><a href="#怎么用？-64" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml">ArrayList &lt; Observable &lt; Long &gt;&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList &lt; &gt; <span class="hljs-literal">()</span>;<span class="hljs-built_in">list</span>.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>interval<span class="hljs-constructor">Range(1, 5, 2, 1, TimeUnit.SECONDS)</span>);<span class="hljs-built_in">list</span>.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>interval<span class="hljs-constructor">Range(6, 5, 0, 1, TimeUnit.SECONDS)</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>amb(<span class="hljs-built_in">list</span>).subscribe(<span class="hljs-keyword">new</span> Consumer &lt; Long &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void accept(Long aLong) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================aLong &quot;</span> + aLong);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">29.580</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">6</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">30.580</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">7</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">31.579</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">8</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">32.579</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">9</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">33.579</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">10</span>复制代码</code></pre><h2 id="6-10-defaultIfEmpty"><a href="#6-10-defaultIfEmpty" class="headerlink" title="6.10 defaultIfEmpty()"></a>6.10 defaultIfEmpty()</h2><h4 id="方法预览：-69"><a href="#方法预览：-69" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs pf">public final Observable<span class="hljs-variable">&lt;T&gt;</span> <span class="hljs-keyword">default</span>IfEmpty(T <span class="hljs-keyword">default</span>Item)复制代码</code></pre><h4 id="有什么用？-66"><a href="#有什么用？-66" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果观察者只发送一个 onComplete() 事件，则可以利用这个方法发送一个值。</p><h4 id="怎么用？-65"><a href="#怎么用？-65" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.<span class="hljs-keyword">create</span>(<span class="hljs-built_in">new</span> ObservableOnSubscribe &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-type">Integer</span> &gt; e) throws <span class="hljs-keyword">Exception</span> &#123;        e.onComplete();    &#125;&#125;).defaultIfEmpty(<span class="hljs-number">666</span>).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================onNext &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">56.376</span> <span class="hljs-number">19249</span><span class="hljs-number">-19249</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-number">666</span>复制代码</code></pre><p>转自 <a href="">掘金：RxJava2 只看这一篇文章就够了-玉刚说</a></p>]]></content>
    
    
    <categories>
      
      <category>RxJava</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activity的初级，中级，高级问法</title>
    <link href="/Blog/2020/11/20/Activity%E7%9A%84%E5%88%9D%E7%BA%A7%EF%BC%8C%E4%B8%AD%E7%BA%A7%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%97%AE%E6%B3%95/"/>
    <url>/Blog/2020/11/20/Activity%E7%9A%84%E5%88%9D%E7%BA%A7%EF%BC%8C%E4%B8%AD%E7%BA%A7%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%97%AE%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity的初级，中级，高级问法"><a href="#Activity的初级，中级，高级问法" class="headerlink" title="Activity的初级，中级，高级问法"></a>Activity的初级，中级，高级问法</h1><p>Activity是我们常用App开发中最重要的组件，主要用于展示界面和用户交互。本文分为三个部分：</p><p>Activity源码和常见的问题</p><ol><li>Activity的生命周期，正常情况和异常情况？</li><li>Activity的四种启动模式，启动页设置singleTask/singleInstance可能造成什么后果？</li><li>任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？</li><li>startActivityForResult导致的一系列问题？</li><li>清除返回栈（Clearing the back stack）的一些概念</li><li>allowTaskReparenting的使用</li><li>Activity的隐式启动</li><li>Activity启动流程</li></ol><p>Activity深层次问题</p><ol><li>Activity生命周期的变化对进程的优先级有什么影响？</li><li>如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？</li><li>一个Activity A启动另一个Activity B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？</li><li>为什么要这么设计Activity生命周期？</li></ol><p>第三方App中一些Activity的设置</p><ol><li>今日头条极速版-新闻界面打开的一些限制和首页</li></ol><h4 id="Activity源码和常见的问题"><a href="#Activity源码和常见的问题" class="headerlink" title="Activity源码和常见的问题"></a>Activity源码和常见的问题</h4><h5 id="1-Activity的生命周期，正常情况和异常情况？"><a href="#1-Activity的生命周期，正常情况和异常情况？" class="headerlink" title="1.Activity的生命周期，正常情况和异常情况？"></a>1.Activity的生命周期，正常情况和异常情况？</h5><p>首先来看看官网上Activity的生命周期，如下图所示</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38e47625f72949e4b2d035c27ed4c321~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>生命周期在开发中会常常被我们用到，比如在界面的恢复和销毁等回调具体的方法，我们在这些方法做一些数据的处理等。当然这里面还少了方法<code>onSaveInstance和onRestoreInstance</code>方法用于状态的保存和恢复，还有一个方法<code>onConfigurationChanged()</code>用于配置变更后的回调。</p><p>下面是一些<strong>常用的生命周期回调流程</strong>：</p><ul><li>启动Activity：<code>onCreate()-&gt;onStart()-&gt;onResume()</code></li><li>点击返回键：<code>onPause()-&gt;onStop()-&gt;onDestroy()</code></li><li>点击Home键：<code>onPause()-&gt;onSaveInstanceState()-&gt;onStop()</code>，<strong>注意在API28之后<code>onSaveInstanceState()</code>方法的执行放在了<code>onStop()</code>之后</strong>。</li><li>用户再次回到原Activity：<code>onRestart()-&gt;onStart()-&gt;onResume()</code></li><li>A Activity启动B Activity：<code>A#onPause()-&gt;B#onCreate()-&gt;B#onStart()-&gt;B#onResume()-&gt;A#onStop()</code></li></ul><p>再来看一下<strong>异常情况下的生命周期分析</strong>：</p><ol><li><p>系统配置发配置变化时生命周期的回调(API28+)</p><p><code>onPause()-&gt;onStop()-&gt;onSaveInstanceState()-&gt;onDestroy()</code>，然后当Activity被重新创建后执行<code>onCreate()-&gt;onStart()-&gt;onRestoreInstanceState()-&gt;onResume()</code></p><p>这里的配置发生变化可以指屏幕发生旋转或者切换到多窗口模式等等。</p><p><strong>系统配置发生改变时，如果不想重新创建Activity，可以通过在AndroidManifest.xml中配置<a href="https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn#config"><code>android:configChanges</code></a>属性，如果想做一些额外的操作可以在onConfigurationChanged回调中处理</strong>。</p></li><li><p>资源内存不足导致低优先级进程被回收，当系统资源不足时，会杀死低优先级进程，此时会调用<code>onSaveInstanceState()和onRestoreInstanceState()</code>进行数据的存储和恢复。</p></li></ol><h5 id="2-Activity的四种启动模式，启动页设置SingleTask-SingleInstance可能造成什么后果？"><a href="#2-Activity的四种启动模式，启动页设置SingleTask-SingleInstance可能造成什么后果？" class="headerlink" title="2.Activity的四种启动模式，启动页设置SingleTask/SingleInstance可能造成什么后果？"></a>2.Activity的四种启动模式，启动页设置SingleTask/SingleInstance可能造成什么后果？</h5><p>在清单文件中声明 Activity 时，可以使用 <a href="https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn"><code>Activity</code></a> 元素的 <a href="https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn#lmode"><code>launchMode</code></a> 属性指定 Activity 应该如何与任务关联。</p><ul><li><p>stardard：默认模式，系统在启动该 Activity 的任务中创建 Activity 的新实例，并将 intent 传送给该实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。注意在该模式下配合FLAG_ACTIVITY_NEW_TASK 与 FLAG_ACTIVITY_CLEAR_TOP，单独/一起配合，<strong>都会重新创建实例</strong>。</p></li><li><p>singleTop：<strong>栈顶复用</strong>模式，如果当前任务的顶部已存在 Activity 的实例，则系统会通过调用其 <code>onNewIntent()</code> 方法来将 intent 转送给该实例，而不是创建 Activity 的新实例。在该模式下配合FLAG_ACTIVITY_CLEAR_TOP是用哪个，不会重新创建实例，会有类似SingleTask的效果，但是如果再加上FLAG_ACTIVITY_NEW_TASK，还是会创建新实例。</p></li><li><p>singleTask：<strong>栈内复用</strong>模式，系统会创建新任务，并实例化新任务的根 Activity。但是，如果另外的任务中已存在该 Activity 的实例，则系统会通过调用其 <code>onNewIntent()</code> 方法将 intent 转送到该现有实例，而不是创建新实例。Activity 一次只能有一个实例存在。该模式默认具有clearTop的效果。</p></li><li><p>singleInstance：<strong>单实例</strong>模式，与 <code>&quot;singleTask&quot;</code> 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。</p><p><strong>关于singleInstance有个特殊的情况</strong>，如果一个A Activity（standard）启动B Activity（singleInstance），这个时候用户点击了手机最近访问列表，然后在再点击该App所在的界面（卡片），然后这个时候点击返回键竟然就直接退出了App，而不是我们预期的退到A Activity界面。其实最近访问列表也是一个Activity（假设为C Activity），当我们从这个C Activity点击App卡片显示我们的singleInstance所在的界面B，这个时候就相当于C启动了B，所以我们点击返回键，就直接回到了桌面（有兴趣可以自己看看源码）。</p><p>还有一个特殊的情况（来自扔物线大佬的文章），就是在<strong>最近任务里看见的 Task 未必还活着，最近任务里看不见的 Task，也未必就死了，比如 singleInstance</strong>。当我们查看最近任务的时候，不同的 Task 会并列展示出来，但有一个前提：它们的 taskAffinity 需要不一样。<strong>在 Android 里，同一个 taskAffinity 可以被创建出多个 Task，但它们最多只能有一个显示在最近任务列表</strong>。这也就是为什么刚才例子里 singleInstance 的那个 Activity 会从最近任务里消失了：因为它被另一个相同 taskAffinity 的 Task 抢了排面。</p><p>同理，你在一个App从首页Activity新建一个Activity(singletask/singleInstance)，如果没有指定taskAffinity，这个Activity的taskAffinity和其他界面一样，所以在最近的范围列表，你也只能看到一个App的卡片，但是如果你taskAffinity设置的不一样，就可以看到在最近列表中看到两个了。</p></li></ul><p>上面讲到的任务对应的是TaskRecord(<strong>栈结构</strong>)，其内部维护了一个<code>ArrayList&lt;ActivityRecord&gt;</code>用来保存和管理ActivityRecord，<strong>ActivityRecord包含了一个Activity的所有信息</strong>。</p><p>通常我们的App都会设置启动页(SplashActivity通常是一张图片)，然后进入我们的主界面（MainActivity），在主界面中通常有很多逻辑会导致该界面异常庞大，占据的内存很大，所以很多时候我们都会给该界面设置为SingleTask栈内复用模式。</p><p>场景一：如果为了达到快速启动的效果，将我们的App的闪屏页(SplashActivity显示固定图片)移除掉，换成MainActivity（SingleTask/SingleInstance）的背景（windowBackground），最后再替换成App的主题，给用户快速响应的体验；</p><p>场景二：如果给启动页SplashActivity设置为SingleTask/SingleInstance模式，同时你的启动页没有及时的关闭。</p><p>以上两种场景会导致你的App无论冷启动还是热启动，每次点击图标都是从启动页开始启动的，具体的原理可以看我这篇文章的分析和解决方案。<a href="https://juejin.im/post/6888990959233662990">切记，不要在你的App启动界面设置SingleTask/SingleInstance</a>。</p><h5 id="3-任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？"><a href="#3-任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？" class="headerlink" title="3.任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？"></a>3.任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？</h5><p>首先来看官网的说明<a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn">Understand Tasks and Back Stack</a>，(A task is a collection of activities that users interact with when performing a certain job. The activities are arranged in a stack—the <em>back stack</em>)—in the order in which each activity is opened. )任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。前面说过任务对应的是TaskRecord(<strong>栈结构</strong>)，其内部维护了一个<code>ArrayList&lt;ActivityRecord&gt;</code>用来保存和管理ActivityRecord，ActivityRecord包含了一个Activity的所有信息。所以其实<strong>任务就是任务栈（TaskRecord是栈结构</strong>)。</p><p>那么返回栈是什么，首先展示一张Gityuan博客的<a href="http://gityuan.com/2017/06/11/activity_record/">图片</a>。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b681e32886a74f1c8012a762be7ccec6~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><ul><li>一般地，对于没有分屏功能以及虚拟屏的情况下，ActivityStackSupervisor与ActivityDisplay都是系统唯一；</li><li>ActivityDisplay主要有Home Stack和App Stack这两个栈；</li><li>每个ActivityStack中可以有若干个TaskRecord对象，<strong>当前只会有一个获得了焦点的ActivityStack</strong>；</li><li>每个TaskRecord包含如果若干个ActivityRecord对象；</li><li>每个ActivityRecord记录一个Activity信息。</li></ul><p><strong>一个返回栈可能只包含一个任务，但在特殊情况下，可能引入多个任务</strong>。这个概念非常重要，这里引用官方的图</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8031cba5772b40d089f2a6097ed69e82~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>这里先说一下操作流程，依次启动ActivityX，ActivityY，Activity1，Activity2；ActivityY，ActivityX（这两个都是SingleTask）在后台任务中，Activity2，Activity1在前台任务中，这两个任务的taskAffinity不同，当从Activity2中启动ActivityY的时候，返回栈如第二列所示，然后点击返回键可以一个个退出。</p><p>再普及一个概念在 Android 里，每个 Activity 都有一个 taskAffinity，它就相当于是对每个 Activity 预先进行的分组。它的值默认取自它所在的 Application 的 taskAffinity，而 Application 的 taskAffinity 默认是 App 的包名。当然也可以手动指定taskAffinity。</p><p><strong>但是图中并没有指明Activity2，Activity1是什么启动模式，实际上我如果我们指定为standard标准模式根本模拟不出这个场景，这一点有点坑</strong>，因为这四个Activity分别按2，1，X，Y排列，也即是说启动是从Y，X，1，2一个个启动的，如果Activity1为standard，就算你指定了Activity1的taskAffinity和ActivityY的不同也没有用，Activity1还是会和ActivityY在同一个任务(TaskRecord)中，也就是说**standard 和 singleTop 的 Activity 在哪个 TaskRecord 启动，全凭启动它的 Activity 在哪个 TaskRecord，taskAffinity在同时指定为singleTask模式下才有意义(只有一种例外，standard 和 singleTop在 allowTaskReparenting 为 true，且被其他应用以 DeepLink 的方式唤起时，才会在指定的任务中)**。</p><p>所以我们将Activity2，Activity1也设置为singleTask，同时taskAffinity也相同，才会模拟出上面的场景，点击Activity2启动ActivityY，才会将后台任务栈ActivityY，ActivityX都带到前台任务栈中，也就是都带到返回栈中。</p><p><strong>小结</strong></p><p>任务就是任务栈（<strong>TaskRecord是栈结构</strong>)，TaskRecord内部维护了一个<code>ArrayList&lt;ActivityRecord&gt;</code>用来保存和管理ActivityRecord，ActivityRecord包含了一个Activity的所有信息。</p><p>一个返回栈可能只包含一个任务，但特殊情况下，可能引入多个任务。<strong>返回栈，前台任务栈，后台任务栈其实在源码中并没有明确的定义，而是在我们操作任务栈过程中提出的一些“概念”，为了便于描述和区分</strong>。</p><p>前台栈比如现在<strong>下图A</strong>中的Activity2，Activity1所在的任务，后台任务栈是ActivityY，ActivityX所在的任务。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1be237dc6554e2fb67c20d2f5e0118c~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>但是问题来了，当Activity2启动ActivityY的时候，返回栈中的内容如<strong>下图B</strong>所示，这个时候前台任务栈是什么呢？</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f7ce0688724b05be5ac26d087b307d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>这个时候后台的任务栈（ActivityY，ActivityX）已经返回到前台，四个Activity都在前台，<strong>此时返回堆栈中包含了转到前台任务中的所有Activity（这句话来自<a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn">官网</a>对这一场景的说明）</strong>。</p><p>问题又来了，比如我们前面说的后台任务栈是在后台等待恢复(比如ActivityX，ActivityY所在的栈)，依次启动ActivityX，ActivityY，Activity1，Activity2，如果你这个时候什么都不做，不断点击返回键，这四个Activity会一个个退出，这个时候你会不会觉得返回栈包含前台任务栈和后台任务栈。但是一开始图A中返回栈（Back Stack）只标明了Activity1，Activity2，这就出现矛盾了，<strong>但我的感觉返回栈就是字面上的含义，点击返回键，能退出多少个Activity，那么这些Activity就都在返回栈中，返回栈就是一个概念，当然你也可以理解它的大小动态变化的（点击返回键的过程中可能大小可能新增）</strong>。</p><h5 id="4-startActivityForResult导致的一系列问题？"><a href="#4-startActivityForResult导致的一系列问题？" class="headerlink" title="4.startActivityForResult导致的一系列问题？"></a>4.startActivityForResult导致的一系列问题？</h5><p>在使用Activity的startActivityForResult启动新界面时，在Api20以下调整时会直接返回<code>Activity.RESULT_CANCELED</code>，官方觉得不应该在两个任务之间setResult。在Api20及以上，对于非startActivity跳转，也就是reqeusetCode&gt;=0，singleTask和SingleInstance模式启动的Activity都不会新建一个任务，还是在原来的栈中。同时官方也建议：</p><p>虽然所有 API 级别的 <code>Activity</code> 类均提供底层 <a href="%5Bdeveloper.android.com/reference/a%E2%80%A6%5D(https://developer.android.com/reference/android/app/Activity#startActivityForResult(android.content.Intent"><code>startActivityForResult()</code></a>, int)) 和 <a href="%5Bdeveloper.android.com/reference/a%E2%80%A6%5D(https://developer.android.com/reference/android/app/Activity#onActivityResult(int"><code>onActivityResult()</code></a>, int, android.content.Intent)) API，但我们强烈建议您使用 AndroidX <a href="https://developer.android.com/jetpack/androidx/releases/activity#1.2.0-alpha02">Activity <code>1.2.0-alpha02</code></a> 和 <a href="https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha02">Fragment <code>1.3.0-alpha02</code></a> 中引入的 Activity Result API。</p><h5 id="5-清除返回栈（Clearing-the-back-stack）的一些概念"><a href="#5-清除返回栈（Clearing-the-back-stack）的一些概念" class="headerlink" title="5.清除返回栈（Clearing the back stack）的一些概念"></a>5.清除返回栈（Clearing the back stack）的一些概念</h5><p>如果用户离开任务较长时间，系统会清除任务中除根 Activity 以外的所有 Activity。当用户再次返回到该任务时，只有根 Activity 会恢复。系统之所以采取这种行为方式是因为，经过一段时间后，用户可能已经放弃了之前执行的操作，现在返回任务是为了开始某项新的操作。</p><p>您可以使用一些 Activity 属性来修改此行为：</p><ul><li><p><code>alwaysRetainTaskState</code></p><p>如果在任务的根 Activity 中将该属性设为 <code>&quot;true&quot;</code>，则不会发生上述默认行为。即使经过很长一段时间后，任务仍会在其堆栈中保留所有 Activity。</p></li><li><p><code>clearTaskOnLaunch</code></p><p>如果在任务的根 Activity 中将该属性设为 <code>&quot;true&quot;</code>，那么只要用户离开任务再返回，堆栈就会被清除到只剩根 Activity。也就是说，它与 <a href="https://developer.android.com/guide/topics/manifest/activity-element#always"><code>alwaysRetainTaskState</code></a> 正好相反。用户始终会返回到任务的初始状态，即便只是短暂离开任务也是如此。</p></li><li><p><code>finishOnTaskLaunch</code></p><p>该属性与 <a href="https://developer.android.com/guide/topics/manifest/activity-element#clear"><code>clearTaskOnLaunch</code></a> 类似，但它只会作用于单个 Activity 而非整个任务。它还可导致任何 Activity 消失，包括根 Activity。如果将该属性设为 <code>&quot;true&quot;</code>，则 Activity 仅在当前会话中归属于任务。如果用户离开任务再返回，则该任务将不再存在。</p></li></ul><h5 id="6-allowTaskReparenting的使用"><a href="#6-allowTaskReparenting的使用" class="headerlink" title="6.allowTaskReparenting的使用"></a>6.allowTaskReparenting的使用</h5><p>Activity 默认情况下只会归属于一个 Task，不会在多个 Task 之间跳来跳去，但你可以通过设置来改变这个逻辑。把它的 allowTaskReparenting 属性设置为 true。如果未设置该属性，则由 <code>&lt;Activity&gt;</code> 元素的相应 <code>allowTaskReparenting</code> 属性所设置的值。默认值为“<code>false</code>”。</p><p>正常情况下，Activity 启动时会与启动它的任务关联，并在其整个生命周期中一直留在该任务处。当不再显示现有任务时，您可以使用该属性强制 Activity 将其父项更改为与其有相似性的任务。该属性通常用于将应用的 Activity 转移至与该应用关联的主任务。</p><p>例如，如果电子邮件消息包含网页链接，则点击该链接会调出可显示该网页的 Activity。该 Activity 由浏览器应用定义，但作为电子邮件任务的一部分启动。<strong>如果将该 Activity 的父项更改为浏览器任务，则它会在浏览器下一次转至前台时显示，在电子邮件任务再次转至前台时消失</strong>。</p><h5 id="7-Activity的隐式启动"><a href="#7-Activity的隐式启动" class="headerlink" title="7.Activity的隐式启动"></a>7.Activity的隐式启动</h5><p>Activity分为显示启动和隐式启动，显示启动就是我们平时调用的一些<code>startActivityXXX()</code>方法，隐式启动可以通过action来启动，启动时调用如下，同时要记得添加category为<code>&quot;android.intent.category.DEFAULT&quot;</code>。</p><pre><code class="hljs java">Intent implicitIntent = <span class="hljs-keyword">new</span> Intent();implicitIntent.setAction(<span class="hljs-string">&quot;com.test.image&quot;</span>);implicitIntent.addCategory(<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span>);MainActivity.<span class="hljs-keyword">this</span>.startActivity(implicitIntent);复制代码</code></pre><p>具体界面的配置如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ImageActivity&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.test.image&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>复制代码</code></pre><p>注意如果是其他App的Activity，需要添加android:exported=”true”才能被调用。</p><h5 id="8-Activity的启动流程（中级问题）"><a href="#8-Activity的启动流程（中级问题）" class="headerlink" title="8.Activity的启动流程（中级问题）"></a>8.Activity的启动流程（中级问题）</h5><p>对很多开发者来说，这可能都是个很沉重的问题，原因很简单，因为回答不好，毕竟里面涉及到的东西很多，需要你拥有很大知识存储量。下面来尝试回答这个问题（基于源码9.0）</p><p>首先先普及一些常见的概念</p><h6 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h6><p>Android Instrumentation是Android系统中的一套控制方法或者“钩子”，这些钩子可以在正常的生命周期（正常是由操作系统控制的）之外控制Android控件的运行，其实指的就是<strong>Instrumentation类提供的各种流程控制方法</strong>。</p><p><code>app-&gt;instrumentation-&gt;ams-&gt;app</code>，自动化测试可以通过Instrumentation来操作Activity等，这个<strong>Instrumentation相当于设计了一个统一的入口</strong>。</p><h6 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h6><p>ActivityThread不是线程类（Thread），只不过它会跑在<code>ActivityThread.main()</code>方法中，安卓程序的入口就是该方法，同时在该方法中一个Looper不断循环的在消息队列中处理消息。管理应用程序进程中主线程的执行，根据Activity管理者的请求调度和执行activities、broadcasts及其相关的操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 看源码很重要的一个能力就是‘眼中只有你’，认不到的都忽略，看认得到的</span>    ···    <span class="hljs-comment">// 创建主线程的Looper对象，发现和工作线程创建Looper对象调用的方法不一样，这里先记下，以后在详解。</span>    <span class="hljs-comment">// 主线程原来也有Looper对象啊</span>    Looper.prepareMainLooper();    <span class="hljs-comment">//创建ActivityThread</span>    ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();    thread.attach(<span class="hljs-keyword">false</span>);    <span class="hljs-comment">// 如果主线程的Handler为空（可以看出，一个好的命名可读性是多么高），那就为主线程创建一个Handler。</span>    <span class="hljs-comment">// 然后我们还可以在主线程创建Handler，说明一个线程对应多个Handler。多读源码，很多问题都得到了解决啊。</span>    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;        sMainThreadHandler = thread.getHandler();    &#125;    Looper.loop()；        <span class="hljs-comment">// 这里抛了个异常，主线程loop异常退出。说明主线程loop不能退出，这里和前面建立Looper对象的调用方法有关</span>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);&#125;复制代码</code></pre><h6 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h6><p>Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作。</p><h6 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h6><p>该类提供与Activity、Service和Process相关的信息以及交互方法， 可以被看作是ActivityManagerService的辅助类。</p><h6 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h6><p>负责所有Activity栈的管理。内部管理了mHomeStack、mFocusedStack和mLastFocusedStack三个Activity栈。其中，mHomeStack管理的是Launcher相关的Activity栈；mFocusedStack管理的是当前显示在前台Activity的Activity栈；mLastFocusedStack管理的是上一次显示在前台Activity的Activity栈。下面是大致的关系图，对于没有分屏功能以及虚拟屏的情况下，ActivityStackSupervisor与ActivityDisplay都是系统唯一。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><h6 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h6><p>ActivityStack负责“Activity栈”的状态和管理，ActivityStack内部包含了多个任务栈（TaskRecord），TaskRecord内部维护了一个<code>ArrayList&lt;ActivityRecord&gt;</code>用来保存和管理ActivityRecord，ActivityRecord包含了一个Activity的所有信息</p><p>如果我们从桌面点击启动app，桌面就是一个Activity，点击app（按钮）启动我们的启动页Activity，从这里分析Activity的启动流程更加全面，而不是在app中去启动一个普通的Activity。可以分为如下几个流程</p><ol><li><p>Launcher通知AMS启动App的启动页Activity，AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。</p><p>Launcher进入pause状态后，通知AMS已经paused了，可以启动App了</p></li><li><p>如果App未开启过，AMS发送创建进程请求，Zogyte进程接受AMS请求并孵化应用进程，应用进程调用ActivityThread并调用mian()方法，并且main()方法中创建ActivityThread对象，<code>activityThread.attach()</code>方法中进行绑定（应用进程绑定到AMS），传入applicationThread以便通讯。</p></li><li><p>AMS通知App绑定Application（bindApplication）并启动Activity，并且创建和关联Context,最后调用onCreate等方法。</p></li></ol><h6 id="灵魂拷问：AMS，Zogyte，App进程，Launcher如何通信？"><a href="#灵魂拷问：AMS，Zogyte，App进程，Launcher如何通信？" class="headerlink" title="灵魂拷问：AMS，Zogyte，App进程，Launcher如何通信？"></a>灵魂拷问：AMS，Zogyte，App进程，Launcher如何通信？</h6><p>这个问题一旦问出来，能干翻一大堆开发人员，下面来仔细讲讲：</p><p>App进程和AMS是如何通信的？</p><p>Zogyte去fork一个App进程，后面就是应用进程和AMS两者的事情了，我们知道Android的跨进程通信是通过Binder服务的，AMS所在的进程和应用进程在通过Binder互相通信时，实际上都是通过两者的代理类进行通信的。</p><p>ActivityManagerService(AMS)在手机开机后时就已经启动了，应用进程去调用AMS的方法，比如startActivity，很容易调用，因为AMS是一个有名称的Binder服务，在任意地方都可以通过在ServiceManger（SM）里面查询拿到代理类，调用代理类的对应方法，然后再去调用AMS的真正方法。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>因为Binder通信是通过代理类来通信的，如果拿不到代理类，其他进程就不知道如何和我们的App通信，系统服务中的AMS也就不知道如何和我们App通信了，所以当App进程创建完成后，会进行设置代理，代理的设置过程如图</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>就是在<code>ActivityThread.attach(false)</code>方法中，AMS绑定ApplicationThread对象，即应用进程绑定到AMS，<strong>通过调用AMS的attachApplication来将ActivityThread的内部类ApplicationThread对象绑定至AMS，这样AMS就可以通过这个代理对象来控制应用进程</strong>。</p><p>AMS和Launcher是怎么通信的？</p><p>其实Launcher也是一个App，调用startActivity方法，然后调用的是Instrumentation的execStartActivity方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span><span class="hljs-function"><span class="hljs-params">        Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123;    ...    <span class="hljs-keyword">try</span> &#123;   ...    <span class="hljs-comment">//获取AMS的代理对象</span>        <span class="hljs-keyword">int</span> result = ActivityManager.getService()            .startActivity(whoThread, who.getBasePackageName(), intent,                    intent.resolveTypeIfNeeded(who.getContentResolver()),                    token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,                    requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);        checkStartActivityResult(result, intent);    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Failure from system&quot;</span>, e);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;复制代码</code></pre><p>在这个方法会调用ActivityManager的getService方法来得到AMS的代理对象，然后调用这个代理对象的startActivity方法</p><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> IActivityManagerSingleton.get();&#125;<span class="hljs-meta">@UnsupportedAppUsage</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =        <span class="hljs-keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//得到activity的service引用，即IBinder类型的AMS引用</span>                <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);        <span class="hljs-comment">//转换成IActivityManager对象</span>                <span class="hljs-keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);                <span class="hljs-keyword">return</span> am;            &#125;        &#125;;复制代码</code></pre><p>可以发现在Singleton中的create方法中由于b是AMS引用作为服务端处于SystemServer进程中，与当前Launcher进程作为客户端与服务端不在同一个进程，所以am返回的是IActivityManager.Stub的代理对象，此时如果要实现客户端与服务端进程间的通信，只需要在AMS继承了IActivityManager.Stub类并实现了相应的方法，而通过下面的代码可以发现AMS刚好是继承了IActivityManager.Stub类的，这样Launcher进程作为客户端就拥有了服务端AMS的代理对象，然后就可以调用AMS的方法来实现具体功能了，就这样Launcher的工作就交给AMS实现了。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IActivityManager</span>.<span class="hljs-title">Stub</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Watchdog</span>.<span class="hljs-title">Monitor</span>, <span class="hljs-title">BatteryStatsImpl</span>.<span class="hljs-title">BatteryCallback</span> </span>&#123;&#125;复制代码</code></pre><p>Zygote和AMS是如何通信的？</p><p>AMS和Zygote建立Socket连接，然后发送创建应用进程的请求。具体可以参考<a href="http://liuwangshu.cn/framework/booting/2-zygote.html">这里</a>。</p><p>最后我们再来看看流程图，看下方的App进程启动过程和<code>Activity.startActivity</code>这两个流程</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>这里还要提到一点，<strong>Hook Activity的启动流程是一个很重要的运用场景</strong>，我们需要欺骗AMS，然后启动真正的TargetActivity，Hook有起始点和终点。这里需要寻找两个地方的hook点，一个是对Intent中Activity的替换（hookIActivityTaskManager方法），一个是对Intent中Activity的还原（hookHandler）。</p><p>在回答Activity的启动流程时，具体的方法如何调用并不重要，所以我才会在最后放出整个流程，各个进程之间如何建立通信，如何通信很重要，同时一些Activity相关概念也很重要，熟悉这些，你就很容易把整个流程串起来了。</p><h4 id="Activity深层次问题"><a href="#Activity深层次问题" class="headerlink" title="Activity深层次问题"></a>Activity深层次问题</h4><h5 id="1-Activity生命周期的变化对进程的优先级有什么影响？"><a href="#1-Activity生命周期的变化对进程的优先级有什么影响？" class="headerlink" title="1.Activity生命周期的变化对进程的优先级有什么影响？"></a>1.Activity生命周期的变化对进程的优先级有什么影响？</h5><p>这里先看一下官网上<a href="https://developer.android.com/guide/components/activities/process-lifecycle">Activity生命周期</a>上对onStart的一段描述，onStart时候Activity就对用户可见了</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>同时你也可以在《Android开发艺术探索》上看到类似的描述</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>但是了解Activity启动流程源码的朋友都知道，ActivityThread的handleResumeActivity方法中，<strong>首先调用Activity的onResume方法，接着会调用Activity.makeVisible()在该方法中，DecorView真正完成了添加和显示这两个过程，到这里Activity的视图才能被看到</strong>。DecoreView和Window进行关联。有兴趣可以看看我这篇文章的<a href="https://juejin.im/post/6886629660814868488#heading-7">分析</a>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeVisible</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mWindowAdded) &#123;            ViewManager wm = getWindowManager();          <span class="hljs-comment">//DecoreView和WindowManager进行关联。</span>            wm.addView(mDecor, getWindow().getAttributes());            mWindowAdded = <span class="hljs-keyword">true</span>;        &#125;  <span class="hljs-comment">//设置DecorView可见</span>        mDecor.setVisibility(View.VISIBLE);    &#125;复制代码</code></pre><p>也就是说在onResume方法执行之后再调用Activity.makeVisible()方法，我们才能真正用<strong>肉眼</strong>看到我们的DecoreView，看到这里你这里不禁会产生一个疑问，那上面官网上的说法（**<code>onStart()</code> 调用使 Activity 对用户可见**）难道是错误的吗？</p><p>带着疑问我们继续在官网上找答案，在<a href="https://developer.android.com/guide/components/activities/process-lifecycle">进程和生命周期</a>这一章节上可以看到：</p><p>为了确定在内存不足时应该终止哪些进程，Android 会根据每个进程中运行的组件以及这些组件的状态，将它们放入“重要性层次结构”。这些进程类型包括（<strong>按重要性排序</strong>）：</p><ol><li><strong>前台进程</strong>是用户目前执行操作所需的进程。在不同的情况下，进程可能会因为其所包含的各种应用组件而被视为前台进程。如果以下任一条件成立，则进程会被认为位于前台：</li></ol><ul><li>它正在用户的互动屏幕上运行一个 <code>Activity</code>（其 <code>onResume()</code> 方法已被调用）。</li><li>它有一个 <code>BroadcastReceiver</code> 目前正在运行（其 <code>BroadcastReceiver.onReceive()</code> 方法正在执行）。</li><li>它有一个 <code>Service</code> 目前正在执行其某个回调（<code>Service.onCreate()</code>、<code>Service.onStart()</code> 或 <code>Service.onDestroy()</code>）中的代码。</li></ul><ol><li><p>系统中只有少数此类进程，而且除非内存过低，导致连这些进程都无法继续运行，才会在最后一步终止这些进程。通常，此时设备已达到内存分页状态，因此必须执行此操作才能使用户界面保持响应。</p></li><li><p><strong>可见进程</strong>正在进行用户当前知晓的任务，因此终止该进程会对用户体验造成明显的负面影响。在以下条件下，进程将被视为可见：</p><ul><li>它正在运行的 <code>Activity</code> 在屏幕上对用户可见，但不在前台（其 <code>onPause()</code> 方法已被调用）。举例来说，如果前台 Activity 显示为一个对话框，而这个对话框允许在其后面看到上一个 Activity，则可能会出现这种情况。</li><li>它有一个 <code>Service</code> 正在通过 <code>Service.startForeground()</code>（要求系统将该服务视为用户知晓或基本上对用户可见的服务）作为前台服务运行。</li><li>系统正在使用其托管的服务实现用户知晓的特定功能，例如动态壁纸、输入法服务等。</li></ul><p>相比前台进程，系统中运行的这些进程数量较不受限制，但仍相对受控。这些进程被认为非常重要，除非系统为了使所有前台进程保持运行而需要终止它们，否则不会这么做。</p></li><li><p><strong>服务进程</strong>包含一个已使用 <code>startService()</code> 方法启动的 <code>Service</code> 。虽然用户无法直接看到这些进程，但它们通常正在执行用户关心的任务（例如后台网络数据上传或下载），因此系统会始终使此类进程保持运行，除非没有足够的内存来保留所有前台和可见进程。</p><p>已经运行了很长时间（例如 30 分钟或更长时间）的服务的重要性可能会降位，以使其进程降至下文所述的缓存 LRU 列表。这有助于避免超长时间运行的服务因内存泄露或其他问题占用大量内存，进而妨碍系统有效利用缓存进程。</p></li><li><p><strong>缓存进程</strong>是目前不需要的进程，因此，如果其他地方需要内存，系统可以根据需要自由地终止该进程。在正常运行的系统中，这些是内存管理中涉及的唯一进程：运行良好的系统将始终有多个缓存进程可用（为了更高效地切换应用），并根据需要定期终止最早的进程。只有在非常危急（且具有不良影响）的情况下，系统中的所有缓存进程才会被终止，此时系统必须开始终止服务进程。</p><p>这些进程通常包含用户当前不可见的一个或多个 <code>Activity</code> 实例（<code>onStop()</code> 方法已被调用并返回）。只要它们正确实现其 Activity 生命周期（详情请见 <code>Activity</code>），那么当系统终止此类流程时，就不会影响用户返回该应用时的体验，因为当关联的 Activity 在新的进程中重新创建时，它可以恢复之前保存的状态。</p><p>这些进程保存在伪 LRU 列表中，列表中的最后一个进程是为了回收内存而终止的第一个进程。此列表的确切排序政策是平台的实现细节，但它通常会先尝试保留更多有用的进程（比如托管用户的主屏幕应用、用户最后看到的 Activity 的进程等），再保留其他类型的进程。还可以针对终止进程应用其他政策：比如对允许的进程数量的硬限制，对进程可持续保持缓存状态的时间长短的限制等。</p></li></ol><p>可以看到在屏幕上运行时一个Activity的onResume的方法已被调用，此时处于前台进程；可见进程的一个符合条件：<strong>它正在运行的 <code>Activity</code> 在屏幕上对用户可见，但不在前台</strong>，然后再对比上面对onStart的描述（<code>onStart()</code> 调用使 Activity 对用户可见，因为应用会<strong>为 Activity 进入前台并支持互动做准备</strong>），这下子你就豁然开朗了，这里的<strong>onStart的可见指的是可见进程的可见，而不是真正意义上的肉眼可见</strong>。</p><p>“onPause此方法表示 Activity 不再位于前台（尽管在用户处于多窗口模式时 Activity 仍然可见）”，“如果您的 Activity 不再对用户可见，说明其已进入“已停止”状态，因此系统将调用 <code>onStop()</code> 回调”，以上都是官方的描述，我们可以打印一下手机中的这些进程，使用<code>adb shell dumpsys meminfo</code>命令，设备是android 10华为手机。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cebd5b982f694241866dc10e27b59b9d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>可以看到分别对应我们的前台进程，可见进程，服务进程和缓存进程，其中服务进程还分为A Services和B Services。其实远远不止这么多的进程级别区分，我自己的App打开后，然后点击home键退到后台，此时属于<strong>Previous进程</strong>（后台进程）级别（com.jackie.testdialog），如果我打开App后，点击返回键退出，这个时候我的App进程就变成了<strong>Cached进程</strong>级别了。</p><p>讲了这么多，你可能觉得一直没有一个量化的数字，进程的级别（oom_adj）的取值范围是多少，在Android7.0之后，ADJ采用100，200，300等数字。下面是基于android9的区分：</p><table><thead><tr><th>ADJ级别</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>NATIVE_ADJ</td><td>-1000</td><td>native进程</td></tr><tr><td>SYSTEM_ADJ</td><td>-900</td><td>仅指system_server进程</td></tr><tr><td>PERSISTENT_PROC_ADJ</td><td>-800</td><td>系统persistent进程</td></tr><tr><td>PERSISTENT_SERVICE_ADJ</td><td>-700</td><td>关联着系统或persistent进程</td></tr><tr><td><code>FOREGROUND_APP_ADJ</code></td><td>0</td><td>前台进程</td></tr><tr><td><code>VISIBLE_APP_ADJ</code></td><td>100</td><td>可见进程</td></tr><tr><td><code>PERCEPTIBLE_APP_ADJ</code></td><td>200</td><td>可感知进程，比如后台音乐播放</td></tr><tr><td>BACKUP_APP_ADJ</td><td>300</td><td>备份进程</td></tr><tr><td>HEAVY_WEIGHT_APP_ADJ</td><td>400</td><td>重量级进程</td></tr><tr><td><code>SERVICE_ADJ</code></td><td>500</td><td>服务进程</td></tr><tr><td>HOME_APP_ADJ</td><td>600</td><td>Home进程</td></tr><tr><td>PREVIOUS_APP_ADJ</td><td>700</td><td>上一个进程</td></tr><tr><td><code>SERVICE_B_ADJ</code></td><td>800</td><td>B List中的Service</td></tr><tr><td><code>CACHED_APP_MIN_ADJ</code></td><td>900</td><td>不可见进程的adj最小值</td></tr><tr><td>CACHED_APP_MAX_ADJ</td><td>906</td><td>不可见进程的adj最大值</td></tr></tbody></table><p>开发者应该减少在保活上花心思，更应该在优化内存上下功夫，因为在相同ADJ级别的情况下，系统会选择优先杀内存占用的进程。当然你也可以手动去测试App的进程级别，不过过程可能有点麻烦，可以参考这篇<a href="https://juejin.im/post/6891911483379482637#heading-23">文章</a>。</p><p><strong>小结</strong></p><p>当界面只有一个Activity时，它进入onStart和onPause时是可见进程，进入onResume时是前台进程，打开后点击Home键退到后台这个时候是Previous进程（后台进程），如果直接点击返回键退出Activity，这个时候是缓存进程；如果有多个Activity（注意这个时候只有app从后台任务进入前台，或者点击Home键退到后台这两种场景；因为app在前台运行时都是前台进程），栈顶的的Activity进入onStart和onPause时是可见进程，进入onResume后是前台进程，点击Home键退到后台时是Previous进程（大家常说的后台进程）。</p><h5 id="2-如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？"><a href="#2-如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？" class="headerlink" title="2.如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？"></a>2.如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？</h5><p>如果你点击主界面MainActivity，点击返回键后系统执行MainActivity的onDestory方法，这个时候<strong>App进程为缓存进程，下次启动App你会发现Application的onCreate方法并不会执行</strong>，当然MainActivity的生命周期都会正常执行，这是因为从缓存进程启动App，系统已经缓存了很多信息，很多数据并不会被销毁，onCreate中初始化的那些内容还在，方便用户下次快速启动。利用这一特性，我们的App首次启动速度一般为500<del>600ms，退出App后存在缓存进程的情况下，每次启动的速度一般为200</del>300ms，算是某种程度上提升了App的启动时间。</p><p>需要注意的是，很多App在退出主界面的时候，会手动调用如下代码去退出App</p><pre><code class="hljs java">System.exit(<span class="hljs-number">0</span>);复制代码</code></pre><p>一旦调用了如下代码，就会彻底的退出并不会利用缓存进程的优势，也失去了系统提供给我们的优化了。</p><h5 id="3-一个Activity-A启动另一个Activity-B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？"><a href="#3-一个Activity-A启动另一个Activity-B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？" class="headerlink" title="3.一个Activity A启动另一个Activity B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？"></a>3.一个Activity A启动另一个Activity B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？</h5><p>如果你看过前面两个问题，这个问题你可能已经有答案了。手机之所以进行进程的管理，用不同的优先级对进程进行区分，首先肯定是为了保证用户的流畅体验，对于优先级低且占用内存高的进程及时清理，保证前台进程有足够的运行空间。前面我们讲到处于前台的（获取焦点）界面只有一个，onPause时当前进程离开了前台，当然可能也要进行一些数据的保存，所以肯定需要先执行当前界面的某个方法，然后再执行B界面的onCreate，onStart，onResume是为了新的界面能够被快速呈现（获取焦点），然后再走旧界面A的onStop方法。</p><p>这里也需要注意，onPause方法中尽量不要去做耗时的操作，如果过于耗时，新界面会很久才能显示出来，尽量放在onStop方法中去做。当然onStop中也不能做过于耗时的操作中，前面我们也试过，点击Home键会执行onStop方法，此时App进程处于后台进程，此时进程的优先级的很低的，当内存不足时，onStop中保存数据的操作可能就未完成，然后App进程就被系统回收了。</p><p>关于状态保存和恢复，在API28之前，onSaveInstanceState执行在onStop之前，但不限于在onPause之前或之后；在API28之后，onSaveInstanceState 执行时机已确定为在 <code>onStop</code> 之后。而onRestoreInstanceState确定执行在onStart之后。</p><h5 id="4-为什么要这么设计Activity生命周期"><a href="#4-为什么要这么设计Activity生命周期" class="headerlink" title="4.为什么要这么设计Activity生命周期"></a>4.为什么要这么设计Activity生命周期</h5><p>假如你自己设计界面的生命周期：</p><ul><li>界面启动时候用需要设计一个方法</li><li>界面完全渲染完毕显示需要一个方法</li><li>界面被部分遮盖时/跳到其他界面/退到后台需要一个方法</li><li>界面完全退出销毁时需要一个方法</li></ul><p>这么看来，我们好像只需要onCreate，onResume，onPause，onDestroy这四个方法，但是这只是一个很粗糙的界面创建~退出流程的回调，但是你看看IOS的UIViewController的生命周期，看起来就是个精致的猪猪女孩</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>这样一对比，连Android的生命周期显得有点粗糙了，其实不全是，Activity还有一系列的<code>onPostXXX</code>方法以及onContentChanged等，但还是没有IOS细腻。其实我觉得，这些生命周期的回调是基于一些场景设计的，从视图的显示到销毁，考虑到不同的需求，我们需要不同程度级别的设计，<strong>如果Android是一个非常简单的系统，也不会实现那么多的特殊需求，可能只需要前面我说的那四个方法就够了，我感觉在生命周期的设计方面，IOS做的更好一些，对开发者更加友好</strong>。</p><p>也有一些人在回答生命周期为什么要这么设计时，可能会这么回答，因为界面需要有个创建/销毁过程，onCreate/onDestroy肯定需要，onStart时进程为可见进程，提升进程的优先级，或者做一些特殊场景的操作，onResume在界面启动完成或者恢复时需要，界面在被透明Activity的覆盖时会执行onPause()，需要有个方法在这个时候做状态保存或特殊操作等，onStop时可以进行状态保存。<strong>这样想问题完全是一种结果倒推的想法，经不起仔细的推敲，一定不要从具体的方法去推场景，而是应该从需求场景开始推导，切记，这一切都是需求或可能的需求引起的</strong>！</p><h4 id="第三方App中一些Activity的设置"><a href="#第三方App中一些Activity的设置" class="headerlink" title="第三方App中一些Activity的设置"></a>第三方App中一些Activity的设置</h4><h5 id="今日头条极速版-新闻界面打开的一些限制"><a href="#今日头条极速版-新闻界面打开的一些限制" class="headerlink" title="今日头条极速版-新闻界面打开的一些限制"></a>今日头条极速版-新闻界面打开的一些限制</h5><p>NewDetailActivity就是我们看到的普通新闻界面，最多只能打开四个，超过四个就会将之前最早的NewDetailActivity关闭，原因很简单，如果无限制的话Activity会越建越多，整个应用越来越卡，影响用户体验。</p><pre><code class="hljs roboconf">TaskRecord&#123;8636<span class="hljs-attribute">d7b #6564 A=com.ss.android.article.lite U=0 StackId=282 sz=5&#125;</span><span class="hljs-attribute">        Run #4</span>: ActivityRecord&#123;8794744 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.base</span><span class="hljs-variable">.feature</span><span class="hljs-variable">.detail</span>2<span class="hljs-variable">.view</span><span class="hljs-variable">.NewDetailActivity</span> t6564&#125;        Run #3: ActivityRecord&#123;8be5248 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.base</span><span class="hljs-variable">.feature</span><span class="hljs-variable">.detail</span>2<span class="hljs-variable">.view</span><span class="hljs-variable">.NewDetailActivity</span> t6564&#125;        Run #2: ActivityRecord&#123;8bd6a09 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.base</span><span class="hljs-variable">.feature</span><span class="hljs-variable">.detail</span>2<span class="hljs-variable">.view</span><span class="hljs-variable">.NewDetailActivity</span> t6564&#125;        Run #1: ActivityRecord&#123;87cc383 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.base</span><span class="hljs-variable">.feature</span><span class="hljs-variable">.detail</span>2<span class="hljs-variable">.view</span><span class="hljs-variable">.NewDetailActivity</span> t6564&#125;        Run #0: ActivityRecord&#123;8bd6b44 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/<span class="hljs-variable">.activity</span><span class="hljs-variable">.SplashActivity</span> t6564&#125;复制代码</code></pre><p>而且还可以发现这个**今日头条极速版的主页叫SplashActivity，真他么牛逼~**，估计是原来有个SplashActivity界面和MainActivity界面，为了优化快速启动，给用户一个秒开的感觉，移除原来的SplashActivity，直接把MainActivity改名为SplashActivity，然后做主题的替换。</p><p>然后我们看看它的启动模式，启动模式是standard。</p><pre><code class="hljs java">~ » adb shell dumpsys activity | grep SplashActivity                                                             jackie<span class="hljs-meta">@JackieLindeMacBook</span>-Pro    baseIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity &#125;    baseIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.sina.weibo/.SplashActivit &#125;    baseIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=cmccwm.mobilemusic/.ui.base.SplashActivity &#125;    baseIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.daimajia.gold/im.juejin.android.ui.SplashActivity &#125;      Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity bnds=[<span class="hljs-number">544</span>,<span class="hljs-number">149</span>][<span class="hljs-number">796</span>,<span class="hljs-number">458</span>] &#125;      mActivityComponent=com.ss.android.article.lite/.activity.SplashActivity    mIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity bnds=[<span class="hljs-number">544</span>,<span class="hljs-number">149</span>][<span class="hljs-number">796</span>,<span class="hljs-number">458</span>] &#125;     #0 ActivityRecord&#123;8e43505 u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125; type=standard mode=fullscreen override-mode=undefined  //启动模式是standard      intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity&#125;      mActivityComponent=com.ss.android.article.lite/.activity.SplashActivity      Activities=[ActivityRecord&#123;<span class="hljs-number">8e43505</span> u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;]        Hist #0: ActivityRecord&#123;8e43505 u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;          Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity bnds=[<span class="hljs-number">544</span>,<span class="hljs-number">149</span>][<span class="hljs-number">796</span>,<span class="hljs-number">458</span>] &#125;        Run #0: ActivityRecord&#123;8e43505 u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;    mResumedActivity: ActivityRecord&#123;<span class="hljs-number">8e43505</span> u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;      intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.sina.weibo/.SplashActivity&#125;      mActivityComponent=com.sina.weibo/.SplashActivity      intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=cmccwm.mobilemusic/.ui.base.SplashActivity&#125;      mActivityComponent=cmccwm.mobilemusic/.ui.base.SplashActivity ResumedActivity:ActivityRecord&#123;<span class="hljs-number">8e43505</span> u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;  ResumedActivity: ActivityRecord&#123;<span class="hljs-number">8e43505</span> u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;复制代码</code></pre><p>再来看今日头条的首页的启动模式，它的首页叫MainActivity，用的也是standard。</p><pre><code class="hljs java">adb shell dumpsys activity | grep MainActivity                                                                                                          jackie<span class="hljs-meta">@JackieLindeMacBook</span>-      Intent &#123; flg=<span class="hljs-number">0x24008000</span> cmp=com.ss.android.article.news/.activity.MainActivity (has extras) &#125;      mActivityComponent=com.ss.android.article.news/.activity.MainActivity    mIntent=Intent &#123; flg=<span class="hljs-number">0x24008000</span> cmp=com.ss.android.article.news/.activity.MainActivity (has extras) &#125;     #0 ActivityRecord&#123;8fadec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125; type=standard mode=fullscreen override-mode=undefined  //standard启动模式     #0 ActivityRecord&#123;9130583 u0 cmccwm.mobilemusic/.ui.base.MainActivity t6681&#125; type=standard mode=fullscreen override-mode=undefined      Activities=[ActivityRecord&#123;<span class="hljs-number">8f</span>adec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;]        Hist #0: ActivityRecord&#123;8fadec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;          Intent &#123; flg=<span class="hljs-number">0x24008000</span> cmp=com.ss.android.article.news/.activity.MainActivity (has extras) &#125;        Run #0: ActivityRecord&#123;8fadec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;    mResumedActivity: ActivityRecord&#123;<span class="hljs-number">8f</span>adec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;      Activities=[ActivityRecord&#123;<span class="hljs-number">9130583</span> u0 cmccwm.mobilemusic/.ui.base.MainActivity t6681&#125;, ActivityRecord&#123;<span class="hljs-number">9822</span>b05 u0 cmccwm.mobilemusic/com.migu.music.ui.local.LocalSongsActivity t6681&#125;]        Hist #0: ActivityRecord&#123;9130583 u0 cmccwm.mobilemusic/.ui.base.MainActivity t6681&#125;          Intent &#123; flg=<span class="hljs-number">0x10000000</span> cmp=cmccwm.mobilemusic/.ui.base.MainActivity (has extras) &#125;        Run #0: ActivityRecord&#123;9130583 u0 cmccwm.mobilemusic/.ui.base.MainActivity t6681&#125; ResumedActivity:ActivityRecord&#123;<span class="hljs-number">8f</span>adec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;  ResumedActivity: ActivityRecord&#123;<span class="hljs-number">8f</span>adec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;复制代码</code></pre><p>我在今日头条和今日头条极速版的app中寻找从某个界面点击某个按钮返回到主页的场景，没有发现有这样的场景，或者说很少（可能是我没有发现），前面也说过使用standard标准模式只要是每次被启动都会创建一个新的实例，如果其他界面回到主页的场景多的话，我觉得可能会用singleTop（当要实现类似SingleTask的效果时可以配合flag实现）。场景极少或者没有是它使用standard的原因吧。</p><p>到此，我们对Activity的介绍和分析已经完毕了，喜欢的点个赞和关注吧。</p>]]></content>
    
    
    <categories>
      
      <category>Android面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android View 从测量布局到触摸反馈</title>
    <link href="/Blog/2020/11/19/Android-View-%E4%BB%8E%E6%B5%8B%E9%87%8F%E5%B8%83%E5%B1%80%E5%88%B0%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88/"/>
    <url>/Blog/2020/11/19/Android-View-%E4%BB%8E%E6%B5%8B%E9%87%8F%E5%B8%83%E5%B1%80%E5%88%B0%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88/</url>
    
    <content type="html"><![CDATA[<p>#自定义View</p><blockquote><p>在Android开发中，自定义 View 最关键的有三个点：绘制、布局和触摸反馈(绘制内容多而简单，查看手册即用即学，这里不记录了)</p></blockquote><p>#布局</p><blockquote><ul><li>测量阶段 ：从上到下<code>递归</code>地调用每个 <code>View</code> 或者 <code>ViewGroup</code> 的 <code>measure() </code>方法，测量他们的尺寸并计算它们的位置</li><li>布局阶段：从上到下<code>递归</code>地调用a每个 <code>View</code> 或者 <code>ViewGroup</code> 的 <code>layout() </code>方法，把测得的它们的尺寸和位置赋值给它们<br>#####测量阶段</li></ul></blockquote><ul><li><code>measure()</code> 方法被父<code>View</code>调用，在 <code>measure() </code>中做一些准备和优化工作后，调用 <code>onMeasure() </code>来进行实际的自我测量</li></ul><blockquote><ul><li>View：<code>View</code> 在 <code>onMeasure()</code> 中会计算出自己的尺寸然后保存</li><li>ViewGroup：<code>ViewGroup</code> 在 <code>onMeasure() </code>中会调用所有<code>子 View </code>的 <code>measure() </code>让它们进行自我测量，并根据<code>子 View</code> 计算出的期望尺寸来计算出它们的实际尺寸和位置然后保存。同时，它也会根据<code>子 View </code>的<code>尺寸</code>和<code>位置</code>来计算出自己的尺寸然后保存<br>注：保存会调用<code>setMeasuredDimension(int,int)</code>，可通过<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>获取保存的值<br>#####布局阶段</li></ul></blockquote><ul><li><code>layout() </code>方法被父 <code>View</code> 调用，在<code>layout()</code> 中它会保存父 <code>View</code> 传进来的自己的位置和尺寸，并且调用 <code>onLayout()</code> 来进行实际的内部布局</li></ul><blockquote><ul><li>View：由于没有子 View，所以 <code>View</code> 的 <code>onLayout() </code>什么也不做</li><li>ViewGroup：<code>ViewGroup</code> 在 <code>onLayout() </code>中会调用自己的所有<code>子 View </code>的<code>layout()</code>方法，把它们的尺寸和位置传给它们（layout方法中会有参数，即实际让子View布局的尺寸参数），让它们完成自我的内部布局<br>下面给出示意图：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-5e90050757f139b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View布局过程.png"><br><img src="https://upload-images.jianshu.io/upload_images/17794320-30a25832259b0599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewGroup布局过程.png"></li></ul></blockquote><p>了解上面的测量布局过程之后，我们很容易地想到以下3种自定义布局过程<br>##自定义布局过程</p><ul><li>重写 <code>onMeasure()</code> 来修改已有的 <code>View</code> 的尺寸(先调用<code>super.onMeasure()</code>)</li><li>重写 <code>onMeasure()</code> 来全新定制自定义 <code>View</code> 的尺寸（不用<code>super.onMeasure()</code>）</li><li>重写 <code>onMeasure()</code> 和 <code>onLayout()</code> 来全新定制自定义 <code>ViewGroup</code> 的内部布局<br>######第一种（修改已有尺寸）<br>1.重写 <code>onMeasure() </code>方法，并在里面调用 super.onMeasure()，触发原有的自我测量<br>2.<code>super.onMeasure()</code>的下面用<code>getMeasuredWidth()</code>和 <code>getMeasuredHeight() </code>来获取到之前的测量结果(宽和高)，并加上自己的代码，根据测量结果计算出新的结果</li></ul><blockquote><p><code>getMeasuredWidth()</code> 和 <code>getMeasuredHeight()</code> 是测得的尺寸（即<code>View</code>在<code>onMeasure</code>中调用<code>setMeasureDimension()</code>保存下来的数据）未必与之后<code>父View</code>调用<code>layout()</code>时传递进来的的尺寸参数相等，具体值是由父View决定！</p></blockquote><p>3.使用<code>setMeasureDimension()</code>保存自定义测量的尺寸值</p><p>######第二种（完全自己计算尺寸）<br>1.重写<code>onMeasure()</code>，计算尺寸(自己计算图、文字等等的长宽作加法运算)<br>2.把计算结果用<code>resolveSize()</code>修正一下<br>3.使用<code>setMeasureDimension()</code>保存自定义测量的尺寸值（也可以自己实现方法来满足父View的限制）</p><blockquote><p>在<code>onMeasure()</code>中有两个参数<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>，它们是<code>父View</code>对<code>子View</code>的测量尺寸的限制，来源于<code>xml</code>中以<code>layout_</code>打头的属性参数,这两个属性各自可以被<code>MeasureSpec.getMode</code>和<code>MeasureSpec.getSize</code>拆分为<code>Mode</code>和<code>SIZE</code><br><code>Mode</code>是限制的类型，包含3种：无限制<code>UNSPECIFIED</code>、限制上限<code>AT_MOST</code>、限制固定值<code>EXACTLY</code><br><code>View</code>为我们提供了<code>resolveSize()</code>方法用来便捷地对应这种限制</p><p><img src="https://upload-images.jianshu.io/upload_images/17794320-7547d490758465b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/17794320-9ab7c57672402505.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>######第三种（ViewGroup自定义测量以及布局过程）<br>1.重写<code>onMeasure()</code>来计算内部布局</p><ul><li>调用每个子View的measure, 让<code>子View</code>自我测量</li><li>根据子View给出的尺寸，得到子View的位置，并保存它们的位置和尺寸</li><li>根据子View的位置和尺寸计算出自己的尺寸并用setMeasuredDimension()保存</li></ul></blockquote><p>2.重写<code>onLayout()</code>来摆放<code>子View</code></p><ul><li>在<code>onMeasure()</code>中，需要根据<code>ViewGroup</code>自身的 <strong>可用空间</strong> 结合<code>子View</code>的<code>layout_</code>打头的属性去测量每个<code>子View</code>的尺寸，并且用  <code>MeasureSpec.makeMeasureSpec()</code> 压缩成<code>MeasureSpec(子View的可用空间)</code>并保存</li><li><code>layout_</code>打头的属性：这类属性是<code>子View</code>提供给<code>父View</code>测量时用的，在Java代码中可以通过<code>view.getLayoutParam()</code>获得。全新自定义<code>ViewGroup</code>时只有 <code>layout_width</code>和<code>layout_height</code> ，开发者可以继续自定义这类属性例如<code>layout_gravity</code>，在自定义测量过程时将其考虑进去即可</li><li>可用空间：对于<code>ViewGroup</code>本身来说最初的可用空间是<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>的参数，而在往<code>子View</code>分配可用空间时，我们可以自己制定规则，可以将<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>直接作为第一个<code>子View</code>的 <strong>可用空间</strong>，也可以自己做一些删减。当第一个<code>子View</code>的测量完成,继续测量第二个<code>子View</code>的时候，需要在<code>widthMeasureSpec</code>或者<code>heightMeasureSpec</code>基础上将第一个<code>子View</code>的 <strong>已用空间</strong> 减去,就得到了第二个<code>子View</code>的可用空间，以此类推</li><li>可用空间判断方法(通用方式，有特例)：</li></ul><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-ea767e7316e78492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可用空间判断"><br>首先根据<code>子View</code>在的xml布局声明的<code>layout_width</code>和<code>layout_height</code>(lp.width、lp.height)分两种情况</p></blockquote><ul><li>MATCH_PARENT：<ul><li><code>ViewGroup</code>的限制为<code>EXACTLY</code>或<code>AT_MOST</code>：由于<code>子View</code>依赖<code>父View</code>，<code>父View</code>需要告诉<code>子View</code>其可用宽度，并且<code>ViewGroup</code>本身可用空间可以确定，所以应当给予<code>子View</code>的限制属性是一个具体值，mode为<code>EXACTLY</code>；此处给予 <code>子View</code> 的宽度是可用宽度，不管 父View 是 <code>AT_MOST</code> 还是<code>EXACTLY</code>，两种的原则都是这块空间<code>子View</code>随便用，so <code>子View</code>的可用空间就是当前ViewGroup的初始可用空间（<code>onMeasure()</code>传来的<code>widthMeasureSpec</code>）减去已用空间</li><li><code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>：<code>子View</code>依赖<code>父View</code>，但<code>ViewGroup</code>本身是<code>UNSPECIFIED</code>无限制大小的（这个地方说大小不是很合适，可用空间可能更佳），于是无法计算出<code>子View</code>的可用空间，所以直接将<code>子View</code>的<code>mode</code>也写为<code>UNSPECIFIED</code>,  不限制其可用空间大小。size直接给0，因为在<code>mode</code>为<code>UNSPECIFIED</code>情况下<code>size</code>无意义，实际在高版本Android有意义，这里不做解释</li></ul></li><li>WARP_CONTENT：<ul><li><code>ViewGroup</code>的限制为<code>EXACTLY</code>或<code>AT_MOST</code>：虽然<code>子View</code>是warp_content，子 View自我测量，但却不能直接将<code>UNSPECIFIED</code>给<code>子 View</code>，因为<code>wrap_content</code>有个隐藏条件是不超过<code>父View</code>，so这里给子View的<code>mode</code>是<code>AT_MOST</code>来限制它的最大尺寸；由于<code>ViewGroup</code>的<code>mode</code>为<code>EXACTLY</code>或<code>AT_MOST</code>，我们就可以得到可用空间大小，将其减去已用空间传给<code>子View</code>的可用空间即可(与match_parent时做法类似)</li><li><code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>：同上，<code>子View</code>需要自我测量，隐藏条件不超过<code>父View</code>应当被满足，但由于<code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>，无法给出具体的可用空间大小，于是无法满足开发者在<code>xml</code>中给<code>子View</code>的<code>wrap_content</code>属性，无奈只能传入<code>UNSPECIFIED</code>不对其进行限制，<code>size</code>依旧是0即可</li></ul></li><li>指定值（sp、dp）：直接给<code>子View</code>指定一个值，<code>ViewGroup</code>什么都不用做，直接将值下发给<code>子View</code>的可用空间，<code>mode</code>给<code>EXACTLY</code>即可</li></ul><p>布局过程基本结束，接下来是触摸反馈过程</p><p>#触摸反馈</p><blockquote><p>触摸反馈的本质就是把一系列的<code>触摸事件</code>解读为对应的操作，比如按下、弹起、滑动等等，开发者再根据解读出来的操作进行<code>反馈</code></p></blockquote><p>对于触摸事件，有两点需要注意</p><ul><li><code>触摸事件</code> 不相互独立，它们是成 <code>序列</code> （成组）出现的</li><li>每组事件由 <code>DOWN</code> 开头，由 <code>UP</code> 或 <code>CANCEL</code> 结尾</li></ul><p>大家都知道，自定义触摸反馈只需要重写<code>View</code>的<code>onTouchEvent(MotionEvent event)</code>方法，event中包含了此次触摸事件的<code>事件类型</code>、<code>坐标</code>等其他信息，当触摸事件不断被触发，<code>onTouchEvent()</code>就不断被调用，这是触摸反馈的<code>核心</code>。对于简单的 <strong>自定义触摸反馈</strong>，重写这个方法已经够了，但难免我们会遇上新的问题 —— 滑动冲突，只有当我们了解整个事件分发机制，才能够彻底解决滑动冲突。<br>在Android中，当一个触摸事件产生，<code>MotionEvent</code> 将从 <code>Activity（Window）</code>——&gt;<code>ViewGroup</code>（多个）——&gt; <code>View</code><br> <img src="https://upload-images.jianshu.io/upload_images/17794320-31aa080f30078289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>实际上学习Android的触摸事件分发机制就是学习以下3个组件的事件分发机制</p><ul><li><code>Activity</code>对触摸事件的分发机制</li><li><code>ViewGroup</code>对触摸事件的分发机制</li><li><code>View</code>对触摸事件的分发机制</li></ul><p>在Android的事件分发机制中，传递的核心方法有3个：</p><ul><li><code>dispatchTouchEvent()</code>：分发（传递）点击事件，当点击事件能够传递给当前View，该方法就会被调用</li><li><code>onInterceptTouchEvent()</code>：只存在于<code>ViewGroup</code>中，在<code>dispatchTouchEvent()</code>内部被调用，判断是否拦截了某个事件</li><li><code>onTouchEvent()</code>：处理点击事件，在<code>dispatchTouchEvent()</code>内部调用</li></ul><blockquote><p>这三个方法的解释不严谨，目的只是让大家现在有一个关系概念，而不是将每个细节都全理解，之后在源码中会有细节</p></blockquote><p>先上一个粗略的图，大概对事件分发流程有个印象，方便看源码的时候理解</p><p>##Activity的事件分发机制<br>当一个触摸事件发生时，事件最先传到 <code>Activity</code> 的 <code>dispatchTouchEvent()</code></p><pre><code class="hljs csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent ev</span>)</span> &#123;        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN)             onUserInteraction();        &#125;    <span class="hljs-comment">//获取Activity的window对象（实现类PhoneWindow）并调用其方法 `superDispatchTouchEvent()`</span>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    <span class="hljs-comment">//当未被处理，直接调用Activity的 `onTouchEvent()` 处理</span>        <span class="hljs-keyword">return</span> onTouchEvent(ev);    &#125;        <span class="hljs-comment">//空方法，当Activity在栈顶，触摸、按Home、back、menu都会触发该方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserInteraction</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;        <span class="hljs-comment">//Window</span>    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>) </span><span class="hljs-function">        <span class="hljs-comment">// mDecor = 顶层View（DecorView）的实例对象</span></span><span class="hljs-function">        <span class="hljs-comment">//DecorView是PhoneWindow的内部类，继承自FrameLayout，所以是一个ViewGroup</span></span><span class="hljs-function">        <span class="hljs-keyword">return</span> mDecor.<span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params"><span class="hljs-keyword">event</span></span>)</span>;    &#125;        <span class="hljs-comment">//DecorView</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;        <span class="hljs-comment">// 调用父类的方法 = ViewGroup的dispatchTouchEvent()</span>        <span class="hljs-comment">// 即 将事件传递到ViewGroup去处理，详细看ViewGroup的事件分发机制</span>        <span class="hljs-keyword">return</span> super.dispatchTouchEvent(<span class="hljs-keyword">event</span>);    &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;        <span class="hljs-comment">// 当一个点击事件未被Activity下任何一个View接收 / 处理时</span>        <span class="hljs-comment">// 应用场景：处理发生在Window边界外的触摸事</span>        <span class="hljs-keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;            finish();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//即只有在点击事件在Window边界外才会返回true，一般情况都返回false</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">shouldCloseOnTouch</span>(<span class="hljs-params">Context context, MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;    <span class="hljs-comment">// 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等</span>    <span class="hljs-keyword">if</span> (mCloseOnTouchOutside &amp;&amp; <span class="hljs-keyword">event</span>.getAction() == MotionEvent.ACTION_DOWN            &amp;&amp; isOutOfBounds(context, <span class="hljs-keyword">event</span>) &amp;&amp; peekDecorView() != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 返回true：说明事件在边界外，即 消费事件</span>    <span class="hljs-comment">// 返回false：未消费（默认）</span>&#125;</code></pre><blockquote><p>流程图 <img src="https://upload-images.jianshu.io/upload_images/17794320-73a1692c3d8e588a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity事件分发流程图"><br>红框中是重点！事件从这里下发到子View/View Group！<br>#ViewGroup事件的分发机制<br>Android 5.0后，ViewGroup.dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同；<br>为了便于理解，采用Android 5.0前的版本</p></blockquote><pre><code class="hljs aspectj">    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;     ... <span class="hljs-comment">// 仅贴出关键代码</span>        <span class="hljs-comment">// ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件</span>            <span class="hljs-keyword">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;              <span class="hljs-comment">// 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent（）修改</span>            <span class="hljs-comment">// 判断值2： !onInterceptTouchEvent(ev) = 对onInterceptTouchEvent()返回值取反</span>                    <span class="hljs-comment">// a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部</span>                    <span class="hljs-comment">// b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断</span>                    <span class="hljs-comment">// c. 关于onInterceptTouchEvent() -&gt;&gt;分析1</span>                ev.setAction(MotionEvent.ACTION_DOWN);                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrolledXInt = (<span class="hljs-keyword">int</span>) scrolledXFloat;                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrolledYInt = (<span class="hljs-keyword">int</span>) scrolledYFloat;                  <span class="hljs-keyword">final</span> View[] children = mChildren;                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mChildrenCount;              <span class="hljs-comment">// 通过for循环，遍历了当前ViewGroup下的所有子View</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                  <span class="hljs-keyword">final</span> View child = children[i];                  <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE                          || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//可见或正在执行动画 </span>                    child.getHitRect(frame);                      <span class="hljs-comment">// 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View</span>                    <span class="hljs-comment">// 若是，则进入条件判断内部</span>                    <span class="hljs-keyword">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> xc = scrolledXFloat - child.mLeft;                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> yc = scrolledYFloat - child.mTop;                          ev.setLocation(xc, yc);                          child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;                          <span class="hljs-comment">// 条件判断的内部调用了该View的dispatchTouchEvent()</span>                        <span class="hljs-comment">// 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制）</span>                        <span class="hljs-keyword">if</span> (child.dispatchTouchEvent(ev))  &#123;                         mMotionTarget = child;                          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                         <span class="hljs-comment">// 调用子View的dispatchTouchEvent后是有返回值的</span>                        <span class="hljs-comment">// 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立</span>                        <span class="hljs-comment">// 于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出</span>                        <span class="hljs-comment">// 即把ViewGroup的点击事件拦截掉</span>                                &#125;                              &#125;                          &#125;                      &#125;                  &#125;              &#125;              <span class="hljs-keyword">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||                      (action == MotionEvent.ACTION_CANCEL);              <span class="hljs-keyword">if</span> (isUpOrCancel) &#123;          <span class="hljs-comment">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false   </span>        <span class="hljs-comment">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true   </span>        <span class="hljs-comment">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false   </span>        <span class="hljs-comment">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false   </span>                mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;              &#125;              <span class="hljs-keyword">final</span> View <span class="hljs-keyword">target</span> = mMotionTarget;          <span class="hljs-comment">// 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true）</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == <span class="hljs-keyword">null</span>) &#123;              ev.setLocation(xf, yf);              <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="hljs-number">0</span>) &#123;                  ev.setAction(MotionEvent.ACTION_CANCEL);                  mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;              &#125;                          <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;            <span class="hljs-comment">// 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent()</span>            <span class="hljs-comment">// 因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（））</span>            <span class="hljs-comment">// 此处需与上面区别：子View的dispatchTouchEvent（）</span>        &#125;         ... &#125;  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;        <span class="hljs-comment">//返回true = 拦截，即事件停止往下传递（需手动设置，即复写onInterceptTouchEvent（），从而让其返回true）</span>      <span class="hljs-comment">//返回false = 不拦截（默认）</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;</code></pre><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-5e5ab9fbb8dbfc6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote><p>到这里为止，你会发现没有任何一个地方消费了（使用了）触摸事件，因为目前为止所有的过程都只是在下发（往下传递MotionEvent），而真正要处理事件，是等到View（真的View，不是ViewGroup）在 <code>dispatchTouchEvent()</code> 中去做操作，在这里才会 <strong>真正</strong> 让 <code>dispatchTouchEvent()</code>与 <code>onTouchEvent()</code> 产生交集，接着往下看<br>#View事件的分发机制</p><pre><code class="hljs csharp">  <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;    <span class="hljs-comment">// 只有以下3个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent()</span>  <span class="hljs-comment">//     1. mOnTouchListener != null</span>  <span class="hljs-comment">//     2. (mViewFlags &amp; ENABLED_MASK) == ENABLED</span>  <span class="hljs-comment">//     3. mOnTouchListener.onTouch(this, event)</span>        <span class="hljs-keyword">if</span> (mOnTouchListener != <span class="hljs-literal">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;                  mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;    <span class="hljs-comment">// 假如onTouch返回了true，直接返回True</span>onTouchEvent()处理            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          &#125;   <span class="hljs-comment">// 假如onTouch没返回true，交给此View的</span>        <span class="hljs-keyword">return</span> onTouchEvent(<span class="hljs-keyword">event</span>);    &#125;  <span class="hljs-comment">// 在这里为mOnTouchListener赋值</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOnTouchListener</span>(<span class="hljs-params">OnTouchListener l</span>)</span> &#123;     <span class="hljs-comment">// 即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空）</span>    mOnTouchListener = l;  &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 回调控件注册Touch事件时的onTouch（）；需手动复写设置，具体如下（以按钮Button为例）</span><span class="hljs-comment">  */</span>    button.setOnTouchListener(<span class="hljs-keyword">new</span> OnTouchListener() &#123;          @Override          <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouch</span>(<span class="hljs-params">View v, MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;          &#125;      &#125;);</code></pre><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-6e3cbb62240c4242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android环境下 MQTT+Protocol Buffers实现消息推送</title>
    <link href="/Blog/2020/11/19/Android%E7%8E%AF%E5%A2%83%E4%B8%8B-MQTT-Protocol-Buffers%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    <url>/Blog/2020/11/19/Android%E7%8E%AF%E5%A2%83%E4%B8%8B-MQTT-Protocol-Buffers%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Android环境下-MQTT-Protocol-Buffers实现消息推送"><a href="#Android环境下-MQTT-Protocol-Buffers实现消息推送" class="headerlink" title="Android环境下 MQTT+Protocol Buffers实现消息推送"></a>Android环境下 MQTT+Protocol Buffers实现消息推送</h1><pre><code>曾记否，大学初识Android时，做出一款聊天软件曾是多少少年的梦想。。。（好吧可能只是我的)emm… 怎么写？长连接，那就直接怼socket吧！于是闷起脑壳就开始写。服务端+客户端，一通操作猛如虎，并伴随着各种线程异常之后终于是肝出来一个聊天室，，，好像还阔以，但是随着少年长大，你渐渐明白服务的重要性，这样的连接你可能保持不了几个，想实现消息推送,MQTT了解一下？</code></pre><h2 id="MQTT-消息队列遥测传输"><a href="#MQTT-消息队列遥测传输" class="headerlink" title="MQTT(消息队列遥测传输)"></a>MQTT(<strong>消息队列遥测传输</strong>)</h2><blockquote><p>一个基于客户端-服务器的消息发布/订阅传输协议。优点：<code>轻量</code>、<code>简单</code>、<code>开放</code>、<code>易于实现</code>;由于其<code>低开销</code>、<code>低带宽占用</code>，所以在物联网、小型设备、移动应用等方面有广泛的应用<br>MQTT协议有三种身份： <code>发布者</code>、<code>代理</code>、<code>订阅者</code>，发布者和订阅者都为客户端，代理为服务器，同时消息的发布者也可以是订阅者<br>MQTT传输的消息分为主题（Topic，可理解为消息的类型，订阅者订阅后，就会收到该主题的消息内容<code>payload</code>。<br>运行流程:<img src="https://upload-images.jianshu.io/upload_images/17794320-daee414b823bba2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote><p>特点如下</p><blockquote><p>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序之间的耦合。</p><p>对负载内容屏蔽的消息传输。</p><p>使用 TCP/IP 提供基础网络连接。</p><p>小型传输，开销很小(固定长度的是头部是2个字节)，协议交换最小化，以降低网络流量<br>整体上协议可拆分为：固定头部+可变头部+消息体</p><p>提供一种机制，使得客户端异常中断时，能够使用LastWill和Testament特性通知有关各方<br>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。<br>Testament：遗嘱机制，功能类似于Last Will。</p><p>有三种级别消息发布服务质量：<br>qos为0：“至多一次”，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复，不久会发送第二次。<br>qos为1：“至少一次”，确保消息到达，但消息重复可能会发生。<br>qos为2：“只有一次”，确保消息到达一次。</p></blockquote><pre><code>有了`MQTT`代替`Socket`作为传输协议，但是数据结构呢？你也许会说`json`，但在通讯极其频繁的IM或者推送泛滥的场景中，`Protocol Buffers`更加适用（当然各有各的优缺点，比如`json`易读，`Protocol Buffers`**小**、**快**），当然使用它我们得有后端同学支持</code></pre><blockquote><p>有了协议，我们还需要一个服务来为我们提供消息的订阅发送，我使用的是<code>EMQ</code>，需要后端同学将自己的服务与<code>EMQ</code>服务接入进行通讯</p></blockquote><p>##EMQ</p><blockquote><p>EMQ X Broker 是基于高并发的 Erlang/OTP 语言平台开发，支持百万级连接和分布式集群架构，发布订阅模式的开源 MQTT 消息服务器。<br>EMQ X Broker 在全球物联网市场广泛应用。无论是产品原型设计、物联网创业公司、还是大规模的商业部署，EMQ X Broker 都支持开源免费使用。<br>详情：<a href="https://www.emqx.io/cn/">https://www.emqx.io/cn/</a></p></blockquote><p>##Protocol Buffer</p><blockquote><p><code>Protocol Buffers</code> 是<strong>Google</strong>推出的用于序列化结构化数据的灵活、高效、自动化的机制。它与 <code>XML</code>、<code>JSON</code>一样都是<code>结构数据序列化</code>的工具，但<code>ProtoBuffer</code>更小，更快，更简单。开发者需要定义一次构造数据的方式，然后就可以使用特定代码轻松地在各种语言的各种数据流中写入和读取数据。同样，使用它必须有后端同学的支持<br>详情：<a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p></blockquote><p>优点</p><ul><li>性能较xml,json, thirft等好，效率高<br>代码生成机制，数据解析类自动生成</li><li>支持向后兼容和向前兼容</li><li>支持多种编程语言（java，c++，python）</li></ul><p>缺点</p><ul><li><p>二进制格式导致可读性差</p></li><li><p>缺乏自描述</p><p>先上个 <code>Protocol Buffers</code> 与 <code>json</code> 的对比图</p></li></ul><pre><code class="hljs angelscript"><span class="hljs-comment">//json：</span>&#123;    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Fenrir&quot;</span>,    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age1&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age2&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age3&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age4&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age5&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age6&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age7&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age8&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age9&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age10&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age11&quot;</span>:<span class="hljs-number">6</span>&#125;<span class="hljs-comment">//Protocol Buffers:</span><span class="hljs-number">10</span> <span class="hljs-number">6</span> <span class="hljs-number">70</span> <span class="hljs-number">101</span> <span class="hljs-number">110</span> <span class="hljs-number">114</span> <span class="hljs-number">105</span> <span class="hljs-number">114</span> <span class="hljs-number">16</span> <span class="hljs-number">34</span> <span class="hljs-number">24</span> <span class="hljs-number">46</span> <span class="hljs-number">32</span> <span class="hljs-number">56</span> <span class="hljs-number">40</span> <span class="hljs-number">16</span> <span class="hljs-number">48</span> <span class="hljs-number">56</span> <span class="hljs-number">56</span> <span class="hljs-number">86</span> <span class="hljs-number">64</span> <span class="hljs-number">66</span> <span class="hljs-number">72</span> <span class="hljs-number">56</span> <span class="hljs-number">80</span> <span class="hljs-number">86</span> <span class="hljs-number">88</span> <span class="hljs-number">54</span> <span class="hljs-number">96</span> <span class="hljs-number">66</span> <span class="hljs-number">104</span> <span class="hljs-number">66</span><span class="hljs-comment">//或者将其Base64，变得下面这样</span>CgZGZW5yaXIQIhguIDgoEDA4OFZAQkg4UFZYNmBCaEI=</code></pre><p>QA：？？？</p><pre><code>`Protocol Buffers`将数据从对象转换成了一个`byte数组`。诚然，由于其可读性差，测试工作会变得困难;    但是使用`Protocol Buffers`不仅能降低数据传输代价，并且无论是在客户端还是服务端，对于数据的`序列化`与`反序列化`速度都将得到不小的提升；所以这并不应该成为使用它的障碍，在真正实装起来时就需要我们给QA们写一个序列化与反序列化的工具。</code></pre><p>##在Android使用Protocol Buffers<br>project gradle中</p><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;    <span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.google.protobuf:protobuf-gradle-plugin:0.8.8&#x27;</span>&#125;</code></pre><p>app gradle中</p><pre><code class="hljs properties"><span class="hljs-attr">apply</span> <span class="hljs-string">plugin: &#x27;com.google.protobuf&#x27; //应用proto插件</span>    <span class="hljs-attr">protobuf</span> <span class="hljs-string">&#123;</span>        <span class="hljs-attr">protoc</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">artifact</span> = <span class="hljs-string">&#x27;com.google.protobuf:protoc:3.0.0&#x27;</span>        <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">plugins</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">javalite</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">artifact</span> = <span class="hljs-string">&#x27;com.google.protobuf:protoc-gen-javalite:3.0.0&#x27;</span>            <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">generateProtoTasks</span> <span class="hljs-string">&#123;</span>            <span class="hljs-meta">all().each</span> <span class="hljs-string">&#123; task -&gt;</span>                <span class="hljs-meta">task.builtins</span> <span class="hljs-string">&#123;</span>                    <span class="hljs-attr">remove</span> <span class="hljs-string">java</span>                <span class="hljs-attr">&#125;</span>                <span class="hljs-meta">task.builtins</span> <span class="hljs-string">&#123;</span>                    <span class="hljs-attr">java</span> <span class="hljs-string">&#123;&#125;</span>                    <span class="hljs-attr">cpp</span> <span class="hljs-string">&#123;&#125;</span>                <span class="hljs-attr">&#125;</span>            <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">sourceSets</span> <span class="hljs-string">&#123;</span>        <span class="hljs-attr">main</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">java</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">srcDir</span> <span class="hljs-string">&#x27;src/main/java&#x27;</span>            <span class="hljs-attr">&#125;</span>            <span class="hljs-attr">proto</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">srcDir</span> <span class="hljs-string">&#x27;src/main/proto&#x27; //配置proto文件路径</span>            <span class="hljs-attr">&#125;</span>            <span class="hljs-meta">jniLibs.srcDir</span> <span class="hljs-string">&#x27;libs&#x27;</span>            <span class="hljs-meta">jni.srcDirs</span> = <span class="hljs-string">[]    //disable automatic ndk-build</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;</span><span class="hljs-attr">dependencies</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attr">api</span> <span class="hljs-string">&#x27;com.google.protobuf:protobuf-java:3.6.1&#x27;</span>    <span class="hljs-attr">api</span> <span class="hljs-string">&#x27;com.google.protobuf:protoc:3.10.1&#x27;</span>    <span class="hljs-attr">implementation</span> <span class="hljs-string">&#x27;com.squareup.retrofit2:converter-protobuf:2.2.0&#x27;</span><span class="hljs-attr">&#125;</span></code></pre><blockquote><p>这里以构建一个无限发送心跳包的程序为例，这里实现心跳包的目的如下</p></blockquote><ul><li>为服务端提供信息用于判断用户是否下线</li><li>确保与服务端建立的topic的唯一性</li><li>顺便增加一下Android服务的优先级</li></ul><p>使用ProtocolBuffers前需要先编辑<code>.proto</code>文件，语法过多就不写在这里了，请移步至<a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a><br>在src/main下创建文件夹proto并在其目录下创建文件 MqttHeartBeatMessage.proto</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">//protoBuf版本</span><span class="hljs-keyword">package</span> rubbishcommunity; <span class="hljs-comment">//包</span><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.example.xxxxxxx&quot;</span>; <span class="hljs-comment">//包名</span><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;MqttHeartBeatMessageOutClass&quot;</span>; <span class="hljs-comment">//生成的Java Class文件类名</span><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MqttHeartBeatMessage</span></span>&#123;    <span class="hljs-built_in">int64</span> uin = <span class="hljs-number">1</span>;    <span class="hljs-built_in">string</span> linkKey = <span class="hljs-number">2</span>;    <span class="hljs-built_in">int64</span> timestamp = <span class="hljs-number">3</span>;&#125;</code></pre><p><code>.proto</code>文件编辑完成之后 Rebuild 编译一下项目,可以发现在java(generated)下面已经生成了proto编译成的java文件<code>MqttHeartBeatMessageOutClass.java</code>，里面包含了<code>MqttHeartBeatMessage.java</code>并实现了<code>get</code>、<code>set</code>方法；</p><ul><li>到此，Proto部分算是完成了，接下来我们需要使用<code>MQTTService</code>实现无限发送心跳包,但在这之前，你要先了解下面两位</li></ul><p>##Eclipse Paho</p><blockquote><p>Eclipse提供的一个访问MQTT服务器的一种开源客户端库<br><a href="https://www.eclipse.org/paho/clients/android/">https://www.eclipse.org/paho/clients/android/</a></p></blockquote><p>##MqttAndroidClient</p><blockquote><p>简单的说就是对MQTTService的连接、通讯等方法的封装类<br>[<a href="https://www.eclipse.org/paho/files/android-javadoc/org/eclipse/paho/android/service/MqttAndroidClient.html]">https://www.eclipse.org/paho/files/android-javadoc/org/eclipse/paho/android/service/MqttAndroidClient.html]</a></p></blockquote><ul><li>引入MQTT的Service以及对Android相关资源</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">implementation</span> &#x27;org.eclipse.paho:org.eclipse.paho.client.mqttv<span class="hljs-number">3</span>:<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>&#x27;<span class="hljs-attribute">implementation</span> &#x27;org.eclipse.paho:org.eclipse.paho.android.service:<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>&#x27;</code></pre><ul><li>Manifests中注册<code>MqttService</code>的Service</li></ul><pre><code class="hljs routeros">&lt;service android:<span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;org.eclipse.paho.android.service.MqttService&quot;</span>/&gt;</code></pre><ul><li>在项目中使用<code>MqttAndroidClient</code>进行MQTT连接与通讯<br>理论上应该将<code>MqttAndroidClient</code>的生命周期与<code>Application</code>绑定在一起，在我的毕设项目中我是再写了一个<code>Service</code>，在我的<code>MainActivity</code>打开之后开启，并在Service中轮询发送心跳包；</li></ul><p>初始化代码：</p><pre><code class="hljs kotlin"><span class="hljs-comment">//新建Client,以设备ID作为client ID</span>mqttAndroidClient = MqttAndroidClient(context,MQTT_URL, <span class="hljs-comment">//MQTT服务地址</span>CLIRNT_ID <span class="hljs-comment">//MQTT连接在代理服务处的clientId，一般由后端同学定义</span>)mqttAndroidClient?.setCallback(<span class="hljs-keyword">object</span> : MqttCallbackExtended &#123;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectComplete</span><span class="hljs-params">(reconnect: <span class="hljs-type">Boolean</span>, serverURI: <span class="hljs-type">String</span>)</span></span> &#123;<span class="hljs-comment">//连接成功</span><span class="hljs-keyword">if</span> (reconnect) &#123;<span class="hljs-comment">// 由于clean Session ，我们需要重新订阅</span><span class="hljs-keyword">try</span> &#123;subscribeToTopic()&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    ex.printStackTrace()&#125;&#125;&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectionLost</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>)</span></span> &#123;<span class="hljs-comment">//连接断开</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">messageArrived</span><span class="hljs-params">(topic: <span class="hljs-type">String</span>, message: <span class="hljs-type">MqttMessage</span>)</span></span> &#123;              <span class="hljs-comment">//接收到订阅的消息</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deliveryComplete</span><span class="hljs-params">(token: <span class="hljs-type">IMqttDeliveryToken</span>)</span></span> &#123;<span class="hljs-comment">//服务器成功delivery消息</span>&#125;&#125;)<span class="hljs-comment">//新建连接设置</span><span class="hljs-keyword">val</span> mqttConnectOptions = MqttConnectOptions()<span class="hljs-comment">//断开后，是否自动连接</span>mqttConnectOptions.isAutomaticReconnect = <span class="hljs-literal">true</span><span class="hljs-comment">//是否清空客户端的连接记录。若为true，则断开后，broker将自动清除该客户端连接信息</span>mqttConnectOptions.isCleanSession = <span class="hljs-literal">true</span><span class="hljs-comment">//设置Mq连接的userName</span>mqttConnectOptions.userName = getLocalEmail()<span class="hljs-comment">//设置超时时间，单位为秒</span><span class="hljs-comment">//mqttConnectOptions.setConnectionTimeout(2);</span><span class="hljs-comment">//心跳时间，单位为秒。即多长时间确认一次Client端是否在线（此心跳时间非刚才说的心跳时间，这个是MqttService内部的心跳）</span>mqttConnectOptions.keepAliveInterval = <span class="hljs-number">2</span><span class="hljs-comment">//允许同时发送几条消息（未收到broker确认信息）</span>mqttConnectOptions.maxInflight = <span class="hljs-number">2</span><span class="hljs-comment">//选择MQTT版本</span>mqttConnectOptions.mqttVersion = MqttConnectOptions.MQTT_VERSION_3_1_1<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//开始连接</span>mqttAndroidClient?.connect(mqttConnectOptions, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">object</span> : IMqttActionListener &#123;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(asyncActionToken: <span class="hljs-type">IMqttToken</span>)</span></span> &#123;<span class="hljs-keyword">val</span> disconnectedBufferOptions = DisconnectedBufferOptions()disconnectedBufferOptions.isBufferEnabled = <span class="hljs-literal">true</span>disconnectedBufferOptions.bufferSize = <span class="hljs-number">100</span>disconnectedBufferOptions.isPersistBuffer = <span class="hljs-literal">false</span>disconnectedBufferOptions.isDeleteOldestMessages = <span class="hljs-literal">true</span>mqttAndroidClient!!.setBufferOpts(disconnectedBufferOptions)subscribeToTopic()<span class="hljs-comment">//成功连接以后开始订阅</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(asyncActionToken: <span class="hljs-type">IMqttToken</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;<span class="hljs-comment">//连接失败</span>exception.printStackTrace()&#125;&#125;)&#125; <span class="hljs-keyword">catch</span> (ex: MqttException) &#123;ex.printStackTrace()&#125;</code></pre><p>轮询发送心跳包</p><pre><code class="hljs awk">Observable.interval(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS).doOnNext &#123;mqService <span class="hljs-regexp">//</span>这是我的服务，没有的话直接使用MqAndroidClient就好.publishMessage(Base64.encodeToString(<span class="hljs-regexp">//</span>下面就是构造proto生成的Class的对象了MqttHeartBeatMessageOutClass.MqttHeartBeatMessage.newBuilder().setLinkKey(getLinkKey()) <span class="hljs-regexp">//</span>proto中自定义的属性.setUin(getLocalUin()) <span class="hljs-regexp">//</span>proto中自定义的属性.setTimestamp(System.currentTimeMillis()) <span class="hljs-regexp">//</span>proto中自定义的属性.build() <span class="hljs-regexp">//</span>构造结束                              .toByteArray(),NO_WRAP),DEW_MQTT_HEART_BEAT_TOPIC <span class="hljs-regexp">//</span>心跳包的TOPIC)&#125;.subscribe()</code></pre><p>至此，心跳包发送已经完成了，接下来说说接收<code>Protocol Buffer</code>数据</p><p>在上面代码中应该看见了，在<code>MqttAndroidClient</code>接收的数据在<code>messageArrived(topic: String, message: MqttMessage)</code>方法中，实际上这里并非所有的消息都会是<code>protocol Buffers</code>消息，所以这里我们可以想办法区分，这里就不累述了。要说的是<code>Protocol Buffer</code>的消息在内部也是需要区分的，比如有两种消息过来1⃣️我的朋友圈有人点赞我需要知道是谁点赞2⃣️有人给我发消息我需要知道是什么消息，而这两种消息内部返回的数据结构可能就完全不一样，所以需要用到<code>Protocol Buffers</code>的enum进行区分，那么我们与后端同学一起定义一种<code>协议</code>,也就是接收的<code>ProtocolBuffers</code>消息的数据结构，像下面这样：</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<span class="hljs-keyword">package</span> rubbishcommunity;<span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.example.rubbishcommunity&quot;</span>;<span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;NotifyMessageOutClass&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NotifyType</span></span>&#123;    ERROR_DEFAULT_TYPE = <span class="hljs-number">0</span>; <span class="hljs-comment">//默认</span>    SYNC_NEW_MESSAGE = <span class="hljs-number">1</span>; <span class="hljs-comment">//新消息</span>    SYNC_MOMENTS_COMMENT = <span class="hljs-number">2</span>; <span class="hljs-comment">//有人点赞</span>&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">NotifyMessage</span></span>&#123;    Header header = <span class="hljs-number">1</span>; <span class="hljs-comment">//数据头</span>    <span class="hljs-built_in">string</span> payload = <span class="hljs-number">2</span>; <span class="hljs-comment">//真实数据（虽然是String，实际是后端将Protocol Buffers数据Base64之后的String）</span>&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Header</span></span>&#123;    NotifyType notifyType = <span class="hljs-number">1</span>; <span class="hljs-comment">//消息类型</span>    <span class="hljs-built_in">int64</span> timestamp = <span class="hljs-number">2</span>; <span class="hljs-comment">//时间戳</span>    <span class="hljs-built_in">string</span> notifyUUID = <span class="hljs-number">3</span>; <span class="hljs-comment">//消息UUID</span>&#125;</code></pre><p>之后我们就可以愉快地解析数据啦！举个栗子</p><p>MqttAndroidClient初始化的地方：</p><pre><code class="hljs reasonml">             <span class="hljs-comment">//订阅的消息送达</span>override <span class="hljs-keyword">fun</span> message<span class="hljs-constructor">Arrived(<span class="hljs-params">topic</span>: String, <span class="hljs-params">message</span>: MqttMessage)</span> &#123;<span class="hljs-comment">//先用Base64解码</span><span class="hljs-keyword">val</span> resBytes = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Base64</span>.</span></span>decode(message.payload, Base64.NO_WRAP)<span class="hljs-comment">//得到最外层的NotifyMessage对象</span><span class="hljs-keyword">val</span> notifyMessage = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NotifyMessageOutClass</span>.</span><span class="hljs-module"><span class="hljs-identifier">NotifyMessage</span>.</span></span>parse<span class="hljs-constructor">From(<span class="hljs-params">resBytes</span>)</span><span class="hljs-comment">//发送MQ事件，目前在BasegFragment中有处理事件的方法</span>send<span class="hljs-constructor">MQData(MQNotifyData(<span class="hljs-params">notifyMessage</span>.<span class="hljs-params">header</span>.<span class="hljs-params">notifyType</span>,<span class="hljs-params">notifyMessage</span>.<span class="hljs-params">payload</span>)</span>)&#125;</code></pre><p>BaseFragment中：</p><pre><code class="hljs reasonml"><span class="hljs-comment">//实际&#x27;MQ消息&#x27;处理者</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handle<span class="hljs-constructor">MQNotifyMessage()</span> &#123;notifyDisposable = get<span class="hljs-constructor">MQNotifyObs()</span>.observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>).doOnNext &#123;on<span class="hljs-constructor">MQMessageArrived(<span class="hljs-params">it</span>)</span>&#125;.subscribe(&#123;&#125;, &#123; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Timber</span>.</span></span>e(it) &#125;)&#125;</code></pre><p>实现的Fragment中：</p><pre><code class="hljs kotlin"><span class="hljs-comment">//有MQ消息</span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMQMessageArrived</span><span class="hljs-params">(mqNotifyData: <span class="hljs-type">MQNotifyData</span>)</span></span> &#123;<span class="hljs-keyword">when</span> (mqNotifyData.mqNotifyType) &#123;NotifyMessageOutClass.NotifyType.SYNC_MOMENTS_FAVORITE -&gt; &#123; <span class="hljs-comment">//有人点赞</span><span class="hljs-comment">//弹个通知并更新列表对应Item</span>&#125;<span class="hljs-keyword">else</span> -&gt; &#123;&#125;&#125;&#125;</code></pre><p>将得到的数据包装成自定义的一个<code>MQNotifyData</code>数据类，数据类中有<code>header</code>和<code>payload</code>，再通过<code>sendMQData()</code>发送到<code>Fragment</code>或者<code>Activity</code>中去，我是在<code>Fragment</code>中一直有一个mq消息的<code>Subject</code>流，当<code>sendMQData()</code>就触发<code>onNext()</code>，其中调用<code>BaseFragment</code>的方法，具体实现在具体需要MQ消息的<code>Fragment</code>中。这是我的方法而已，就是将数据通知到界面，如何实现随意，欢迎大佬来指正～</p><p>MQ中的<code>ProtocolBuffers</code>完成了，还有最后一步就是为我们的正常Http请求的数据也添加支持，啊好像写不完了，各位看官～下次补上吧～！！</p>]]></content>
    
    
    <categories>
      
      <category>网络通讯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中间凹陷的BottomNavigationView（仿百度地图）</title>
    <link href="/Blog/2020/11/19/%E4%B8%AD%E9%97%B4%E5%87%B9%E9%99%B7%E7%9A%84BottomNavigationView%EF%BC%88%E4%BB%BF%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%EF%BC%89/"/>
    <url>/Blog/2020/11/19/%E4%B8%AD%E9%97%B4%E5%87%B9%E9%99%B7%E7%9A%84BottomNavigationView%EF%BC%88%E4%BB%BF%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>##GapBottomNavigtionView</p><p>百度的：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-2ab547998387f2ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="71529789c6c948803e1075c2c7e00809.jpg"><br>我的：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-faea132de3d4305f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e9347423eb2031228af77ad63d7b01d7.jpg"></p><blockquote><p>项目地址：<a href="https://github.com/ZYF99/UIKit/tree/1.3">https://github.com/ZYF99/UIKit/tree/1.3</a></p></blockquote><p>###使用方式</p><p>在app的build.gradle中</p><pre><code class="hljs gradle"><span class="hljs-keyword">allprojects</span> &#123;<span class="hljs-keyword">repositories</span> &#123;...maven &#123; url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span> &#125;&#125;&#125;<span class="hljs-keyword">dependencies</span> &#123;        implementation <span class="hljs-string">&#x27;com.github.ZYF99:UIKit:1.3&#x27;</span>&#125;</code></pre><p>在布局文件中直接使用</p><pre><code class="hljs routeros">&lt;com.google.android.material.floatingactionbutton.FloatingActionButton    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/fab_add&quot;</span>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;30dp&quot;</span>    android:<span class="hljs-attribute">backgroundTint</span>=<span class="hljs-string">&quot;#ffffff&quot;</span>    android:<span class="hljs-attribute">elevation</span>=<span class="hljs-string">&quot;6dp&quot;</span>    android:<span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;@android:drawable/ic_input_add&quot;</span>    android:<span class="hljs-attribute">tint</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">borderWidth</span>=<span class="hljs-string">&quot;0dp&quot;</span>    app:<span class="hljs-attribute">fabSize</span>=<span class="hljs-string">&quot;normal&quot;</span>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">rippleColor</span>=<span class="hljs-string">&quot;#00FFFFFF&quot;</span>/&gt;&lt;com.zhangyf.gapbottomnavigationview.GapBottomNavigationView    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_marginStart</span>=<span class="hljs-string">&quot;32dp&quot;</span>    android:<span class="hljs-attribute">layout_marginEnd</span>=<span class="hljs-string">&quot;32dp&quot;</span>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;16dp&quot;</span>    android:<span class="hljs-attribute">backgroundTint</span>=<span class="hljs-string">&quot;#ffffff&quot;</span>    android:<span class="hljs-attribute">clickable</span>=<span class="hljs-string">&quot;false&quot;</span>    android:<span class="hljs-attribute">padding</span>=<span class="hljs-string">&quot;8dp&quot;</span>    app:<span class="hljs-attribute">center_radius</span>=<span class="hljs-string">&quot;32dp&quot;</span>    app:<span class="hljs-attribute">corner_radius</span>=<span class="hljs-string">&quot;12dp&quot;</span>    app:<span class="hljs-attribute">elevation</span>=<span class="hljs-string">&quot;5dp&quot;</span>    app:<span class="hljs-attribute">itemBackground</span>=<span class="hljs-string">&quot;@null&quot;</span>    app:<span class="hljs-attribute">itemIconTint</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">itemTextColor</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">labelVisibilityMode</span>=<span class="hljs-string">&quot;labeled&quot;</span>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">menu</span>=<span class="hljs-string">&quot;@menu/navigation&quot;</span>    app:<span class="hljs-attribute">shadow_length</span>=<span class="hljs-string">&quot;4dp&quot;</span>    tools:<span class="hljs-attribute">targetApi</span>=<span class="hljs-string">&quot;lollipop&quot;</span> /&gt;</code></pre><blockquote><p>anchor_fab： 用来指定凹陷下去的 View ，一般都为 FloatingActionButton<br>shadow_length：用来指定高度（阴影大小）<br>cornerRadius：用来指定拐角处的平滑半径大小</p></blockquote><p>##源码<br>attrs中的3个属性</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;GapBottomNavigationView&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;shadow_length&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;corner_radius&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center_radius&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><p>#####导入源码（请直接copy）</p><blockquote><p>源码采用Kotlin，有需要可以直接转为Java，转换方法自行百度</p></blockquote><pre><code class="hljs roboconf">package com.zhangyf.gapbottomnavigationview<span class="hljs-keyword">import</span> android.annotation.SuppressLint<span class="hljs-keyword">import</span> android.content.Context<span class="hljs-keyword">import</span> android.graphics.*<span class="hljs-keyword">import</span> android.graphics.drawable.GradientDrawable<span class="hljs-keyword">import</span> android.os.Build<span class="hljs-keyword">import</span> android.util.AttributeSet<span class="hljs-keyword">import</span> android.util.Log<span class="hljs-keyword">import</span> androidx.annotation.*<span class="hljs-keyword">import</span> com.google.android.material.bottomnavigation.BottomNavigationViewclass GapBottomNavigationView : BottomNavigationView &#123;    <span class="hljs-attribute">private var fabId = 0 //凹陷View的id</span><span class="hljs-attribute">    private var centerRadius</span>: Float = 0<span class="hljs-variable">.toFloat</span>() //中间凹陷的半径    private var cornerRadius = 12f //拐角处的圆滑大小（越大越平滑）    private var shadowLength = 6f //阴影大小    constructor(context: Context) : super(context)    constructor(context: Context, attrs: AttributeSet) : this(context, attrs, 0)    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(        context,        attrs,        defStyleAttr    ) &#123;        background = GradientDrawable()<span class="hljs-variable">.apply</span> &#123; setColor(Color<span class="hljs-variable">.TRANSPARENT</span>) &#125;        val ta = context<span class="hljs-variable">.obtainStyledAttributes</span>(attrs, R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView</span>)        centerRadius = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_center_radius</span>, 0<span class="hljs-variable">.toFloat</span>())        shadowLength = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_shadow_length</span>, 6<span class="hljs-variable">.toFloat</span>())        cornerRadius = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_corner_radius</span>, 12<span class="hljs-variable">.toFloat</span>())        ta<span class="hljs-variable">.recycle</span>()    &#125;    @SuppressLint(&quot;DrawAllocation&quot;)    @RequiresApi(api = Build<span class="hljs-variable">.VERSION_CODES</span><span class="hljs-variable">.KITKAT</span>)    override fun onDraw(canvas: Canvas) &#123;        super<span class="hljs-variable">.onDraw</span>(canvas)        val paint = Paint()        val path = Path()        //左边的半圆        val rectL = RectF(            shadowLength,            shadowLength,            height<span class="hljs-variable">.toFloat</span>() + shadowLength,            height<span class="hljs-variable">.toFloat</span>() - shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectL, 90<span class="hljs-variable">.toFloat</span>(), 180<span class="hljs-variable">.toFloat</span>(), false)        path<span class="hljs-variable">.lineTo</span>(width / 2 - centerRadius - cornerRadius, shadowLength)        //左边转角处        path<span class="hljs-variable">.quadTo</span>(            width / 2 - centerRadius,            shadowLength,            width / 2 - centerRadius,            cornerRadius + shadowLength        )        //中间凹陷的半圆        val rectCenter = RectF(            width / 2 - centerRadius,            cornerRadius + shadowLength - centerRadius,            width / 2 + centerRadius,            cornerRadius + centerRadius + shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectCenter, 180<span class="hljs-variable">.toFloat</span>(), (-180)<span class="hljs-variable">.toFloat</span>(), false)        //利用贝塞尔曲线画中间凹陷（非半圆）/*path<span class="hljs-variable">.quadTo</span>(width<span class="hljs-variable">.toFloat</span>() / 2,centerRadius<span class="hljs-variable">.toFloat</span>(),width / 2 + centerRadius - cornerRadius - cornerRadius / sqrt(2<span class="hljs-variable">.toFloat</span>()),cornerRadius / sqrt(2<span class="hljs-variable">.toFloat</span>()))*/        //右边转角处        path<span class="hljs-variable">.quadTo</span>(            width / 2 + centerRadius,            shadowLength,            width / 2 + centerRadius + cornerRadius,            shadowLength        )        path<span class="hljs-variable">.lineTo</span>((width - shadowLength - height / 2), shadowLength)        //右边的半圆        val rectR = RectF(            width<span class="hljs-variable">.toFloat</span>() - shadowLength - height,            shadowLength,            width<span class="hljs-variable">.toFloat</span>() - shadowLength,            height<span class="hljs-variable">.toFloat</span>() - shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectR, 270<span class="hljs-variable">.toFloat</span>(), 180<span class="hljs-variable">.toFloat</span>(), false)        //最后的直线        path<span class="hljs-variable">.moveTo</span>((width - shadowLength - height / 2), height<span class="hljs-variable">.toFloat</span>() - shadowLength)        path<span class="hljs-variable">.lineTo</span>(height / 2<span class="hljs-variable">.toFloat</span>() + shadowLength, height<span class="hljs-variable">.toFloat</span>() - shadowLength)        path<span class="hljs-variable">.close</span>()        Log<span class="hljs-variable">.d</span>(&quot;!!!&quot;, &quot;!!!!!!!!!!!!&quot;)        //按背景色填充背景        paint<span class="hljs-variable">.apply</span> &#123;            style = Paint<span class="hljs-variable">.Style</span><span class="hljs-variable">.FILL</span>            if (Build<span class="hljs-variable">.VERSION</span><span class="hljs-variable">.SDK_INT</span> &gt;= Build<span class="hljs-variable">.VERSION_CODES</span><span class="hljs-variable">.LOLLIPOP</span>) &#123;                color = backgroundTintList?<span class="hljs-variable">.defaultColor</span> ?: Color<span class="hljs-variable">.BLACK</span>            &#125;            maskFilter = null            isAntiAlias = true            //添加阴影            setShadowLayer(shadowLength, 0<span class="hljs-variable">.toFloat</span>(), 0<span class="hljs-variable">.toFloat</span>(), Color<span class="hljs-variable">.LTGRAY</span>)        &#125;        canvas<span class="hljs-variable">.drawPath</span>(path, paint)    &#125;&#125;</code></pre><blockquote><p>建议：结合我的代码并利用 paint（画笔） 随意更改为你想要的形状</p></blockquote><p>我的效果就是这样咯<br><img src="https://upload-images.jianshu.io/upload_images/17794320-fc974949ebf9b9ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="093143d5ebb666338bc164a6bd339da5.jpg"></p><p>喜欢不要忘了点赞关注或者去github点个星星哦～～</p>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
