<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android View 从测量布局到触摸反馈</title>
    <link href="/Blog/2020/11/19/Android-View-%E4%BB%8E%E6%B5%8B%E9%87%8F%E5%B8%83%E5%B1%80%E5%88%B0%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88/"/>
    <url>/Blog/2020/11/19/Android-View-%E4%BB%8E%E6%B5%8B%E9%87%8F%E5%B8%83%E5%B1%80%E5%88%B0%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88/</url>
    
    <content type="html"><![CDATA[<p>#自定义View</p><blockquote><p>在Android开发中，自定义 View 最关键的有三个点：绘制、布局和触摸反馈(绘制内容多而简单，查看手册即用即学，这里不记录了)</p></blockquote><p>#布局</p><blockquote><ul><li>测量阶段 ：从上到下<code>递归</code>地调用每个 <code>View</code> 或者 <code>ViewGroup</code> 的 <code>measure() </code>方法，测量他们的尺寸并计算它们的位置</li><li>布局阶段：从上到下<code>递归</code>地调用a每个 <code>View</code> 或者 <code>ViewGroup</code> 的 <code>layout() </code>方法，把测得的它们的尺寸和位置赋值给它们<br>#####测量阶段</li></ul></blockquote><ul><li><code>measure()</code> 方法被父<code>View</code>调用，在 <code>measure() </code>中做一些准备和优化工作后，调用 <code>onMeasure() </code>来进行实际的自我测量</li></ul><blockquote><ul><li>View：<code>View</code> 在 <code>onMeasure()</code> 中会计算出自己的尺寸然后保存</li><li>ViewGroup：<code>ViewGroup</code> 在 <code>onMeasure() </code>中会调用所有<code>子 View </code>的 <code>measure() </code>让它们进行自我测量，并根据<code>子 View</code> 计算出的期望尺寸来计算出它们的实际尺寸和位置然后保存。同时，它也会根据<code>子 View </code>的<code>尺寸</code>和<code>位置</code>来计算出自己的尺寸然后保存<br>注：保存会调用<code>setMeasuredDimension(int,int)</code>，可通过<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>获取保存的值<br>#####布局阶段</li></ul></blockquote><ul><li><code>layout() </code>方法被父 <code>View</code> 调用，在<code>layout()</code> 中它会保存父 <code>View</code> 传进来的自己的位置和尺寸，并且调用 <code>onLayout()</code> 来进行实际的内部布局</li></ul><blockquote><ul><li>View：由于没有子 View，所以 <code>View</code> 的 <code>onLayout() </code>什么也不做</li><li>ViewGroup：<code>ViewGroup</code> 在 <code>onLayout() </code>中会调用自己的所有<code>子 View </code>的<code>layout()</code>方法，把它们的尺寸和位置传给它们（layout方法中会有参数，即实际让子View布局的尺寸参数），让它们完成自我的内部布局<br>下面给出示意图：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-5e90050757f139b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View布局过程.png"><br><img src="https://upload-images.jianshu.io/upload_images/17794320-30a25832259b0599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewGroup布局过程.png"></li></ul></blockquote><p>了解上面的测量布局过程之后，我们很容易地想到以下3种自定义布局过程<br>##自定义布局过程</p><ul><li>重写 <code>onMeasure()</code> 来修改已有的 <code>View</code> 的尺寸(先调用<code>super.onMeasure()</code>)</li><li>重写 <code>onMeasure()</code> 来全新定制自定义 <code>View</code> 的尺寸（不用<code>super.onMeasure()</code>）</li><li>重写 <code>onMeasure()</code> 和 <code>onLayout()</code> 来全新定制自定义 <code>ViewGroup</code> 的内部布局<br>######第一种（修改已有尺寸）<br>1.重写 <code>onMeasure() </code>方法，并在里面调用 super.onMeasure()，触发原有的自我测量<br>2.<code>super.onMeasure()</code>的下面用<code>getMeasuredWidth()</code>和 <code>getMeasuredHeight() </code>来获取到之前的测量结果(宽和高)，并加上自己的代码，根据测量结果计算出新的结果</li></ul><blockquote><p><code>getMeasuredWidth()</code> 和 <code>getMeasuredHeight()</code> 是测得的尺寸（即<code>View</code>在<code>onMeasure</code>中调用<code>setMeasureDimension()</code>保存下来的数据）未必与之后<code>父View</code>调用<code>layout()</code>时传递进来的的尺寸参数相等，具体值是由父View决定！</p></blockquote><p>3.使用<code>setMeasureDimension()</code>保存自定义测量的尺寸值</p><p>######第二种（完全自己计算尺寸）<br>1.重写<code>onMeasure()</code>，计算尺寸(自己计算图、文字等等的长宽作加法运算)<br>2.把计算结果用<code>resolveSize()</code>修正一下<br>3.使用<code>setMeasureDimension()</code>保存自定义测量的尺寸值（也可以自己实现方法来满足父View的限制）</p><blockquote><p>在<code>onMeasure()</code>中有两个参数<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>，它们是<code>父View</code>对<code>子View</code>的测量尺寸的限制，来源于<code>xml</code>中以<code>layout_</code>打头的属性参数,这两个属性各自可以被<code>MeasureSpec.getMode</code>和<code>MeasureSpec.getSize</code>拆分为<code>Mode</code>和<code>SIZE</code><br><code>Mode</code>是限制的类型，包含3种：无限制<code>UNSPECIFIED</code>、限制上限<code>AT_MOST</code>、限制固定值<code>EXACTLY</code><br><code>View</code>为我们提供了<code>resolveSize()</code>方法用来便捷地对应这种限制<br><img src="https://upload-images.jianshu.io/upload_images/17794320-7547d490758465b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/17794320-9ab7c57672402505.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>######第三种（ViewGroup自定义测量以及布局过程）<br>1.重写<code>onMeasure()</code>来计算内部布局</p><ul><li>调用每个子View的measure, 让<code>子View</code>自我测量</li><li>根据子View给出的尺寸，得到子View的位置，并保存它们的位置和尺寸</li><li>根据子View的位置和尺寸计算出自己的尺寸并用setMeasuredDimension()保存</li></ul></blockquote><p>2.重写<code>onLayout()</code>来摆放<code>子View</code></p><ul><li>在<code>onMeasure()</code>中，需要根据<code>ViewGroup</code>自身的 <strong>可用空间</strong> 结合<code>子View</code>的<code>layout_</code>打头的属性去测量每个<code>子View</code>的尺寸，并且用  <code>MeasureSpec.makeMeasureSpec()</code> 压缩成<code>MeasureSpec(子View的可用空间)</code>并保存</li><li><code>layout_</code>打头的属性：这类属性是<code>子View</code>提供给<code>父View</code>测量时用的，在Java代码中可以通过<code>view.getLayoutParam()</code>获得。全新自定义<code>ViewGroup</code>时只有 <code>layout_width</code>和<code>layout_height</code> ，开发者可以继续自定义这类属性例如<code>layout_gravity</code>，在自定义测量过程时将其考虑进去即可</li><li>可用空间：对于<code>ViewGroup</code>本身来说最初的可用空间是<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>的参数，而在往<code>子View</code>分配可用空间时，我们可以自己制定规则，可以将<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>直接作为第一个<code>子View</code>的 <strong>可用空间</strong>，也可以自己做一些删减。当第一个<code>子View</code>的测量完成,继续测量第二个<code>子View</code>的时候，需要在<code>widthMeasureSpec</code>或者<code>heightMeasureSpec</code>基础上将第一个<code>子View</code>的 <strong>已用空间</strong> 减去,就得到了第二个<code>子View</code>的可用空间，以此类推</li><li>可用空间判断方法(通用方式，有特例)：</li></ul><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-ea767e7316e78492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可用空间判断"><br>首先根据<code>子View</code>在的xml布局声明的<code>layout_width</code>和<code>layout_height</code>(lp.width、lp.height)分两种情况</p></blockquote><ul><li>MATCH_PARENT：<ul><li><code>ViewGroup</code>的限制为<code>EXACTLY</code>或<code>AT_MOST</code>：由于<code>子View</code>依赖<code>父View</code>，<code>父View</code>需要告诉<code>子View</code>其可用宽度，并且<code>ViewGroup</code>本身可用空间可以确定，所以应当给予<code>子View</code>的限制属性是一个具体值，mode为<code>EXACTLY</code>；此处给予 <code>子View</code> 的宽度是可用宽度，不管 父View 是 <code>AT_MOST</code> 还是<code>EXACTLY</code>，两种的原则都是这块空间<code>子View</code>随便用，so <code>子View</code>的可用空间就是当前ViewGroup的初始可用空间（<code>onMeasure()</code>传来的<code>widthMeasureSpec</code>）减去已用空间</li><li><code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>：<code>子View</code>依赖<code>父View</code>，但<code>ViewGroup</code>本身是<code>UNSPECIFIED</code>无限制大小的（这个地方说大小不是很合适，可用空间可能更佳），于是无法计算出<code>子View</code>的可用空间，所以直接将<code>子View</code>的<code>mode</code>也写为<code>UNSPECIFIED</code>,  不限制其可用空间大小。size直接给0，因为在<code>mode</code>为<code>UNSPECIFIED</code>情况下<code>size</code>无意义，实际在高版本Android有意义，这里不做解释</li></ul></li><li>WARP_CONTENT：<ul><li><code>ViewGroup</code>的限制为<code>EXACTLY</code>或<code>AT_MOST</code>：虽然<code>子View</code>是warp_content，子 View自我测量，但却不能直接将<code>UNSPECIFIED</code>给<code>子 View</code>，因为<code>wrap_content</code>有个隐藏条件是不超过<code>父View</code>，so这里给子View的<code>mode</code>是<code>AT_MOST</code>来限制它的最大尺寸；由于<code>ViewGroup</code>的<code>mode</code>为<code>EXACTLY</code>或<code>AT_MOST</code>，我们就可以得到可用空间大小，将其减去已用空间传给<code>子View</code>的可用空间即可(与match_parent时做法类似)</li><li><code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>：同上，<code>子View</code>需要自我测量，隐藏条件不超过<code>父View</code>应当被满足，但由于<code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>，无法给出具体的可用空间大小，于是无法满足开发者在<code>xml</code>中给<code>子View</code>的<code>wrap_content</code>属性，无奈只能传入<code>UNSPECIFIED</code>不对其进行限制，<code>size</code>依旧是0即可</li></ul></li><li>指定值（sp、dp）：直接给<code>子View</code>指定一个值，<code>ViewGroup</code>什么都不用做，直接将值下发给<code>子View</code>的可用空间，<code>mode</code>给<code>EXACTLY</code>即可</li></ul><p>布局过程基本结束，接下来是触摸反馈过程</p><p>#触摸反馈</p><blockquote><p>触摸反馈的本质就是把一系列的<code>触摸事件</code>解读为对应的操作，比如按下、弹起、滑动等等，开发者再根据解读出来的操作进行<code>反馈</code></p></blockquote><p>对于触摸事件，有两点需要注意</p><ul><li><code>触摸事件</code> 不相互独立，它们是成 <code>序列</code> （成组）出现的</li><li>每组事件由 <code>DOWN</code> 开头，由 <code>UP</code> 或 <code>CANCEL</code> 结尾</li></ul><p>大家都知道，自定义触摸反馈只需要重写<code>View</code>的<code>onTouchEvent(MotionEvent event)</code>方法，event中包含了此次触摸事件的<code>事件类型</code>、<code>坐标</code>等其他信息，当触摸事件不断被触发，<code>onTouchEvent()</code>就不断被调用，这是触摸反馈的<code>核心</code>。对于简单的 <strong>自定义触摸反馈</strong>，重写这个方法已经够了，但难免我们会遇上新的问题 —— 滑动冲突，只有当我们了解整个事件分发机制，才能够彻底解决滑动冲突。<br>在Android中，当一个触摸事件产生，<code>MotionEvent</code> 将从 <code>Activity（Window）</code>——&gt;<code>ViewGroup</code>（多个）——&gt; <code>View</code><br> <img src="https://upload-images.jianshu.io/upload_images/17794320-31aa080f30078289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>实际上学习Android的触摸事件分发机制就是学习以下3个组件的事件分发机制</p><ul><li><code>Activity</code>对触摸事件的分发机制</li><li><code>ViewGroup</code>对触摸事件的分发机制</li><li><code>View</code>对触摸事件的分发机制</li></ul><p>在Android的事件分发机制中，传递的核心方法有3个：</p><ul><li><code>dispatchTouchEvent()</code>：分发（传递）点击事件，当点击事件能够传递给当前View，该方法就会被调用</li><li><code>onInterceptTouchEvent()</code>：只存在于<code>ViewGroup</code>中，在<code>dispatchTouchEvent()</code>内部被调用，判断是否拦截了某个事件</li><li><code>onTouchEvent()</code>：处理点击事件，在<code>dispatchTouchEvent()</code>内部调用</li></ul><blockquote><p>这三个方法的解释不严谨，目的只是让大家现在有一个关系概念，而不是将每个细节都全理解，之后在源码中会有细节</p></blockquote><p>先上一个粗略的图，大概对事件分发流程有个印象，方便看源码的时候理解</p><p>##Activity的事件分发机制<br>当一个触摸事件发生时，事件最先传到 <code>Activity</code> 的 <code>dispatchTouchEvent()</code></p><pre><code class="hljs csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent ev</span>)</span> &#123;        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN)             onUserInteraction();        &#125;    <span class="hljs-comment">//获取Activity的window对象（实现类PhoneWindow）并调用其方法 `superDispatchTouchEvent()`</span>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    <span class="hljs-comment">//当未被处理，直接调用Activity的 `onTouchEvent()` 处理</span>        <span class="hljs-keyword">return</span> onTouchEvent(ev);    &#125;        <span class="hljs-comment">//空方法，当Activity在栈顶，触摸、按Home、back、menu都会触发该方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserInteraction</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;        <span class="hljs-comment">//Window</span>    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>) </span><span class="hljs-function">        <span class="hljs-comment">// mDecor = 顶层View（DecorView）的实例对象</span></span><span class="hljs-function">        <span class="hljs-comment">//DecorView是PhoneWindow的内部类，继承自FrameLayout，所以是一个ViewGroup</span></span><span class="hljs-function">        <span class="hljs-keyword">return</span> mDecor.<span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params"><span class="hljs-keyword">event</span></span>)</span>;    &#125;        <span class="hljs-comment">//DecorView</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;        <span class="hljs-comment">// 调用父类的方法 = ViewGroup的dispatchTouchEvent()</span>        <span class="hljs-comment">// 即 将事件传递到ViewGroup去处理，详细看ViewGroup的事件分发机制</span>        <span class="hljs-keyword">return</span> super.dispatchTouchEvent(<span class="hljs-keyword">event</span>);    &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;        <span class="hljs-comment">// 当一个点击事件未被Activity下任何一个View接收 / 处理时</span>        <span class="hljs-comment">// 应用场景：处理发生在Window边界外的触摸事</span>        <span class="hljs-keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;            finish();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//即只有在点击事件在Window边界外才会返回true，一般情况都返回false</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">shouldCloseOnTouch</span>(<span class="hljs-params">Context context, MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;    <span class="hljs-comment">// 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等</span>    <span class="hljs-keyword">if</span> (mCloseOnTouchOutside &amp;&amp; <span class="hljs-keyword">event</span>.getAction() == MotionEvent.ACTION_DOWN            &amp;&amp; isOutOfBounds(context, <span class="hljs-keyword">event</span>) &amp;&amp; peekDecorView() != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 返回true：说明事件在边界外，即 消费事件</span>    <span class="hljs-comment">// 返回false：未消费（默认）</span>&#125;</code></pre><blockquote><p>流程图 <img src="https://upload-images.jianshu.io/upload_images/17794320-73a1692c3d8e588a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity事件分发流程图"><br>红框中是重点！事件从这里下发到子View/View Group！<br>#ViewGroup事件的分发机制<br>Android 5.0后，ViewGroup.dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同；<br>为了便于理解，采用Android 5.0前的版本</p></blockquote><pre><code class="hljs aspectj">    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;     ... <span class="hljs-comment">// 仅贴出关键代码</span>        <span class="hljs-comment">// ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件</span>            <span class="hljs-keyword">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;              <span class="hljs-comment">// 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent（）修改</span>            <span class="hljs-comment">// 判断值2： !onInterceptTouchEvent(ev) = 对onInterceptTouchEvent()返回值取反</span>                    <span class="hljs-comment">// a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部</span>                    <span class="hljs-comment">// b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断</span>                    <span class="hljs-comment">// c. 关于onInterceptTouchEvent() -&gt;&gt;分析1</span>                ev.setAction(MotionEvent.ACTION_DOWN);                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrolledXInt = (<span class="hljs-keyword">int</span>) scrolledXFloat;                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrolledYInt = (<span class="hljs-keyword">int</span>) scrolledYFloat;                  <span class="hljs-keyword">final</span> View[] children = mChildren;                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mChildrenCount;              <span class="hljs-comment">// 通过for循环，遍历了当前ViewGroup下的所有子View</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                  <span class="hljs-keyword">final</span> View child = children[i];                  <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE                          || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//可见或正在执行动画 </span>                    child.getHitRect(frame);                      <span class="hljs-comment">// 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View</span>                    <span class="hljs-comment">// 若是，则进入条件判断内部</span>                    <span class="hljs-keyword">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> xc = scrolledXFloat - child.mLeft;                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> yc = scrolledYFloat - child.mTop;                          ev.setLocation(xc, yc);                          child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;                          <span class="hljs-comment">// 条件判断的内部调用了该View的dispatchTouchEvent()</span>                        <span class="hljs-comment">// 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制）</span>                        <span class="hljs-keyword">if</span> (child.dispatchTouchEvent(ev))  &#123;                         mMotionTarget = child;                          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                         <span class="hljs-comment">// 调用子View的dispatchTouchEvent后是有返回值的</span>                        <span class="hljs-comment">// 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立</span>                        <span class="hljs-comment">// 于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出</span>                        <span class="hljs-comment">// 即把ViewGroup的点击事件拦截掉</span>                                &#125;                              &#125;                          &#125;                      &#125;                  &#125;              &#125;              <span class="hljs-keyword">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||                      (action == MotionEvent.ACTION_CANCEL);              <span class="hljs-keyword">if</span> (isUpOrCancel) &#123;          <span class="hljs-comment">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false   </span>        <span class="hljs-comment">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true   </span>        <span class="hljs-comment">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false   </span>        <span class="hljs-comment">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false   </span>                mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;              &#125;              <span class="hljs-keyword">final</span> View <span class="hljs-keyword">target</span> = mMotionTarget;          <span class="hljs-comment">// 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true）</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == <span class="hljs-keyword">null</span>) &#123;              ev.setLocation(xf, yf);              <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="hljs-number">0</span>) &#123;                  ev.setAction(MotionEvent.ACTION_CANCEL);                  mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;              &#125;                          <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;            <span class="hljs-comment">// 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent()</span>            <span class="hljs-comment">// 因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（））</span>            <span class="hljs-comment">// 此处需与上面区别：子View的dispatchTouchEvent（）</span>        &#125;         ... &#125;  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;        <span class="hljs-comment">//返回true = 拦截，即事件停止往下传递（需手动设置，即复写onInterceptTouchEvent（），从而让其返回true）</span>      <span class="hljs-comment">//返回false = 不拦截（默认）</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;</code></pre><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-5e5ab9fbb8dbfc6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote><p>到这里为止，你会发现没有任何一个地方消费了（使用了）触摸事件，因为目前为止所有的过程都只是在下发（往下传递MotionEvent），而真正要处理事件，是等到View（真的View，不是ViewGroup）在 <code>dispatchTouchEvent()</code> 中去做操作，在这里才会 <strong>真正</strong> 让 <code>dispatchTouchEvent()</code>与 <code>onTouchEvent()</code> 产生交集，接着往下看<br>#View事件的分发机制</p><pre><code class="hljs csharp">  <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;    <span class="hljs-comment">// 只有以下3个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent()</span>  <span class="hljs-comment">//     1. mOnTouchListener != null</span>  <span class="hljs-comment">//     2. (mViewFlags &amp; ENABLED_MASK) == ENABLED</span>  <span class="hljs-comment">//     3. mOnTouchListener.onTouch(this, event)</span>        <span class="hljs-keyword">if</span> (mOnTouchListener != <span class="hljs-literal">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;                  mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;    <span class="hljs-comment">// 假如onTouch返回了true，直接返回True</span>onTouchEvent()处理            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          &#125;   <span class="hljs-comment">// 假如onTouch没返回true，交给此View的</span>        <span class="hljs-keyword">return</span> onTouchEvent(<span class="hljs-keyword">event</span>);    &#125;  <span class="hljs-comment">// 在这里为mOnTouchListener赋值</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOnTouchListener</span>(<span class="hljs-params">OnTouchListener l</span>)</span> &#123;     <span class="hljs-comment">// 即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空）</span>    mOnTouchListener = l;  &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 回调控件注册Touch事件时的onTouch（）；需手动复写设置，具体如下（以按钮Button为例）</span><span class="hljs-comment">  */</span>    button.setOnTouchListener(<span class="hljs-keyword">new</span> OnTouchListener() &#123;          @Override          <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouch</span>(<span class="hljs-params">View v, MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;          &#125;      &#125;);</code></pre><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-6e3cbb62240c4242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android环境下 MQTT+Protocol Buffers实现消息推送</title>
    <link href="/Blog/2020/11/19/Android%E7%8E%AF%E5%A2%83%E4%B8%8B-MQTT-Protocol-Buffers%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    <url>/Blog/2020/11/19/Android%E7%8E%AF%E5%A2%83%E4%B8%8B-MQTT-Protocol-Buffers%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Android环境下-MQTT-Protocol-Buffers实现消息推送"><a href="#Android环境下-MQTT-Protocol-Buffers实现消息推送" class="headerlink" title="Android环境下 MQTT+Protocol Buffers实现消息推送"></a>Android环境下 MQTT+Protocol Buffers实现消息推送</h1><pre><code>曾记否，大学初识Android时，做出一款聊天软件曾是多少少年的梦想。。。（好吧可能只是我的)emm… 怎么写？长连接，那就直接怼socket吧！于是闷起脑壳就开始写。服务端+客户端，一通操作猛如虎，并伴随着各种线程异常之后终于是肝出来一个聊天室，，，好像还阔以，但是随着少年长大，你渐渐明白服务的重要性，这样的连接你可能保持不了几个，想实现消息推送,MQTT了解一下？</code></pre><h2 id="MQTT-消息队列遥测传输"><a href="#MQTT-消息队列遥测传输" class="headerlink" title="MQTT(消息队列遥测传输)"></a>MQTT(<strong>消息队列遥测传输</strong>)</h2><blockquote><p>一个基于客户端-服务器的消息发布/订阅传输协议。优点：<code>轻量</code>、<code>简单</code>、<code>开放</code>、<code>易于实现</code>;由于其<code>低开销</code>、<code>低带宽占用</code>，所以在物联网、小型设备、移动应用等方面有广泛的应用<br>MQTT协议有三种身份： <code>发布者</code>、<code>代理</code>、<code>订阅者</code>，发布者和订阅者都为客户端，代理为服务器，同时消息的发布者也可以是订阅者<br>MQTT传输的消息分为主题（Topic，可理解为消息的类型，订阅者订阅后，就会收到该主题的消息内容<code>payload</code>。<br>运行流程:<img src="https://upload-images.jianshu.io/upload_images/17794320-daee414b823bba2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote><p>特点如下</p><blockquote><p>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序之间的耦合。</p><p>对负载内容屏蔽的消息传输。</p><p>使用 TCP/IP 提供基础网络连接。</p><p>小型传输，开销很小(固定长度的是头部是2个字节)，协议交换最小化，以降低网络流量<br>整体上协议可拆分为：固定头部+可变头部+消息体</p><p>提供一种机制，使得客户端异常中断时，能够使用LastWill和Testament特性通知有关各方<br>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。<br>Testament：遗嘱机制，功能类似于Last Will。</p><p>有三种级别消息发布服务质量：<br>qos为0：“至多一次”，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复，不久会发送第二次。<br>qos为1：“至少一次”，确保消息到达，但消息重复可能会发生。<br>qos为2：“只有一次”，确保消息到达一次。</p></blockquote><pre><code>有了`MQTT`代替`Socket`作为传输协议，但是数据结构呢？你也许会说`json`，但在通讯极其频繁的IM或者推送泛滥的场景中，`Protocol Buffers`更加适用（当然各有各的优缺点，比如`json`易读，`Protocol Buffers`**小**、**快**），当然使用它我们得有后端同学支持</code></pre><blockquote><p>有了协议，我们还需要一个服务来为我们提供消息的订阅发送，我使用的是<code>EMQ</code>，需要后端同学将自己的服务与<code>EMQ</code>服务接入进行通讯</p></blockquote><p>##EMQ</p><blockquote><p>EMQ X Broker 是基于高并发的 Erlang/OTP 语言平台开发，支持百万级连接和分布式集群架构，发布订阅模式的开源 MQTT 消息服务器。<br>EMQ X Broker 在全球物联网市场广泛应用。无论是产品原型设计、物联网创业公司、还是大规模的商业部署，EMQ X Broker 都支持开源免费使用。<br>详情：<a href="https://www.emqx.io/cn/">https://www.emqx.io/cn/</a></p></blockquote><p>##Protocol Buffer</p><blockquote><p><code>Protocol Buffers</code> 是<strong>Google</strong>推出的用于序列化结构化数据的灵活、高效、自动化的机制。它与 <code>XML</code>、<code>JSON</code>一样都是<code>结构数据序列化</code>的工具，但<code>ProtoBuffer</code>更小，更快，更简单。开发者需要定义一次构造数据的方式，然后就可以使用特定代码轻松地在各种语言的各种数据流中写入和读取数据。同样，使用它必须有后端同学的支持<br>详情：<a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p></blockquote><p>优点</p><ul><li>性能较xml,json, thirft等好，效率高<br>代码生成机制，数据解析类自动生成</li><li>支持向后兼容和向前兼容</li><li>支持多种编程语言（java，c++，python）</li></ul><p>缺点</p><ul><li><p>二进制格式导致可读性差</p></li><li><p>缺乏自描述</p><p>先上个 <code>Protocol Buffers</code> 与 <code>json</code> 的对比图</p></li></ul><pre><code class="hljs angelscript"><span class="hljs-comment">//json：</span>&#123;    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Fenrir&quot;</span>,    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age1&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age2&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age3&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age4&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age5&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age6&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age7&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age8&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age9&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age10&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age11&quot;</span>:<span class="hljs-number">6</span>&#125;<span class="hljs-comment">//Protocol Buffers:</span><span class="hljs-number">10</span> <span class="hljs-number">6</span> <span class="hljs-number">70</span> <span class="hljs-number">101</span> <span class="hljs-number">110</span> <span class="hljs-number">114</span> <span class="hljs-number">105</span> <span class="hljs-number">114</span> <span class="hljs-number">16</span> <span class="hljs-number">34</span> <span class="hljs-number">24</span> <span class="hljs-number">46</span> <span class="hljs-number">32</span> <span class="hljs-number">56</span> <span class="hljs-number">40</span> <span class="hljs-number">16</span> <span class="hljs-number">48</span> <span class="hljs-number">56</span> <span class="hljs-number">56</span> <span class="hljs-number">86</span> <span class="hljs-number">64</span> <span class="hljs-number">66</span> <span class="hljs-number">72</span> <span class="hljs-number">56</span> <span class="hljs-number">80</span> <span class="hljs-number">86</span> <span class="hljs-number">88</span> <span class="hljs-number">54</span> <span class="hljs-number">96</span> <span class="hljs-number">66</span> <span class="hljs-number">104</span> <span class="hljs-number">66</span><span class="hljs-comment">//或者将其Base64，变得下面这样</span>CgZGZW5yaXIQIhguIDgoEDA4OFZAQkg4UFZYNmBCaEI=</code></pre><p>QA：？？？</p><pre><code>`Protocol Buffers`将数据从对象转换成了一个`byte数组`。诚然，由于其可读性差，测试工作会变得困难;    但是使用`Protocol Buffers`不仅能降低数据传输代价，并且无论是在客户端还是服务端，对于数据的`序列化`与`反序列化`速度都将得到不小的提升；所以这并不应该成为使用它的障碍，在真正实装起来时就需要我们给QA们写一个序列化与反序列化的工具。</code></pre><p>##在Android使用Protocol Buffers<br>project gradle中</p><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;    <span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.google.protobuf:protobuf-gradle-plugin:0.8.8&#x27;</span>&#125;</code></pre><p>app gradle中</p><pre><code class="hljs properties"><span class="hljs-attr">apply</span> <span class="hljs-string">plugin: &#x27;com.google.protobuf&#x27; //应用proto插件</span>    <span class="hljs-attr">protobuf</span> <span class="hljs-string">&#123;</span>        <span class="hljs-attr">protoc</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">artifact</span> = <span class="hljs-string">&#x27;com.google.protobuf:protoc:3.0.0&#x27;</span>        <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">plugins</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">javalite</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">artifact</span> = <span class="hljs-string">&#x27;com.google.protobuf:protoc-gen-javalite:3.0.0&#x27;</span>            <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">generateProtoTasks</span> <span class="hljs-string">&#123;</span>            <span class="hljs-meta">all().each</span> <span class="hljs-string">&#123; task -&gt;</span>                <span class="hljs-meta">task.builtins</span> <span class="hljs-string">&#123;</span>                    <span class="hljs-attr">remove</span> <span class="hljs-string">java</span>                <span class="hljs-attr">&#125;</span>                <span class="hljs-meta">task.builtins</span> <span class="hljs-string">&#123;</span>                    <span class="hljs-attr">java</span> <span class="hljs-string">&#123;&#125;</span>                    <span class="hljs-attr">cpp</span> <span class="hljs-string">&#123;&#125;</span>                <span class="hljs-attr">&#125;</span>            <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">sourceSets</span> <span class="hljs-string">&#123;</span>        <span class="hljs-attr">main</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">java</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">srcDir</span> <span class="hljs-string">&#x27;src/main/java&#x27;</span>            <span class="hljs-attr">&#125;</span>            <span class="hljs-attr">proto</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">srcDir</span> <span class="hljs-string">&#x27;src/main/proto&#x27; //配置proto文件路径</span>            <span class="hljs-attr">&#125;</span>            <span class="hljs-meta">jniLibs.srcDir</span> <span class="hljs-string">&#x27;libs&#x27;</span>            <span class="hljs-meta">jni.srcDirs</span> = <span class="hljs-string">[]    //disable automatic ndk-build</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;</span><span class="hljs-attr">dependencies</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attr">api</span> <span class="hljs-string">&#x27;com.google.protobuf:protobuf-java:3.6.1&#x27;</span>    <span class="hljs-attr">api</span> <span class="hljs-string">&#x27;com.google.protobuf:protoc:3.10.1&#x27;</span>    <span class="hljs-attr">implementation</span> <span class="hljs-string">&#x27;com.squareup.retrofit2:converter-protobuf:2.2.0&#x27;</span><span class="hljs-attr">&#125;</span></code></pre><blockquote><p>这里以构建一个无限发送心跳包的程序为例，这里实现心跳包的目的如下</p></blockquote><ul><li>为服务端提供信息用于判断用户是否下线</li><li>确保与服务端建立的topic的唯一性</li><li>顺便增加一下Android服务的优先级</li></ul><p>使用ProtocolBuffers前需要先编辑<code>.proto</code>文件，语法过多就不写在这里了，请移步至<a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a><br>在src/main下创建文件夹proto并在其目录下创建文件 MqttHeartBeatMessage.proto</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">//protoBuf版本</span><span class="hljs-keyword">package</span> rubbishcommunity; <span class="hljs-comment">//包</span><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.example.xxxxxxx&quot;</span>; <span class="hljs-comment">//包名</span><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;MqttHeartBeatMessageOutClass&quot;</span>; <span class="hljs-comment">//生成的Java Class文件类名</span><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MqttHeartBeatMessage</span></span>&#123;    <span class="hljs-built_in">int64</span> uin = <span class="hljs-number">1</span>;    <span class="hljs-built_in">string</span> linkKey = <span class="hljs-number">2</span>;    <span class="hljs-built_in">int64</span> timestamp = <span class="hljs-number">3</span>;&#125;</code></pre><p><code>.proto</code>文件编辑完成之后 Rebuild 编译一下项目,可以发现在java(generated)下面已经生成了proto编译成的java文件<code>MqttHeartBeatMessageOutClass.java</code>，里面包含了<code>MqttHeartBeatMessage.java</code>并实现了<code>get</code>、<code>set</code>方法；</p><ul><li>到此，Proto部分算是完成了，接下来我们需要使用<code>MQTTService</code>实现无限发送心跳包,但在这之前，你要先了解下面两位</li></ul><p>##Eclipse Paho</p><blockquote><p>Eclipse提供的一个访问MQTT服务器的一种开源客户端库<br><a href="https://www.eclipse.org/paho/clients/android/">https://www.eclipse.org/paho/clients/android/</a></p></blockquote><p>##MqttAndroidClient</p><blockquote><p>简单的说就是对MQTTService的连接、通讯等方法的封装类<br>[<a href="https://www.eclipse.org/paho/files/android-javadoc/org/eclipse/paho/android/service/MqttAndroidClient.html]">https://www.eclipse.org/paho/files/android-javadoc/org/eclipse/paho/android/service/MqttAndroidClient.html]</a></p></blockquote><ul><li>引入MQTT的Service以及对Android相关资源</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">implementation</span> &#x27;org.eclipse.paho:org.eclipse.paho.client.mqttv<span class="hljs-number">3</span>:<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>&#x27;<span class="hljs-attribute">implementation</span> &#x27;org.eclipse.paho:org.eclipse.paho.android.service:<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>&#x27;</code></pre><ul><li>Manifests中注册<code>MqttService</code>的Service</li></ul><pre><code class="hljs routeros">&lt;service android:<span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;org.eclipse.paho.android.service.MqttService&quot;</span>/&gt;</code></pre><ul><li>在项目中使用<code>MqttAndroidClient</code>进行MQTT连接与通讯<br>理论上应该将<code>MqttAndroidClient</code>的生命周期与<code>Application</code>绑定在一起，在我的毕设项目中我是再写了一个<code>Service</code>，在我的<code>MainActivity</code>打开之后开启，并在Service中轮询发送心跳包；</li></ul><p>初始化代码：</p><pre><code class="hljs kotlin"><span class="hljs-comment">//新建Client,以设备ID作为client ID</span>mqttAndroidClient = MqttAndroidClient(context,MQTT_URL, <span class="hljs-comment">//MQTT服务地址</span>CLIRNT_ID <span class="hljs-comment">//MQTT连接在代理服务处的clientId，一般由后端同学定义</span>)mqttAndroidClient?.setCallback(<span class="hljs-keyword">object</span> : MqttCallbackExtended &#123;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectComplete</span><span class="hljs-params">(reconnect: <span class="hljs-type">Boolean</span>, serverURI: <span class="hljs-type">String</span>)</span></span> &#123;<span class="hljs-comment">//连接成功</span><span class="hljs-keyword">if</span> (reconnect) &#123;<span class="hljs-comment">// 由于clean Session ，我们需要重新订阅</span><span class="hljs-keyword">try</span> &#123;subscribeToTopic()&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    ex.printStackTrace()&#125;&#125;&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectionLost</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>)</span></span> &#123;<span class="hljs-comment">//连接断开</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">messageArrived</span><span class="hljs-params">(topic: <span class="hljs-type">String</span>, message: <span class="hljs-type">MqttMessage</span>)</span></span> &#123;              <span class="hljs-comment">//接收到订阅的消息</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deliveryComplete</span><span class="hljs-params">(token: <span class="hljs-type">IMqttDeliveryToken</span>)</span></span> &#123;<span class="hljs-comment">//服务器成功delivery消息</span>&#125;&#125;)<span class="hljs-comment">//新建连接设置</span><span class="hljs-keyword">val</span> mqttConnectOptions = MqttConnectOptions()<span class="hljs-comment">//断开后，是否自动连接</span>mqttConnectOptions.isAutomaticReconnect = <span class="hljs-literal">true</span><span class="hljs-comment">//是否清空客户端的连接记录。若为true，则断开后，broker将自动清除该客户端连接信息</span>mqttConnectOptions.isCleanSession = <span class="hljs-literal">true</span><span class="hljs-comment">//设置Mq连接的userName</span>mqttConnectOptions.userName = getLocalEmail()<span class="hljs-comment">//设置超时时间，单位为秒</span><span class="hljs-comment">//mqttConnectOptions.setConnectionTimeout(2);</span><span class="hljs-comment">//心跳时间，单位为秒。即多长时间确认一次Client端是否在线（此心跳时间非刚才说的心跳时间，这个是MqttService内部的心跳）</span>mqttConnectOptions.keepAliveInterval = <span class="hljs-number">2</span><span class="hljs-comment">//允许同时发送几条消息（未收到broker确认信息）</span>mqttConnectOptions.maxInflight = <span class="hljs-number">2</span><span class="hljs-comment">//选择MQTT版本</span>mqttConnectOptions.mqttVersion = MqttConnectOptions.MQTT_VERSION_3_1_1<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//开始连接</span>mqttAndroidClient?.connect(mqttConnectOptions, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">object</span> : IMqttActionListener &#123;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(asyncActionToken: <span class="hljs-type">IMqttToken</span>)</span></span> &#123;<span class="hljs-keyword">val</span> disconnectedBufferOptions = DisconnectedBufferOptions()disconnectedBufferOptions.isBufferEnabled = <span class="hljs-literal">true</span>disconnectedBufferOptions.bufferSize = <span class="hljs-number">100</span>disconnectedBufferOptions.isPersistBuffer = <span class="hljs-literal">false</span>disconnectedBufferOptions.isDeleteOldestMessages = <span class="hljs-literal">true</span>mqttAndroidClient!!.setBufferOpts(disconnectedBufferOptions)subscribeToTopic()<span class="hljs-comment">//成功连接以后开始订阅</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(asyncActionToken: <span class="hljs-type">IMqttToken</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;<span class="hljs-comment">//连接失败</span>exception.printStackTrace()&#125;&#125;)&#125; <span class="hljs-keyword">catch</span> (ex: MqttException) &#123;ex.printStackTrace()&#125;</code></pre><p>轮询发送心跳包</p><pre><code class="hljs awk">Observable.interval(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS).doOnNext &#123;mqService <span class="hljs-regexp">//</span>这是我的服务，没有的话直接使用MqAndroidClient就好.publishMessage(Base64.encodeToString(<span class="hljs-regexp">//</span>下面就是构造proto生成的Class的对象了MqttHeartBeatMessageOutClass.MqttHeartBeatMessage.newBuilder().setLinkKey(getLinkKey()) <span class="hljs-regexp">//</span>proto中自定义的属性.setUin(getLocalUin()) <span class="hljs-regexp">//</span>proto中自定义的属性.setTimestamp(System.currentTimeMillis()) <span class="hljs-regexp">//</span>proto中自定义的属性.build() <span class="hljs-regexp">//</span>构造结束                              .toByteArray(),NO_WRAP),DEW_MQTT_HEART_BEAT_TOPIC <span class="hljs-regexp">//</span>心跳包的TOPIC)&#125;.subscribe()</code></pre><p>至此，心跳包发送已经完成了，接下来说说接收<code>Protocol Buffer</code>数据</p><p>在上面代码中应该看见了，在<code>MqttAndroidClient</code>接收的数据在<code>messageArrived(topic: String, message: MqttMessage)</code>方法中，实际上这里并非所有的消息都会是<code>protocol Buffers</code>消息，所以这里我们可以想办法区分，这里就不累述了。要说的是<code>Protocol Buffer</code>的消息在内部也是需要区分的，比如有两种消息过来1⃣️我的朋友圈有人点赞我需要知道是谁点赞2⃣️有人给我发消息我需要知道是什么消息，而这两种消息内部返回的数据结构可能就完全不一样，所以需要用到<code>Protocol Buffers</code>的enum进行区分，那么我们与后端同学一起定义一种<code>协议</code>,也就是接收的<code>ProtocolBuffers</code>消息的数据结构，像下面这样：</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<span class="hljs-keyword">package</span> rubbishcommunity;<span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.example.rubbishcommunity&quot;</span>;<span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;NotifyMessageOutClass&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NotifyType</span></span>&#123;    ERROR_DEFAULT_TYPE = <span class="hljs-number">0</span>; <span class="hljs-comment">//默认</span>    SYNC_NEW_MESSAGE = <span class="hljs-number">1</span>; <span class="hljs-comment">//新消息</span>    SYNC_MOMENTS_COMMENT = <span class="hljs-number">2</span>; <span class="hljs-comment">//有人点赞</span>&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">NotifyMessage</span></span>&#123;    Header header = <span class="hljs-number">1</span>; <span class="hljs-comment">//数据头</span>    <span class="hljs-built_in">string</span> payload = <span class="hljs-number">2</span>; <span class="hljs-comment">//真实数据（虽然是String，实际是后端将Protocol Buffers数据Base64之后的String）</span>&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Header</span></span>&#123;    NotifyType notifyType = <span class="hljs-number">1</span>; <span class="hljs-comment">//消息类型</span>    <span class="hljs-built_in">int64</span> timestamp = <span class="hljs-number">2</span>; <span class="hljs-comment">//时间戳</span>    <span class="hljs-built_in">string</span> notifyUUID = <span class="hljs-number">3</span>; <span class="hljs-comment">//消息UUID</span>&#125;</code></pre><p>之后我们就可以愉快地解析数据啦！举个栗子</p><p>MqttAndroidClient初始化的地方：</p><pre><code class="hljs reasonml">             <span class="hljs-comment">//订阅的消息送达</span>override <span class="hljs-keyword">fun</span> message<span class="hljs-constructor">Arrived(<span class="hljs-params">topic</span>: String, <span class="hljs-params">message</span>: MqttMessage)</span> &#123;<span class="hljs-comment">//先用Base64解码</span><span class="hljs-keyword">val</span> resBytes = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Base64</span>.</span></span>decode(message.payload, Base64.NO_WRAP)<span class="hljs-comment">//得到最外层的NotifyMessage对象</span><span class="hljs-keyword">val</span> notifyMessage = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NotifyMessageOutClass</span>.</span><span class="hljs-module"><span class="hljs-identifier">NotifyMessage</span>.</span></span>parse<span class="hljs-constructor">From(<span class="hljs-params">resBytes</span>)</span><span class="hljs-comment">//发送MQ事件，目前在BasegFragment中有处理事件的方法</span>send<span class="hljs-constructor">MQData(MQNotifyData(<span class="hljs-params">notifyMessage</span>.<span class="hljs-params">header</span>.<span class="hljs-params">notifyType</span>,<span class="hljs-params">notifyMessage</span>.<span class="hljs-params">payload</span>)</span>)&#125;</code></pre><p>BaseFragment中：</p><pre><code class="hljs reasonml"><span class="hljs-comment">//实际&#x27;MQ消息&#x27;处理者</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handle<span class="hljs-constructor">MQNotifyMessage()</span> &#123;notifyDisposable = get<span class="hljs-constructor">MQNotifyObs()</span>.observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>).doOnNext &#123;on<span class="hljs-constructor">MQMessageArrived(<span class="hljs-params">it</span>)</span>&#125;.subscribe(&#123;&#125;, &#123; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Timber</span>.</span></span>e(it) &#125;)&#125;</code></pre><p>实现的Fragment中：</p><pre><code class="hljs kotlin"><span class="hljs-comment">//有MQ消息</span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMQMessageArrived</span><span class="hljs-params">(mqNotifyData: <span class="hljs-type">MQNotifyData</span>)</span></span> &#123;<span class="hljs-keyword">when</span> (mqNotifyData.mqNotifyType) &#123;NotifyMessageOutClass.NotifyType.SYNC_MOMENTS_FAVORITE -&gt; &#123; <span class="hljs-comment">//有人点赞</span><span class="hljs-comment">//弹个通知并更新列表对应Item</span>&#125;<span class="hljs-keyword">else</span> -&gt; &#123;&#125;&#125;&#125;</code></pre><p>将得到的数据包装成自定义的一个<code>MQNotifyData</code>数据类，数据类中有<code>header</code>和<code>payload</code>，再通过<code>sendMQData()</code>发送到<code>Fragment</code>或者<code>Activity</code>中去，我是在<code>Fragment</code>中一直有一个mq消息的<code>Subject</code>流，当<code>sendMQData()</code>就触发<code>onNext()</code>，其中调用<code>BaseFragment</code>的方法，具体实现在具体需要MQ消息的<code>Fragment</code>中。这是我的方法而已，就是将数据通知到界面，如何实现随意，欢迎大佬来指正～</p><p>MQ中的<code>ProtocolBuffers</code>完成了，还有最后一步就是为我们的正常Http请求的数据也添加支持，啊好像写不完了，各位看官～下次补上吧～！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>中间凹陷的BottomNavigationView（仿百度地图）</title>
    <link href="/Blog/2020/11/19/%E4%B8%AD%E9%97%B4%E5%87%B9%E9%99%B7%E7%9A%84BottomNavigationView%EF%BC%88%E4%BB%BF%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%EF%BC%89/"/>
    <url>/Blog/2020/11/19/%E4%B8%AD%E9%97%B4%E5%87%B9%E9%99%B7%E7%9A%84BottomNavigationView%EF%BC%88%E4%BB%BF%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>##GapBottomNavigtionView</p><p>百度的：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-2ab547998387f2ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="71529789c6c948803e1075c2c7e00809.jpg"><br>我的：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-faea132de3d4305f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e9347423eb2031228af77ad63d7b01d7.jpg"></p><blockquote><p>项目地址：<a href="https://github.com/ZYF99/UIKit/tree/1.3">https://github.com/ZYF99/UIKit/tree/1.3</a></p></blockquote><p>###使用方式</p><p>在app的build.gradle中</p><pre><code class="hljs gradle"><span class="hljs-keyword">allprojects</span> &#123;<span class="hljs-keyword">repositories</span> &#123;...maven &#123; url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span> &#125;&#125;&#125;<span class="hljs-keyword">dependencies</span> &#123;        implementation <span class="hljs-string">&#x27;com.github.ZYF99:UIKit:1.3&#x27;</span>&#125;</code></pre><p>在布局文件中直接使用</p><pre><code class="hljs routeros">&lt;com.google.android.material.floatingactionbutton.FloatingActionButton    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/fab_add&quot;</span>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;30dp&quot;</span>    android:<span class="hljs-attribute">backgroundTint</span>=<span class="hljs-string">&quot;#ffffff&quot;</span>    android:<span class="hljs-attribute">elevation</span>=<span class="hljs-string">&quot;6dp&quot;</span>    android:<span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;@android:drawable/ic_input_add&quot;</span>    android:<span class="hljs-attribute">tint</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">borderWidth</span>=<span class="hljs-string">&quot;0dp&quot;</span>    app:<span class="hljs-attribute">fabSize</span>=<span class="hljs-string">&quot;normal&quot;</span>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">rippleColor</span>=<span class="hljs-string">&quot;#00FFFFFF&quot;</span>/&gt;&lt;com.zhangyf.gapbottomnavigationview.GapBottomNavigationView    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_marginStart</span>=<span class="hljs-string">&quot;32dp&quot;</span>    android:<span class="hljs-attribute">layout_marginEnd</span>=<span class="hljs-string">&quot;32dp&quot;</span>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;16dp&quot;</span>    android:<span class="hljs-attribute">backgroundTint</span>=<span class="hljs-string">&quot;#ffffff&quot;</span>    android:<span class="hljs-attribute">clickable</span>=<span class="hljs-string">&quot;false&quot;</span>    android:<span class="hljs-attribute">padding</span>=<span class="hljs-string">&quot;8dp&quot;</span>    app:<span class="hljs-attribute">center_radius</span>=<span class="hljs-string">&quot;32dp&quot;</span>    app:<span class="hljs-attribute">corner_radius</span>=<span class="hljs-string">&quot;12dp&quot;</span>    app:<span class="hljs-attribute">elevation</span>=<span class="hljs-string">&quot;5dp&quot;</span>    app:<span class="hljs-attribute">itemBackground</span>=<span class="hljs-string">&quot;@null&quot;</span>    app:<span class="hljs-attribute">itemIconTint</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">itemTextColor</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">labelVisibilityMode</span>=<span class="hljs-string">&quot;labeled&quot;</span>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">menu</span>=<span class="hljs-string">&quot;@menu/navigation&quot;</span>    app:<span class="hljs-attribute">shadow_length</span>=<span class="hljs-string">&quot;4dp&quot;</span>    tools:<span class="hljs-attribute">targetApi</span>=<span class="hljs-string">&quot;lollipop&quot;</span> /&gt;</code></pre><blockquote><p>anchor_fab： 用来指定凹陷下去的 View ，一般都为 FloatingActionButton<br>shadow_length：用来指定高度（阴影大小）<br>cornerRadius：用来指定拐角处的平滑半径大小</p></blockquote><p>##源码<br>attrs中的3个属性</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;GapBottomNavigationView&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;shadow_length&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;corner_radius&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center_radius&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><p>#####导入源码（请直接copy）</p><blockquote><p>源码采用Kotlin，有需要可以直接转为Java，转换方法自行百度</p></blockquote><pre><code class="hljs roboconf">package com.zhangyf.gapbottomnavigationview<span class="hljs-keyword">import</span> android.annotation.SuppressLint<span class="hljs-keyword">import</span> android.content.Context<span class="hljs-keyword">import</span> android.graphics.*<span class="hljs-keyword">import</span> android.graphics.drawable.GradientDrawable<span class="hljs-keyword">import</span> android.os.Build<span class="hljs-keyword">import</span> android.util.AttributeSet<span class="hljs-keyword">import</span> android.util.Log<span class="hljs-keyword">import</span> androidx.annotation.*<span class="hljs-keyword">import</span> com.google.android.material.bottomnavigation.BottomNavigationViewclass GapBottomNavigationView : BottomNavigationView &#123;    <span class="hljs-attribute">private var fabId = 0 //凹陷View的id</span><span class="hljs-attribute">    private var centerRadius</span>: Float = 0<span class="hljs-variable">.toFloat</span>() //中间凹陷的半径    private var cornerRadius = 12f //拐角处的圆滑大小（越大越平滑）    private var shadowLength = 6f //阴影大小    constructor(context: Context) : super(context)    constructor(context: Context, attrs: AttributeSet) : this(context, attrs, 0)    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(        context,        attrs,        defStyleAttr    ) &#123;        background = GradientDrawable()<span class="hljs-variable">.apply</span> &#123; setColor(Color<span class="hljs-variable">.TRANSPARENT</span>) &#125;        val ta = context<span class="hljs-variable">.obtainStyledAttributes</span>(attrs, R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView</span>)        centerRadius = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_center_radius</span>, 0<span class="hljs-variable">.toFloat</span>())        shadowLength = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_shadow_length</span>, 6<span class="hljs-variable">.toFloat</span>())        cornerRadius = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_corner_radius</span>, 12<span class="hljs-variable">.toFloat</span>())        ta<span class="hljs-variable">.recycle</span>()    &#125;    @SuppressLint(&quot;DrawAllocation&quot;)    @RequiresApi(api = Build<span class="hljs-variable">.VERSION_CODES</span><span class="hljs-variable">.KITKAT</span>)    override fun onDraw(canvas: Canvas) &#123;        super<span class="hljs-variable">.onDraw</span>(canvas)        val paint = Paint()        val path = Path()        //左边的半圆        val rectL = RectF(            shadowLength,            shadowLength,            height<span class="hljs-variable">.toFloat</span>() + shadowLength,            height<span class="hljs-variable">.toFloat</span>() - shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectL, 90<span class="hljs-variable">.toFloat</span>(), 180<span class="hljs-variable">.toFloat</span>(), false)        path<span class="hljs-variable">.lineTo</span>(width / 2 - centerRadius - cornerRadius, shadowLength)        //左边转角处        path<span class="hljs-variable">.quadTo</span>(            width / 2 - centerRadius,            shadowLength,            width / 2 - centerRadius,            cornerRadius + shadowLength        )        //中间凹陷的半圆        val rectCenter = RectF(            width / 2 - centerRadius,            cornerRadius + shadowLength - centerRadius,            width / 2 + centerRadius,            cornerRadius + centerRadius + shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectCenter, 180<span class="hljs-variable">.toFloat</span>(), (-180)<span class="hljs-variable">.toFloat</span>(), false)        //利用贝塞尔曲线画中间凹陷（非半圆）/*path<span class="hljs-variable">.quadTo</span>(width<span class="hljs-variable">.toFloat</span>() / 2,centerRadius<span class="hljs-variable">.toFloat</span>(),width / 2 + centerRadius - cornerRadius - cornerRadius / sqrt(2<span class="hljs-variable">.toFloat</span>()),cornerRadius / sqrt(2<span class="hljs-variable">.toFloat</span>()))*/        //右边转角处        path<span class="hljs-variable">.quadTo</span>(            width / 2 + centerRadius,            shadowLength,            width / 2 + centerRadius + cornerRadius,            shadowLength        )        path<span class="hljs-variable">.lineTo</span>((width - shadowLength - height / 2), shadowLength)        //右边的半圆        val rectR = RectF(            width<span class="hljs-variable">.toFloat</span>() - shadowLength - height,            shadowLength,            width<span class="hljs-variable">.toFloat</span>() - shadowLength,            height<span class="hljs-variable">.toFloat</span>() - shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectR, 270<span class="hljs-variable">.toFloat</span>(), 180<span class="hljs-variable">.toFloat</span>(), false)        //最后的直线        path<span class="hljs-variable">.moveTo</span>((width - shadowLength - height / 2), height<span class="hljs-variable">.toFloat</span>() - shadowLength)        path<span class="hljs-variable">.lineTo</span>(height / 2<span class="hljs-variable">.toFloat</span>() + shadowLength, height<span class="hljs-variable">.toFloat</span>() - shadowLength)        path<span class="hljs-variable">.close</span>()        Log<span class="hljs-variable">.d</span>(&quot;!!!&quot;, &quot;!!!!!!!!!!!!&quot;)        //按背景色填充背景        paint<span class="hljs-variable">.apply</span> &#123;            style = Paint<span class="hljs-variable">.Style</span><span class="hljs-variable">.FILL</span>            if (Build<span class="hljs-variable">.VERSION</span><span class="hljs-variable">.SDK_INT</span> &gt;= Build<span class="hljs-variable">.VERSION_CODES</span><span class="hljs-variable">.LOLLIPOP</span>) &#123;                color = backgroundTintList?<span class="hljs-variable">.defaultColor</span> ?: Color<span class="hljs-variable">.BLACK</span>            &#125;            maskFilter = null            isAntiAlias = true            //添加阴影            setShadowLayer(shadowLength, 0<span class="hljs-variable">.toFloat</span>(), 0<span class="hljs-variable">.toFloat</span>(), Color<span class="hljs-variable">.LTGRAY</span>)        &#125;        canvas<span class="hljs-variable">.drawPath</span>(path, paint)    &#125;&#125;</code></pre><blockquote><p>建议：结合我的代码并利用 paint（画笔） 随意更改为你想要的形状</p></blockquote><p>我的效果就是这样咯<br><img src="https://upload-images.jianshu.io/upload_images/17794320-fc974949ebf9b9ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="093143d5ebb666338bc164a6bd339da5.jpg"></p><p>喜欢不要忘了点赞关注或者去github点个星星哦～～</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
