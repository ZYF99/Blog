<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于虹软人脸识别的Rx封装，3分钟开发人脸识别APP</title>
    <link href="/Blog/2020/12/07/%E5%9F%BA%E4%BA%8E%E8%99%B9%E8%BD%AF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%9A%84Rx%E5%B0%81%E8%A3%85%EF%BC%8C3%E5%88%86%E9%92%9F%E5%BC%80%E5%8F%91%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABAPP/"/>
    <url>/Blog/2020/12/07/%E5%9F%BA%E4%BA%8E%E8%99%B9%E8%BD%AF%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%9A%84Rx%E5%B0%81%E8%A3%85%EF%BC%8C3%E5%88%86%E9%92%9F%E5%BC%80%E5%8F%91%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABAPP/</url>
    
    <content type="html"><![CDATA[<h1 id="基于虹软人脸识别SDK的Rx封装，3分钟开发人脸识别APP"><a href="#基于虹软人脸识别SDK的Rx封装，3分钟开发人脸识别APP" class="headerlink" title="基于虹软人脸识别SDK的Rx封装，3分钟开发人脸识别APP"></a>基于虹软人脸识别SDK的Rx封装，3分钟开发人脸识别APP</h1><blockquote><p>本文由 <a href="https://zyf99.github.io/Blog/">ZEKI安卓学弟</a> 写作</p><p>原作者：<code>ZEKI安卓学弟</code></p><p>版权声明：本文版权归 <code>ZEKI安卓学弟</code> 所有，未经许可，不得以任何形式转载</p></blockquote><h1 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h1><p>虹软人脸人脸识别SDK：ArcFace 离线SDK，包含人脸检测、性别检测、年龄检测、人脸识别、图像质量检测、RGB活体检测、IR活体检测等能力，初次使用时需联网激活，激活后即可在本地无网络环境下工作，可根据具体的业务需求结合人脸识别SDK灵活地进行应用层开发。</p><blockquote><p>基础版本暂不支持<code>图像质量检测</code>以及<code>离线激活</code>；</p></blockquote><p><img src="C:\Users\Zhangyf\AppData\Roaming\Typora\typora-user-images\image-20201207174931350.png" alt="image-20201207174931350"></p><h1 id="0-引子"><a href="#0-引子" class="headerlink" title="0. 引子"></a>0. 引子</h1><p>人脸识别在当今已不是稀奇的功能，许多业务场景都能看到人脸识别的影子。作为移动应用开发者，选择接入合适的SDK能为我们带来更高效的开发体验；本文首先将以虹软人脸识别SDK基础方法为切入点逐渐探讨，但官方SDK未免过于繁琐，所以文章带领读者将其封装，基于官方方法打造自己的高可用，多场景可用的Util，使人脸开发无需繁琐的过程即可轻松接入。</p><blockquote><p>SDK准备工作请参考<br><a href="https://ai.arcsoft.com.cn/manual/docs#/139">https://ai.arcsoft.com.cn/manual/docs#/139</a><br><a href="https://ai.arcsoft.com.cn/manual/docs#/140">https://ai.arcsoft.com.cn/manual/docs#/140</a>  <strong>只需看3.1</strong><br>本文将不再累述</p></blockquote><h1 id="1-方法介绍（摘自-虹软安卓接入详情）"><a href="#1-方法介绍（摘自-虹软安卓接入详情）" class="headerlink" title="1. 方法介绍（摘自 虹软安卓接入详情）"></a>1. 方法介绍（摘自 <a href="https://ai.arcsoft.com.cn/manual/docs#/140">虹软安卓接入详情</a>）</h1><h2 id="1-activeOnline"><a href="#1-activeOnline" class="headerlink" title="1.activeOnline"></a>1.activeOnline</h2><p><strong>功能描述</strong></p><p>用于在线激活SDK。</p><p><strong>方法</strong></p><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> active<span class="hljs-constructor">Online(Context <span class="hljs-params">context</span>,  String <span class="hljs-params">appId</span>, String <span class="hljs-params">sdkKey</span>)</span></code></pre><blockquote><p>初次使用SDK时需要对SDK先进行激活，激活后无需重复调用；<br>调用此接口时必须为联网状态，激活成功后即可离线使用；</p></blockquote><p><strong>参数说明</strong></p><table><thead><tr><th>参数</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td>context</td><td align="center">in</td><td>上下文信息</td></tr><tr><td>appId</td><td align="center">in</td><td>官网获取的APP_ID</td></tr><tr><td>sdkKey</td><td align="center">in</td><td>官网获取的SDK_KEY</td></tr></tbody></table><p><strong>返回值</strong></p><p>成功返回<code>ErrorInfo.MOK</code>、<code>ErrorInfo.MERR_ASF_ALREADY_ACTIVATED</code>，失败详见 <a href="https://ai.arcsoft.com.cn/manual/docs#/141#42__19">错误码列表</a>。</p><h2 id="2-init"><a href="#2-init" class="headerlink" title="2.init"></a>2.init</h2><p><strong>功能描述</strong></p><p>初始化引擎。</p><blockquote><p>该接口至关重要，清楚的了解该接口参数的意义，可以避免一些问题以及对项目的设计都有一定的帮助。</p></blockquote><p><strong>方法</strong></p><pre><code class="hljs properties"><span class="hljs-attr">int</span> <span class="hljs-string">init(</span>    <span class="hljs-attr">Context</span> <span class="hljs-string">context,</span>    <span class="hljs-attr">DetectMode</span> <span class="hljs-string">detectMode,</span>    <span class="hljs-attr">DetectFaceOrientPriority</span> <span class="hljs-string">detectFaceOrientPriority,</span>    <span class="hljs-attr">int</span> <span class="hljs-string">detectFaceScaleVal,</span>    <span class="hljs-attr">int</span> <span class="hljs-string">detectFaceMaxNum,</span>    <span class="hljs-attr">int</span> <span class="hljs-string">combinedMask</span><span class="hljs-attr">)</span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th>参数</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td>context</td><td align="center">in</td><td>上下文信息</td></tr><tr><td>detectMode</td><td align="center">in</td><td>VIDEO模式：处理连续帧的图像数据 IMAGE模式：处理单张的图像数据</td></tr><tr><td>detectFaceOrientPriority</td><td align="center">in</td><td>人脸检测角度，推荐单一角度检测；</td></tr><tr><td>detectFaceScaleVal</td><td align="center">in</td><td>识别的最小人脸比例（图片长边与人脸框长边的比值） VIDEO模式取值范围[2,32]，推荐值为16 IMAGE模式取值范围[2,32]，推荐值为32</td></tr><tr><td>detectFaceMaxNum</td><td align="center">in</td><td>最大需要检测的人脸个数，取值范围[1,50]</td></tr><tr><td>combinedMask</td><td align="center">in</td><td>需要启用的功能组合，可多选</td></tr></tbody></table><h2 id="3-detectFaces（传入分离的图像信息数据）"><a href="#3-detectFaces（传入分离的图像信息数据）" class="headerlink" title="3.detectFaces（传入分离的图像信息数据）"></a>3.detectFaces（传入分离的图像信息数据）</h2><p><strong>方法</strong></p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">detectFaces</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">byte</span>[] data,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span>,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> format,</span></span><span class="hljs-function"><span class="hljs-params">    List&lt;FaceInfo&gt; faceInfoList</span></span><span class="hljs-function"><span class="hljs-params">)</span></span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th>参数</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td align="center">in</td><td>图像数据</td></tr><tr><td>width</td><td align="center">in</td><td>图像宽度，为4的倍数</td></tr><tr><td>height</td><td align="center">in</td><td>图像高度，在NV21格式下要求为2的倍数； BGR24/GRAY/DEPTH_U16格式无限制；</td></tr><tr><td>format</td><td align="center">in</td><td>图像的颜色格式</td></tr><tr><td>faceInfoList</td><td align="center">out</td><td>检测到的人脸信息</td></tr></tbody></table><p><strong>返回值</strong></p><p>成功返回<code>ErrorInfo.MOK</code>，失败详见 <a href="https://ai.arcsoft.com.cn/manual/docs#/141#42__19">错误码列表</a>。</p><blockquote><p><code>detectFaceMaxNum</code> 参数的设置，对能否检测到人脸以及检测到几张人脸都有决定性的作用。</p></blockquote><h2 id="4-process（传入分离的图像信息数据）"><a href="#4-process（传入分离的图像信息数据）" class="headerlink" title="4.process（传入分离的图像信息数据）"></a>4.process（传入分离的图像信息数据）</h2><p><strong>方法</strong></p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">byte</span>[] data,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span>,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> format,</span></span><span class="hljs-function"><span class="hljs-params">    List&lt;FaceInfo&gt; faceInfoList,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> combinedMask</span></span><span class="hljs-function"><span class="hljs-params">)</span></span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th>参数</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td align="center">in</td><td>图像数据</td></tr><tr><td>width</td><td align="center">in</td><td>图片宽度，为4的倍数</td></tr><tr><td>height</td><td align="center">in</td><td>图片高度，在NV21格式下要求为2的倍数 BGR24格式无限制</td></tr><tr><td>format</td><td align="center">in</td><td>支持NV21/BGR24</td></tr><tr><td>faceInfoList</td><td align="center">in</td><td>人脸信息列表</td></tr><tr><td>combinedMask</td><td align="center">in</td><td>检测的属性（ASF_AGE、ASF_GENDER、 ASF_FACE3DANGLE、ASF_LIVENESS），支持多选 检测的属性须在引擎初始化接口的combinedMask参数中启用</td></tr></tbody></table><p><strong>重要参数说明</strong></p><ul><li><strong>combinedMask</strong></li></ul><blockquote><p>process接口中支持检测<code>ASF_AGE</code>、<code>ASF_GENDER</code>、<code>ASF_FACE3DANGLE</code>、<code>ASF_LIVENESS</code>四种属性，但是想检测这些属性，必须在初始化引擎接口中对想要检测的属性进行初始化。</p></blockquote><p>关于初始化接口中<code>combinedMask</code>和<code>process</code>接口中<code>combinedMask</code>参数之间的关系，举例进行详细说明，如下图所示：</p><ol><li><code>process</code>接口中<code>combinedMask</code>支持传入的属性有<code>ASF_AGE</code>、<code>ASF_GENDER</code>、<code>ASF_FACE3DANGLE</code>、<code>ASF_LIVENESS</code>。</li><li>初始化中传入了<code>ASF_FACE_DETECT</code>、<code>ASF_FACERECOGNITION</code>、<code>ASF_AGE</code>、<code>ASF_LIVENESS</code>属性。</li><li>process可传入属性组合只有<code>ASF_AGE</code>、<code>ASF_LIVENESS</code>、<code>ASF_AGE | ASF_LIVENESS</code>。</li></ol><p><img src="https://ai.arcsoft.com.cn/uploadFiles/1/sdk/dd46d091-405d-4468-95ce-a4b3303edda8.png" alt="combinedMask"></p><p><strong>返回值</strong></p><p>成功返回<code>ErrorInfo.MOK</code>，失败详见 <a href="https://ai.arcsoft.com.cn/manual/docs#/141#42__19">错误码列表</a>。</p><h2 id="5-extractFaceFeature（传入分离的图像信息数据）"><a href="#5-extractFaceFeature（传入分离的图像信息数据）" class="headerlink" title="5.extractFaceFeature（传入分离的图像信息数据）"></a>5.extractFaceFeature（传入分离的图像信息数据）</h2><p><strong>方法</strong></p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">extractFaceFeature</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">byte</span>[] data,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span>,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span>,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> format,</span></span><span class="hljs-function"><span class="hljs-params">    FaceInfo faceInfo,</span></span><span class="hljs-function"><span class="hljs-params">    FaceFeature feature</span></span><span class="hljs-function"><span class="hljs-params">)</span></span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th>参数</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td align="center">in</td><td>图像数据</td></tr><tr><td>width</td><td align="center">in</td><td>图片宽度，为4的倍数</td></tr><tr><td>height</td><td align="center">in</td><td>图片高度，在NV21格式下要求为2的倍数； BGR24/GRAY/DEPTH_U16格式无限制；</td></tr><tr><td>format</td><td align="center">in</td><td>图像的颜色格式</td></tr><tr><td>faceInfo</td><td align="center">in</td><td>人脸信息（人脸框、人脸角度）</td></tr><tr><td>feature</td><td align="center">out</td><td>提取到的人脸特征信息</td></tr></tbody></table><p><strong>返回值</strong></p><p>成功返回<code>ErrorInfo.MOK</code>，失败详见 <a href="https://ai.arcsoft.com.cn/manual/docs#/141#42__19">错误码列表</a>。</p><h2 id="6-compareFaceFeature（可选择比对模型）"><a href="#6-compareFaceFeature（可选择比对模型）" class="headerlink" title="6.compareFaceFeature（可选择比对模型）"></a>6.compareFaceFeature（可选择比对模型）</h2><p><strong>方法</strong></p><pre><code class="hljs properties"><span class="hljs-attr">int</span> <span class="hljs-string">compareFaceFeature (</span>    <span class="hljs-attr">FaceFeature</span> <span class="hljs-string">feature1,</span>    <span class="hljs-attr">FaceFeature</span> <span class="hljs-string">feature2,</span>    <span class="hljs-attr">CompareModel</span> <span class="hljs-string">compareModel,</span>    <span class="hljs-attr">FaceSimilar</span> <span class="hljs-string">faceSimilar</span><span class="hljs-attr">)</span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th>参数</th><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td>feature1</td><td align="center">in</td><td>人脸特征</td></tr><tr><td>feature2</td><td align="center">in</td><td>人脸特征</td></tr><tr><td>compareModel</td><td align="center">in</td><td>比对模型</td></tr><tr><td>faceSimilar</td><td align="center">out</td><td>比对相似度</td></tr></tbody></table><p><strong>返回值</strong></p><p>成功返回<code>ErrorInfo.MOK</code>，失败详见 <a href="https://ai.arcsoft.com.cn/manual/docs#/141#42__19">错误码列表</a>。</p><h1 id="开始封装"><a href="#开始封装" class="headerlink" title="开始封装"></a>开始封装</h1><blockquote><p>直接SDK的使用请参考官方Demo，在注册SDK服务时下载即可。这里不介绍Demo使用，如果需要直接参考官方写的Demo即可，另外的，用我最后的封装会比直接使用官方SDK简单得多</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>RxJava</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BottomSheetBehavior+ViewPager+多RecyclerView 滑动冲突（滑动弹出隐藏）终极解决方案</title>
    <link href="/Blog/2020/12/07/BottomSheetBehavior-ViewPager-%E5%A4%9ARecyclerView-%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%EF%BC%88%E6%BB%91%E5%8A%A8%E5%BC%B9%E5%87%BA%E9%9A%90%E8%97%8F%EF%BC%89%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/Blog/2020/12/07/BottomSheetBehavior-ViewPager-%E5%A4%9ARecyclerView-%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%EF%BC%88%E6%BB%91%E5%8A%A8%E5%BC%B9%E5%87%BA%E9%9A%90%E8%97%8F%EF%BC%89%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://upload-images.jianshu.io/upload_images/17794320-594fb17b92a0442c.gif?imageMogr2/auto-orient/strip" alt="滑动冲突_1.gif"><br><img src="https://upload-images.jianshu.io/upload_images/17794320-6cd28b3ea12d2cf7.gif?imageMogr2/auto-orient/strip" alt="滑动冲突_2.gif"></p><h1 id="使用BottomSheetBehavior引发的问题"><a href="#使用BottomSheetBehavior引发的问题" class="headerlink" title="使用BottomSheetBehavior引发的问题"></a>使用BottomSheetBehavior引发的问题</h1><h2 id="问题1：BottomSheetBehavior-ViewPager-多页RecyclerView组合，只有第一页列表可滑动"><a href="#问题1：BottomSheetBehavior-ViewPager-多页RecyclerView组合，只有第一页列表可滑动" class="headerlink" title="问题1：BottomSheetBehavior+ViewPager+多页RecyclerView组合，只有第一页列表可滑动"></a>问题1：BottomSheetBehavior+ViewPager+多页RecyclerView组合，只有第一页列表可滑动</h2><p>在<code>CoordinatorLayout</code>中对弹出的<code>ViewGroup</code>直接使用 <code>com.google.android.material.bottomsheet.BottomSheetBehavior</code>，本身是没有问题的，但当我们嵌套了<code>ViewPager</code>+多页<code>RecyclerView</code>这个组合，就会导致只有第一页<code>RecyclerView</code>能滑动，其余页的滑动事件全部被<code>behavior</code>处理掉了，也就是滑动全部成为了弹出隐藏你得弹出框，很显然，列表是需要先于弹出框消费滑动的，于是我们看看<code>BottomSheetBehavior</code>的源码，如下：</p><pre><code class="hljs pgsql">@Nullable@VisibleForTesting<span class="hljs-keyword">View</span> findScrollingChild(<span class="hljs-keyword">View</span> <span class="hljs-keyword">view</span>) &#123;  <span class="hljs-keyword">if</span> (ViewCompat.isNestedScrollingEnabled(<span class="hljs-keyword">view</span>)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">view</span>;  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">view</span> instanceof ViewGroup) &#123;    ViewGroup <span class="hljs-keyword">group</span> = (ViewGroup) <span class="hljs-keyword">view</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, count = <span class="hljs-keyword">group</span>.getChildCount(); i &lt; count; i++) &#123;      <span class="hljs-keyword">View</span> scrollingChild = findScrollingChild(<span class="hljs-keyword">group</span>.getChildAt(i));      <span class="hljs-keyword">if</span> (scrollingChild != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> scrollingChild;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><blockquote><p> 关键的一段代码，在寻找滑动<code>View</code>的时候，对<code>ViewGroup</code>的<code>子View</code>进行了遍历，再递归的寻找<code>子View</code>下可滑动的控件，当找到第一个可滑动控件时，将其返回，作为消费滑动事件的控件。<br> 这里就明白了只有第一个<code>RecyclerView</code>能滑动的原因：无论<code>findScrollingChild</code>什么时机被触发，永远都只会返回<code>ViewPager</code>的第一页中的<code>RecyclerView</code>。知道了原因，修改就很简单了：将<code>ViewPager</code>拿出来，单独进行一波单独遍历。那么我们新建一个<code>MyViewPagerBottomSheetBehavior.java</code>，将<code>BottomSheetBehavior</code>代码拷贝，改造<code>findScrollingChild</code>后如下：</p></blockquote><pre><code class="hljs gauss"><span class="hljs-comment">@Nullable</span><span class="hljs-comment">@</span>VisibleForTesting<span class="hljs-built_in">View</span> <span class="hljs-built_in">findScrollingChild</span>(<span class="hljs-built_in">View</span> <span class="hljs-built_in">view</span>) &#123;    <span class="hljs-keyword">if</span> (ViewCompat.isNestedScrollingEnabled(<span class="hljs-built_in">view</span>)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">view</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">view</span> instanceof ViewPager) &#123;        ViewPager viewPager = (ViewPager) <span class="hljs-built_in">view</span>;        <span class="hljs-built_in">View</span> currentViewPagerChild = ViewPagerUtils.getCurrentView(viewPager); <span class="hljs-comment">//通过ViewPagerUtils找到当前在界面上的页面</span>        <span class="hljs-built_in">View</span> scrollingChild = <span class="hljs-built_in">findScrollingChild</span>(currentViewPagerChild);        <span class="hljs-keyword">if</span> (scrollingChild != <span class="hljs-built_in">null</span>) &#123;            <span class="hljs-keyword">return</span> scrollingChild;        &#125;        <span class="hljs-keyword">return</span> currentViewPagerChild;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">view</span> instanceof ViewGroup) &#123;        ViewGroup group = (ViewGroup) <span class="hljs-built_in">view</span>;        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>, count = group.<span class="hljs-built_in">getChildCount</span>(); i &lt; count; i++) &#123;            View scrollingChild = findScrollingChild(group.<span class="hljs-built_in">getChildAt</span>(i));            <span class="hljs-keyword">if</span> (scrollingChild != <span class="hljs-built_in">null</span>) &#123;                <span class="hljs-keyword">return</span> scrollingChild;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">null</span>;&#125;</code></pre><p>第一个问题解决了~</p><h2 id="问题2：滑动事件全部被-RecyclerView-消费掉，滑动弹出和关闭功能消失了"><a href="#问题2：滑动事件全部被-RecyclerView-消费掉，滑动弹出和关闭功能消失了" class="headerlink" title="问题2：滑动事件全部被 RecyclerView 消费掉，滑动弹出和关闭功能消失了"></a>问题2：滑动事件全部被 <code>RecyclerView</code> 消费掉，滑动弹出和关闭功能消失了</h2><p>导致这个问题的原因也很简单，我们的滑动事件在 <code>RecyclerView</code> 加入前，都是由 <code>BottomSheetBehavior</code> 来消费的，当我们加入 <code>RecyclerView</code> 这种可滑动控件后，滑动事件都被其消费，这与 <code>ViewPager</code> 无关。</p><blockquote><p>多数情况下我们需要 <code>RecyclerView</code> 消费事件（滑动），但我们同时希望当 <code>RecyclerView</code> 滑动到顶部时，将事件又重新交给 <code>Behavior</code> 消费，这样就可以做到，列表在顶部时滑动开启/关闭弹出框<br>实现需要分为以下几步</p></blockquote><ul><li>为 <code>Behavior</code> 添加 <code>Flag</code> ，标记列表是否滑动到最顶端<br>由于需要适配ViewPager多页情况，一个Flag不能解决，需要一个HashMap，将页数与Flag关联起来<pre><code class="hljs lasso"><span class="hljs-comment">//针对viewpager联动</span><span class="hljs-built_in">boolean</span> isFirstFind = <span class="hljs-literal">true</span>; <span class="hljs-comment">//第一次寻找联动View，为viewPager添加滑动监听</span><span class="hljs-keyword">private</span> HashMap&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Boolean</span>&gt; isScrollViewOnTopMap = <span class="hljs-literal">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">//关联页数与能否滑动flag的Map</span><span class="hljs-keyword">private</span> View globalView;<span class="hljs-comment">//保存下来的view，方便刷新寻找滑动控件时使用</span><span class="hljs-keyword">private</span> int currentPagePosition = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前ViewPager的页数</span>@Nullable@VisibleForTestingView findScrollingChild(View view) &#123; <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.. &#125;</code></pre></li><li>定义一个刷新滑动控件的方法，仅供 <code>MyViewPagerBehavior</code> 内部使用<pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyScrollView</span>(<span class="hljs-params"></span>)</span> &#123;    nestedScrollingChildRef = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(findScrollingChild(globalView));&#125;</code></pre></li><li>从<code>MyViewPagerBehavior</code>内对外暴露一个设置<code>Flag</code>的方法<pre><code class="hljs reasonml">public void set<span class="hljs-constructor">CurrentScrollViewOnTop(<span class="hljs-params">boolean</span> <span class="hljs-params">scrollViewOnTop</span>)</span> &#123;    isScrollViewOnTopMap.put(currentPagePosition, scrollViewOnTop);    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(<span class="hljs-string">&quot;~~~~~~~~~&quot;</span>,isScrollViewOnTopMap.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);    notify<span class="hljs-constructor">ScrollView()</span>;&#125;</code></pre></li><li>更改 <code>findScrollingChild(View view)</code> 方法，适配列表在顶部时，滑动由 <code>behavior</code> 处理<pre><code class="hljs reasonml">@Nullable@VisibleForTestingView find<span class="hljs-constructor">ScrollingChild(View <span class="hljs-params">view</span>)</span> &#123;    <span class="hljs-keyword">if</span>(view==null)&#123;        return null;    &#125;    globalView = view; <span class="hljs-comment">//为全局view赋值</span>    boolean b = isScrollViewOnTopMap.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">currentPagePosition</span>,<span class="hljs-params">false</span> )</span>;<span class="hljs-comment">//列表是否处于顶部</span>    <span class="hljs-keyword">if</span> (b) &#123;<span class="hljs-comment">//处于顶部，返回null，代表内部滑动控件不消费任何滑动事件，交由behavior处理</span>        return null;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewCompat</span>.</span></span>is<span class="hljs-constructor">NestedScrollingEnabled(<span class="hljs-params">view</span>)</span>) &#123;        return view;    &#125;    <span class="hljs-keyword">if</span> (view instanceof ViewPager) &#123;        ViewPager viewPager = (ViewPager) view;        <span class="hljs-keyword">if</span> (isFirstFind) &#123;<span class="hljs-comment">//初次寻找滑动view，添加viewpager翻页监听</span>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>require<span class="hljs-constructor">NonNull(<span class="hljs-params">viewPager</span>.<span class="hljs-params">getAdapter</span>()</span>).get<span class="hljs-constructor">Count()</span>; i++) &#123;                isScrollViewOnTopMap.put(i,<span class="hljs-literal">true</span>); <span class="hljs-comment">//将所有顶部标记置为false，默认不在顶部</span>            &#125;            viewPager.add<span class="hljs-constructor">OnPageChangeListener(<span class="hljs-params">new</span> ViewPager.OnPageChangeListener()</span> &#123;                @Override                public void on<span class="hljs-constructor">PageScrolled(<span class="hljs-params">int</span> <span class="hljs-params">position</span>, <span class="hljs-params">float</span> <span class="hljs-params">positionOffset</span>, <span class="hljs-params">int</span> <span class="hljs-params">positionOffsetPixels</span>)</span> &#123;                    <span class="hljs-comment">//翻页后，将现在的页数更新</span>                    currentPagePosition = position;                &#125;                @Override                public void on<span class="hljs-constructor">PageSelected(<span class="hljs-params">int</span> <span class="hljs-params">position</span>)</span> &#123;                &#125;                @Override                public void on<span class="hljs-constructor">PageScrollStateChanged(<span class="hljs-params">int</span> <span class="hljs-params">state</span>)</span> &#123;                &#125;            &#125;);            isFirstFind = <span class="hljs-literal">false</span>;        &#125;        View currentViewPagerChild = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewPagerUtils</span>.</span></span>get<span class="hljs-constructor">CurrentView(<span class="hljs-params">viewPager</span>)</span>; <span class="hljs-comment">//找到ViewPager当前的view</span>        View scrollingChild = find<span class="hljs-constructor">ScrollingChild(<span class="hljs-params">currentViewPagerChild</span>)</span>;        <span class="hljs-keyword">if</span> (scrollingChild != null) &#123;            return scrollingChild;        &#125;        return currentViewPagerChild;    &#125;</code></pre></li><li>监听 <code>RecyclerView</code> 滑动，在对顶部时，通知 <code>Behavior</code><br>这是在Fragment或者Activity中，你得behavior一定要自己去取，可能就在你得 <code>Fragment/Activity</code> 中通过<code>MyViewPagerBehavior.from()</code>就能获取,也可能你要从其他 <code>Activity</code> 和 <code>Fragment</code> 注入进来，具体只有你自己了解；不要忘了：<ul><li>behavior变量类型一定要写刚才创建的 <code>MyViewPagerBottomSheetBehavior</code></li><li>xml中更换behavior为 <code>MyViewPagerBottomSheetBehavior</code></li></ul></li></ul><pre><code class="hljs reasonml"><span class="hljs-comment">//上拉加载</span>binding.rvList.add<span class="hljs-constructor">OnScrollListener(<span class="hljs-params">new</span> RecyclerView.OnScrollListener()</span> &#123;    @Override    public void on<span class="hljs-constructor">Scrolled(@NonNull RecyclerView <span class="hljs-params">recyclerView</span>, <span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>)</span> &#123;        <span class="hljs-keyword">if</span> (behavior != null) &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(<span class="hljs-string">&quot;!!!!!!!!!&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(!<span class="hljs-params">recyclerView</span>.<span class="hljs-params">canScrollVertically</span>(-1)</span>) + dy);            <span class="hljs-keyword">if</span> (dy<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//指尖未真实上下滑动（针对从viewpager其他页面切换过来时），不做任何操作</span>                return;            &#125;            <span class="hljs-keyword">if</span> (!recyclerView.can<span class="hljs-constructor">ScrollVertically(-1)</span><span class="hljs-operator"> &amp;&amp; </span>dy &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//不可以下拉，并且手势是下拉，通知behavior已经列表已经在顶部了</span>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(<span class="hljs-string">&quot;~~~~~&quot;</span>, <span class="hljs-string">&quot;划不动了&quot;</span>);                behavior.set<span class="hljs-constructor">CurrentScrollViewOnTop(<span class="hljs-params">true</span>)</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//可以下拉或者手势不是下拉，通知behavior已经列表不在顶部</span>                behavior.set<span class="hljs-constructor">CurrentScrollViewOnTop(<span class="hljs-params">false</span>)</span>;            &#125;        &#125;    &#125;&#125;);</code></pre><h2 id="贴上完整的MyViewPagerBottomSheetBehavior"><a href="#贴上完整的MyViewPagerBottomSheetBehavior" class="headerlink" title="贴上完整的MyViewPagerBottomSheetBehavior"></a>贴上完整的MyViewPagerBottomSheetBehavior</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xxx.wordingtech.ui.widget;<span class="hljs-keyword">import</span> com.google.android.material.R;<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> androidx.annotation.RestrictTo.Scope.LIBRARY_GROUP;<span class="hljs-keyword">import</span> android.animation.ValueAnimator;<span class="hljs-keyword">import</span> android.animation.ValueAnimator.AnimatorUpdateListener;<span class="hljs-keyword">import</span> android.annotation.SuppressLint;<span class="hljs-keyword">import</span> android.content.Context;<span class="hljs-keyword">import</span> android.content.res.ColorStateList;<span class="hljs-keyword">import</span> android.content.res.TypedArray;<span class="hljs-keyword">import</span> android.os.Build;<span class="hljs-keyword">import</span> android.os.Build.VERSION;<span class="hljs-keyword">import</span> android.os.Build.VERSION_CODES;<span class="hljs-keyword">import</span> android.os.Parcel;<span class="hljs-keyword">import</span> android.os.Parcelable;<span class="hljs-keyword">import</span> androidx.annotation.FloatRange;<span class="hljs-keyword">import</span> androidx.annotation.IntDef;<span class="hljs-keyword">import</span> androidx.annotation.NonNull;<span class="hljs-keyword">import</span> androidx.annotation.Nullable;<span class="hljs-keyword">import</span> androidx.annotation.RestrictTo;<span class="hljs-keyword">import</span> androidx.annotation.VisibleForTesting;<span class="hljs-keyword">import</span> androidx.core.math.MathUtils;<span class="hljs-keyword">import</span> androidx.core.view.ViewCompat;<span class="hljs-keyword">import</span> androidx.core.view.accessibility.AccessibilityNodeInfoCompat;<span class="hljs-keyword">import</span> androidx.core.view.accessibility.AccessibilityNodeInfoCompat.AccessibilityActionCompat;<span class="hljs-keyword">import</span> androidx.core.view.accessibility.AccessibilityViewCommand;<span class="hljs-keyword">import</span> android.util.AttributeSet;<span class="hljs-keyword">import</span> android.util.Log;<span class="hljs-keyword">import</span> android.util.Pair;<span class="hljs-keyword">import</span> android.util.TypedValue;<span class="hljs-keyword">import</span> android.view.MotionEvent;<span class="hljs-keyword">import</span> android.view.VelocityTracker;<span class="hljs-keyword">import</span> android.view.View;<span class="hljs-keyword">import</span> android.view.ViewConfiguration;<span class="hljs-keyword">import</span> android.view.ViewGroup;<span class="hljs-keyword">import</span> android.view.ViewParent;<span class="hljs-keyword">import</span> android.view.WindowInsets;<span class="hljs-keyword">import</span> androidx.coordinatorlayout.widget.CoordinatorLayout;<span class="hljs-keyword">import</span> androidx.coordinatorlayout.widget.CoordinatorLayout.LayoutParams;<span class="hljs-keyword">import</span> androidx.customview.view.AbsSavedState;<span class="hljs-keyword">import</span> androidx.customview.widget.ViewDragHelper;<span class="hljs-keyword">import</span> androidx.viewpager.widget.ViewPager;<span class="hljs-keyword">import</span> androidx.viewpager.widget.ViewPagerUtils;<span class="hljs-keyword">import</span> com.google.android.material.bottomsheet.BottomSheetBehavior;<span class="hljs-keyword">import</span> com.google.android.material.resources.MaterialResources;<span class="hljs-keyword">import</span> com.google.android.material.shape.MaterialShapeDrawable;<span class="hljs-keyword">import</span> com.google.android.material.shape.ShapeAppearanceModel;<span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-keyword">import</span> java.lang.ref.WeakReference;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Objects;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewPagerBottomSheetBehavior</span>&lt;<span class="hljs-title">V</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">View</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">CoordinatorLayout</span>.<span class="hljs-title">Behavior</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Callback for monitoring events about bottom sheets.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BottomSheetCallback</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Called when the bottom sheet changes its state.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> bottomSheet The bottom sheet view.</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> newState    The new state. This will be one of &#123;<span class="hljs-doctag">@link</span> #STATE_DRAGGING&#125;, &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">         *                    #STATE_SETTLING&#125;, &#123;<span class="hljs-doctag">@link</span> #STATE_EXPANDED&#125;, &#123;<span class="hljs-doctag">@link</span> #STATE_COLLAPSED&#125;, &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">         *                    #STATE_HIDDEN&#125;, or &#123;<span class="hljs-doctag">@link</span> #STATE_HALF_EXPANDED&#125;.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View bottomSheet, <span class="hljs-meta">@State</span> <span class="hljs-keyword">int</span> newState)</span></span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * Called when the bottom sheet is being dragged.</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> bottomSheet The bottom sheet view.</span><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> slideOffset The new offset of this bottom sheet within [-1,1] range. Offset increases</span><span class="hljs-comment">         *                    as this bottom sheet is moving upward. From 0 to 1 the sheet is between collapsed and</span><span class="hljs-comment">         *                    expanded states and from -1 to 0 it is between hidden and collapsed states.</span><span class="hljs-comment">         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSlide</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View bottomSheet, <span class="hljs-keyword">float</span> slideOffset)</span></span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The bottom sheet is dragging.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATE_DRAGGING = <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The bottom sheet is settling.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATE_SETTLING = <span class="hljs-number">2</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The bottom sheet is expanded.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATE_EXPANDED = <span class="hljs-number">3</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The bottom sheet is collapsed.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATE_COLLAPSED = <span class="hljs-number">4</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The bottom sheet is hidden.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATE_HIDDEN = <span class="hljs-number">5</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * The bottom sheet is half-expanded (used when mFitToContents is false).</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATE_HALF_EXPANDED = <span class="hljs-number">6</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@hide</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RestrictTo(LIBRARY_GROUP)</span>    <span class="hljs-meta">@IntDef(&#123;</span><span class="hljs-meta">            STATE_EXPANDED,</span><span class="hljs-meta">            STATE_COLLAPSED,</span><span class="hljs-meta">            STATE_DRAGGING,</span><span class="hljs-meta">            STATE_SETTLING,</span><span class="hljs-meta">            STATE_HIDDEN,</span><span class="hljs-meta">            STATE_HALF_EXPANDED</span><span class="hljs-meta">    &#125;)</span>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> State &#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Peek at the 16:9 ratio keyline of its parent.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;This can be used as a parameter for &#123;<span class="hljs-doctag">@link</span> #setPeekHeight(int)&#125;. &#123;<span class="hljs-doctag">@link</span> #getPeekHeight()&#125;</span><span class="hljs-comment">     * will return this when the value is set.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PEEK_HEIGHT_AUTO = -<span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * This flag will preserve the peekHeight int value on configuration change.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SAVE_PEEK_HEIGHT = <span class="hljs-number">0x1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * This flag will preserve the fitToContents boolean value on configuration change.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SAVE_FIT_TO_CONTENTS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * This flag will preserve the hideable boolean value on configuration change.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SAVE_HIDEABLE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * This flag will preserve the skipCollapsed boolean value on configuration change.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SAVE_SKIP_COLLAPSED = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * This flag will preserve all aforementioned values on configuration change.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SAVE_ALL = -<span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * This flag will not preserve the aforementioned values set at runtime if the view is destroyed</span><span class="hljs-comment">     * and recreated. The only value preserved will be the positional state, e.g. collapsed, hidden,</span><span class="hljs-comment">     * expanded, etc. This is the default behavior.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SAVE_NONE = <span class="hljs-number">0</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@hide</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RestrictTo(LIBRARY_GROUP)</span>    <span class="hljs-meta">@IntDef(</span><span class="hljs-meta">            flag = true,</span><span class="hljs-meta">            value = &#123;</span><span class="hljs-meta">                    SAVE_PEEK_HEIGHT,</span><span class="hljs-meta">                    SAVE_FIT_TO_CONTENTS,</span><span class="hljs-meta">                    SAVE_HIDEABLE,</span><span class="hljs-meta">                    SAVE_SKIP_COLLAPSED,</span><span class="hljs-meta">                    SAVE_ALL,</span><span class="hljs-meta">                    SAVE_NONE,</span><span class="hljs-meta">            &#125;)</span>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SaveFlags &#123;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;BottomSheetBehavior&quot;</span>;    <span class="hljs-meta">@SaveFlags</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> saveFlags = SAVE_NONE;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNIFICANT_VEL_THRESHOLD = <span class="hljs-number">500</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> HIDE_THRESHOLD = <span class="hljs-number">0.5f</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> HIDE_FRICTION = <span class="hljs-number">0.1f</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORNER_ANIMATION_DURATION = <span class="hljs-number">500</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> fitToContents = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> updateImportantForAccessibilityOnSiblings = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> maximumVelocity;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Peek height set by the user.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> peekHeight;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Whether or not to use automatic peek height.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> peekHeightAuto;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Minimum peek height permitted.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> peekHeightMin;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * True if Behavior has a non-null value for the <span class="hljs-doctag">@shapeAppearance</span> attribute</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> shapeThemingEnabled;    <span class="hljs-keyword">private</span> MaterialShapeDrawable materialShapeDrawable;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> gestureInsetBottomIgnored;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Default Shape Appearance to be used in bottomsheet</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> ShapeAppearanceModel shapeAppearanceModelDefault;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isShapeExpanded;    <span class="hljs-keyword">private</span> SettleRunnable settleRunnable = <span class="hljs-keyword">null</span>;    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">private</span> ValueAnimator interpolatorAnimator;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEF_STYLE_RES = R.style.Widget_Design_BottomSheet_Modal;    <span class="hljs-keyword">int</span> expandedOffset;    <span class="hljs-keyword">int</span> fitToContentsOffset;    <span class="hljs-keyword">int</span> halfExpandedOffset;    <span class="hljs-keyword">float</span> halfExpandedRatio = <span class="hljs-number">0.5f</span>;    <span class="hljs-keyword">int</span> collapsedOffset;    <span class="hljs-keyword">float</span> elevation = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">boolean</span> hideable;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> skipCollapsed;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> draggable = <span class="hljs-keyword">true</span>;    <span class="hljs-meta">@State</span>    <span class="hljs-keyword">int</span> state = STATE_COLLAPSED;    <span class="hljs-meta">@Nullable</span>    ViewDragHelper viewDragHelper;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ignoreEvents;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> lastNestedScrollDy;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> nestedScrolled;    <span class="hljs-keyword">int</span> parentWidth;    <span class="hljs-keyword">int</span> parentHeight;    <span class="hljs-meta">@Nullable</span>    WeakReference&lt;V&gt; viewRef;    <span class="hljs-meta">@Nullable</span>    WeakReference&lt;View&gt; nestedScrollingChildRef;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;BottomSheetCallback&gt; callbacks = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">private</span> VelocityTracker velocityTracker;    <span class="hljs-keyword">int</span> activePointerId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> initialY;    <span class="hljs-keyword">boolean</span> touchingScrollingChild;    <span class="hljs-meta">@Nullable</span>    <span class="hljs-keyword">private</span> Map&lt;View, Integer&gt; importantForAccessibilityMap;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyViewPagerBottomSheetBehavior</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyViewPagerBottomSheetBehavior</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;        <span class="hljs-keyword">super</span>(context, attrs);        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.BottomSheetBehavior_Layout);        <span class="hljs-keyword">this</span>.shapeThemingEnabled = a.hasValue(R.styleable.BottomSheetBehavior_Layout_shapeAppearance);        <span class="hljs-keyword">boolean</span> hasBackgroundTint = a.hasValue(R.styleable.BottomSheetBehavior_Layout_backgroundTint);        <span class="hljs-keyword">if</span> (hasBackgroundTint) &#123;            <span class="hljs-meta">@SuppressLint(&quot;RestrictedApi&quot;)</span> ColorStateList bottomSheetColor =                    MaterialResources.getColorStateList(                            context, a, R.styleable.BottomSheetBehavior_Layout_backgroundTint);            createMaterialShapeDrawable(context, attrs, hasBackgroundTint, bottomSheetColor);        &#125; <span class="hljs-keyword">else</span> &#123;            createMaterialShapeDrawable(context, attrs, hasBackgroundTint);        &#125;        createShapeValueAnimator();        <span class="hljs-keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.LOLLIPOP) &#123;            <span class="hljs-keyword">this</span>.elevation = a.getDimension(R.styleable.BottomSheetBehavior_Layout_android_elevation, -<span class="hljs-number">1</span>);        &#125;        TypedValue value = a.peekValue(R.styleable.BottomSheetBehavior_Layout_behavior_peekHeight);        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span> &amp;&amp; value.data == PEEK_HEIGHT_AUTO) &#123;            setPeekHeight(value.data);        &#125; <span class="hljs-keyword">else</span> &#123;            setPeekHeight(                    a.getDimensionPixelSize(                            R.styleable.BottomSheetBehavior_Layout_behavior_peekHeight, PEEK_HEIGHT_AUTO));        &#125;        setHideable(a.getBoolean(R.styleable.BottomSheetBehavior_Layout_behavior_hideable, <span class="hljs-keyword">false</span>));        setGestureInsetBottomIgnored(                a.getBoolean(R.styleable.BottomSheetBehavior_Layout_gestureInsetBottomIgnored, <span class="hljs-keyword">false</span>));        setFitToContents(                a.getBoolean(R.styleable.BottomSheetBehavior_Layout_behavior_fitToContents, <span class="hljs-keyword">true</span>));        setSkipCollapsed(                a.getBoolean(R.styleable.BottomSheetBehavior_Layout_behavior_skipCollapsed, <span class="hljs-keyword">false</span>));        setDraggable(a.getBoolean(R.styleable.BottomSheetBehavior_Layout_behavior_draggable, <span class="hljs-keyword">true</span>));        setSaveFlags(a.getInt(R.styleable.BottomSheetBehavior_Layout_behavior_saveFlags, SAVE_NONE));        setHalfExpandedRatio(                a.getFloat(R.styleable.BottomSheetBehavior_Layout_behavior_halfExpandedRatio, <span class="hljs-number">0.5f</span>));        value = a.peekValue(R.styleable.BottomSheetBehavior_Layout_behavior_expandedOffset);        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span> &amp;&amp; value.type == TypedValue.TYPE_FIRST_INT) &#123;            setExpandedOffset(value.data);        &#125; <span class="hljs-keyword">else</span> &#123;            setExpandedOffset(                    a.getDimensionPixelOffset(                            R.styleable.BottomSheetBehavior_Layout_behavior_expandedOffset, <span class="hljs-number">0</span>));        &#125;        a.recycle();        ViewConfiguration configuration = ViewConfiguration.get(context);        maximumVelocity = configuration.getScaledMaximumFlingVelocity();    &#125;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Parcelable <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, <span class="hljs-meta">@NonNull</span> V child)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SavedState(<span class="hljs-keyword">super</span>.onSaveInstanceState(parent, child), <span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRestoreInstanceState</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, <span class="hljs-meta">@NonNull</span> V child, <span class="hljs-meta">@NonNull</span> Parcelable state)</span> </span>&#123;        SavedState ss = (SavedState) state;        <span class="hljs-keyword">super</span>.onRestoreInstanceState(parent, child, ss.getSuperState());        <span class="hljs-comment">// Restore Optional State values designated by saveFlags</span>        restoreOptionalState(ss);        <span class="hljs-comment">// Intermediate states are restored as collapsed state</span>        <span class="hljs-keyword">if</span> (ss.state == STATE_DRAGGING || ss.state == STATE_SETTLING) &#123;            <span class="hljs-keyword">this</span>.state = STATE_COLLAPSED;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.state = ss.state;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAttachedToLayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutParams layoutParams)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onAttachedToLayoutParams(layoutParams);        <span class="hljs-comment">// These may already be null, but just be safe, explicitly assign them. This lets us know the</span>        <span class="hljs-comment">// first time we layout with this behavior by checking (viewRef == null).</span>        viewRef = <span class="hljs-keyword">null</span>;        viewDragHelper = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDetachedFromLayoutParams</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onDetachedFromLayoutParams();        <span class="hljs-comment">// Release references so we don&#x27;t run unnecessary codepaths while not attached to a view.</span>        viewRef = <span class="hljs-keyword">null</span>;        viewDragHelper = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLayoutChild</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, <span class="hljs-meta">@NonNull</span> V child, <span class="hljs-keyword">int</span> layoutDirection)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ViewCompat.getFitsSystemWindows(parent) &amp;&amp; !ViewCompat.getFitsSystemWindows(child)) &#123;            child.setFitsSystemWindows(<span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-keyword">if</span> (viewRef == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// First layout with this behavior.</span>            peekHeightMin =                    parent.getResources().getDimensionPixelSize(R.dimen.design_bottom_sheet_peek_height_min);            setSystemGestureInsets(parent);            viewRef = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(child);            <span class="hljs-comment">// Only set MaterialShapeDrawable as background if shapeTheming is enabled, otherwise will</span>            <span class="hljs-comment">// default to android:background declared in styles or layout.</span>            <span class="hljs-keyword">if</span> (shapeThemingEnabled &amp;&amp; materialShapeDrawable != <span class="hljs-keyword">null</span>) &#123;                ViewCompat.setBackground(child, materialShapeDrawable);            &#125;            <span class="hljs-comment">// Set elevation on MaterialShapeDrawable</span>            <span class="hljs-keyword">if</span> (materialShapeDrawable != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// Use elevation attr if set on bottomsheet; otherwise, use elevation of child view.</span>                materialShapeDrawable.setElevation(                        elevation == -<span class="hljs-number">1</span> ? ViewCompat.getElevation(child) : elevation);                <span class="hljs-comment">// Update the material shape based on initial state.</span>                isShapeExpanded = state == STATE_EXPANDED;                materialShapeDrawable.setInterpolation(isShapeExpanded ? <span class="hljs-number">0f</span> : <span class="hljs-number">1f</span>);            &#125;            updateAccessibilityActions();            <span class="hljs-keyword">if</span> (ViewCompat.getImportantForAccessibility(child)                    == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;                ViewCompat.setImportantForAccessibility(child, ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);            &#125;        &#125;        <span class="hljs-keyword">if</span> (viewDragHelper == <span class="hljs-keyword">null</span>) &#123;            viewDragHelper = ViewDragHelper.create(parent, dragCallback);        &#125;        <span class="hljs-keyword">int</span> savedTop = child.getTop();        <span class="hljs-comment">// First let the parent lay it out</span>        parent.onLayoutChild(child, layoutDirection);        <span class="hljs-comment">// Offset the bottom sheet</span>        parentWidth = parent.getWidth();        parentHeight = parent.getHeight();        fitToContentsOffset = Math.max(<span class="hljs-number">0</span>, parentHeight - child.getHeight());        calculateHalfExpandedOffset();        calculateCollapsedOffset();        <span class="hljs-keyword">if</span> (state == STATE_EXPANDED) &#123;            ViewCompat.offsetTopAndBottom(child, getExpandedOffset());        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == STATE_HALF_EXPANDED) &#123;            ViewCompat.offsetTopAndBottom(child, halfExpandedOffset);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hideable &amp;&amp; state == STATE_HIDDEN) &#123;            ViewCompat.offsetTopAndBottom(child, parentHeight);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == STATE_COLLAPSED) &#123;            ViewCompat.offsetTopAndBottom(child, collapsedOffset);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == STATE_DRAGGING || state == STATE_SETTLING) &#123;            ViewCompat.offsetTopAndBottom(child, savedTop - child.getTop());        &#125;        nestedScrollingChildRef = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(findScrollingChild(child));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, <span class="hljs-meta">@NonNull</span> V child, <span class="hljs-meta">@NonNull</span> MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!child.isShown() || !draggable) &#123;            ignoreEvents = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> action = event.getActionMasked();        <span class="hljs-comment">// Record the velocity</span>        <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;            reset();        &#125;        <span class="hljs-keyword">if</span> (velocityTracker == <span class="hljs-keyword">null</span>) &#123;            velocityTracker = VelocityTracker.obtain();        &#125;        velocityTracker.addMovement(event);        <span class="hljs-keyword">switch</span> (action) &#123;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                touchingScrollingChild = <span class="hljs-keyword">false</span>;                activePointerId = MotionEvent.INVALID_POINTER_ID;                <span class="hljs-comment">// Reset the ignore flag</span>                <span class="hljs-keyword">if</span> (ignoreEvents) &#123;                    ignoreEvents = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                <span class="hljs-keyword">int</span> initialX = (<span class="hljs-keyword">int</span>) event.getX();                initialY = (<span class="hljs-keyword">int</span>) event.getY();                <span class="hljs-comment">// Only intercept nested scrolling events here if the view not being moved by the</span>                <span class="hljs-comment">// ViewDragHelper.</span>                <span class="hljs-keyword">if</span> (state != STATE_SETTLING) &#123;                    View scroll = nestedScrollingChildRef != <span class="hljs-keyword">null</span> ? nestedScrollingChildRef.get() : <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">if</span> (scroll != <span class="hljs-keyword">null</span> &amp;&amp; parent.isPointInChildBounds(scroll, initialX, initialY)) &#123;                        activePointerId = event.getPointerId(event.getActionIndex());                        touchingScrollingChild = <span class="hljs-keyword">true</span>;                    &#125;                &#125;                ignoreEvents =                        activePointerId == MotionEvent.INVALID_POINTER_ID                                &amp;&amp; !parent.isPointInChildBounds(child, initialX, initialY);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>: <span class="hljs-comment">// fall out</span>        &#125;        <span class="hljs-keyword">if</span> (!ignoreEvents                &amp;&amp; viewDragHelper != <span class="hljs-keyword">null</span>                &amp;&amp; viewDragHelper.shouldInterceptTouchEvent(event)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// We have to handle cases that the ViewDragHelper does not capture the bottom sheet because</span>        <span class="hljs-comment">// it is not the top most view of its parent. This is not necessary when the touch event is</span>        <span class="hljs-comment">// happening over the scrolling content as nested scrolling logic handles that case.</span>        View scroll = nestedScrollingChildRef != <span class="hljs-keyword">null</span> ? nestedScrollingChildRef.get() : <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> action == MotionEvent.ACTION_MOVE                &amp;&amp; scroll != <span class="hljs-keyword">null</span>                &amp;&amp; !ignoreEvents                &amp;&amp; state != STATE_DRAGGING                &amp;&amp; !parent.isPointInChildBounds(scroll, (<span class="hljs-keyword">int</span>) event.getX(), (<span class="hljs-keyword">int</span>) event.getY())                &amp;&amp; viewDragHelper != <span class="hljs-keyword">null</span>                &amp;&amp; Math.abs(initialY - event.getY()) &gt; viewDragHelper.getTouchSlop();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout parent, <span class="hljs-meta">@NonNull</span> V child, <span class="hljs-meta">@NonNull</span> MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!child.isShown()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> action = event.getActionMasked();        <span class="hljs-keyword">if</span> (state == STATE_DRAGGING &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span> (viewDragHelper != <span class="hljs-keyword">null</span>) &#123;            viewDragHelper.processTouchEvent(event);        &#125;        <span class="hljs-comment">// Record the velocity</span>        <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;            reset();        &#125;        <span class="hljs-keyword">if</span> (velocityTracker == <span class="hljs-keyword">null</span>) &#123;            velocityTracker = VelocityTracker.obtain();        &#125;        velocityTracker.addMovement(event);        <span class="hljs-comment">// The ViewDragHelper tries to capture only the top-most View. We have to explicitly tell it</span>        <span class="hljs-comment">// to capture the bottom sheet in case it is not captured and the touch slop is passed.</span>        <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_MOVE &amp;&amp; !ignoreEvents) &#123;            <span class="hljs-keyword">if</span> (Math.abs(initialY - event.getY()) &gt; viewDragHelper.getTouchSlop()) &#123;                viewDragHelper.captureChildView(child, event.getPointerId(event.getActionIndex()));            &#125;        &#125;        <span class="hljs-keyword">return</span> !ignoreEvents;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> V child,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> View directTargetChild,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> View target,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> axes,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> type)</span> </span>&#123;        lastNestedScrollDy = <span class="hljs-number">0</span>;        nestedScrolled = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> (axes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != <span class="hljs-number">0</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedPreScroll</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> V child,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> View target,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> dx,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> dy,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">int</span>[] consumed,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> type)</span> </span>&#123;        <span class="hljs-keyword">if</span> (type == ViewCompat.TYPE_NON_TOUCH) &#123;            <span class="hljs-comment">// Ignore fling here. The ViewDragHelper handles it.</span>            <span class="hljs-keyword">return</span>;        &#125;        View scrollingChild = nestedScrollingChildRef != <span class="hljs-keyword">null</span> ? nestedScrollingChildRef.get() : <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (target != scrollingChild) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> currentTop = child.getTop();        <span class="hljs-keyword">int</span> newTop = currentTop - dy;        <span class="hljs-keyword">if</span> (dy &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Upward</span>            <span class="hljs-keyword">if</span> (newTop &lt; getExpandedOffset()) &#123;                consumed[<span class="hljs-number">1</span>] = currentTop - getExpandedOffset();                ViewCompat.offsetTopAndBottom(child, -consumed[<span class="hljs-number">1</span>]);                setStateInternal(STATE_EXPANDED);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (!draggable) &#123;                    <span class="hljs-comment">// Prevent dragging</span>                    <span class="hljs-keyword">return</span>;                &#125;                consumed[<span class="hljs-number">1</span>] = dy;                ViewCompat.offsetTopAndBottom(child, -dy);                setStateInternal(STATE_DRAGGING);            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dy &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Downward</span>            <span class="hljs-keyword">if</span> (!target.canScrollVertically(-<span class="hljs-number">1</span>)) &#123;                <span class="hljs-keyword">if</span> (newTop &lt;= collapsedOffset || hideable) &#123;                    <span class="hljs-keyword">if</span> (!draggable) &#123;                        <span class="hljs-comment">// Prevent dragging</span>                        <span class="hljs-keyword">return</span>;                    &#125;                    consumed[<span class="hljs-number">1</span>] = dy;                    ViewCompat.offsetTopAndBottom(child, -dy);                    setStateInternal(STATE_DRAGGING);                &#125; <span class="hljs-keyword">else</span> &#123;                    consumed[<span class="hljs-number">1</span>] = currentTop - collapsedOffset;                    ViewCompat.offsetTopAndBottom(child, -consumed[<span class="hljs-number">1</span>]);                    setStateInternal(STATE_COLLAPSED);                &#125;            &#125;        &#125;        dispatchOnSlide(child.getTop());        lastNestedScrollDy = dy;        nestedScrolled = <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStopNestedScroll</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> V child,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> View target,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> type)</span> </span>&#123;        <span class="hljs-keyword">if</span> (child.getTop() == getExpandedOffset()) &#123;            setStateInternal(STATE_EXPANDED);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (nestedScrollingChildRef == <span class="hljs-keyword">null</span>                || target != nestedScrollingChildRef.get()                || !nestedScrolled) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> top;        <span class="hljs-keyword">int</span> targetState;        <span class="hljs-keyword">if</span> (lastNestedScrollDy &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (fitToContents) &#123;                top = fitToContentsOffset;                targetState = STATE_EXPANDED;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span> currentTop = child.getTop();                <span class="hljs-keyword">if</span> (currentTop &gt; halfExpandedOffset) &#123;                    top = halfExpandedOffset;                    targetState = STATE_HALF_EXPANDED;                &#125; <span class="hljs-keyword">else</span> &#123;                    top = expandedOffset;                    targetState = STATE_EXPANDED;                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hideable &amp;&amp; shouldHide(child, getYVelocity())) &#123;            top = parentHeight;            targetState = STATE_HIDDEN;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastNestedScrollDy == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> currentTop = child.getTop();            <span class="hljs-keyword">if</span> (fitToContents) &#123;                <span class="hljs-keyword">if</span> (Math.abs(currentTop - fitToContentsOffset) &lt; Math.abs(currentTop - collapsedOffset)) &#123;                    top = fitToContentsOffset;                    targetState = STATE_EXPANDED;                &#125; <span class="hljs-keyword">else</span> &#123;                    top = collapsedOffset;                    targetState = STATE_COLLAPSED;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (currentTop &lt; halfExpandedOffset) &#123;                    <span class="hljs-keyword">if</span> (currentTop &lt; Math.abs(currentTop - collapsedOffset)) &#123;                        top = expandedOffset;                        targetState = STATE_EXPANDED;                    &#125; <span class="hljs-keyword">else</span> &#123;                        top = halfExpandedOffset;                        targetState = STATE_HALF_EXPANDED;                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> (Math.abs(currentTop - halfExpandedOffset) &lt; Math.abs(currentTop - collapsedOffset)) &#123;                        top = halfExpandedOffset;                        targetState = STATE_HALF_EXPANDED;                    &#125; <span class="hljs-keyword">else</span> &#123;                        top = collapsedOffset;                        targetState = STATE_COLLAPSED;                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (fitToContents) &#123;                top = collapsedOffset;                targetState = STATE_COLLAPSED;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// Settle to nearest height.</span>                <span class="hljs-keyword">int</span> currentTop = child.getTop();                <span class="hljs-keyword">if</span> (Math.abs(currentTop - halfExpandedOffset) &lt; Math.abs(currentTop - collapsedOffset)) &#123;                    top = halfExpandedOffset;                    targetState = STATE_HALF_EXPANDED;                &#125; <span class="hljs-keyword">else</span> &#123;                    top = collapsedOffset;                    targetState = STATE_COLLAPSED;                &#125;            &#125;        &#125;        startSettlingAnimation(child, targetState, top, <span class="hljs-keyword">false</span>);        nestedScrolled = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> V child,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> View target,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> dxConsumed,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> dyConsumed,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> dxUnconsumed,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> dyUnconsumed,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">int</span> type,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">int</span>[] consumed)</span> </span>&#123;        <span class="hljs-comment">// Overridden to prevent the default consumption of the entire scroll distance.</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onNestedPreFling</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CoordinatorLayout coordinatorLayout,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> V child,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> View target,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">float</span> velocityX,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">float</span> velocityY)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nestedScrollingChildRef != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> target == nestedScrollingChildRef.get()                    &amp;&amp; (state != STATE_EXPANDED                    || <span class="hljs-keyword">super</span>.onNestedPreFling(coordinatorLayout, child, target, velocityX, velocityY));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> whether the height of the expanded sheet is determined by the height of its contents,</span><span class="hljs-comment">     * or if it is expanded in two stages (half the height of the parent container, full height of</span><span class="hljs-comment">     * parent container).</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFitToContents</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> fitToContents;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets whether the height of the expanded sheet is determined by the height of its contents, or</span><span class="hljs-comment">     * if it is expanded in two stages (half the height of the parent container, full height of parent</span><span class="hljs-comment">     * container). Default value is true.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fitToContents whether or not to fit the expanded sheet to its contents.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFitToContents</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fitToContents)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fitToContents == fitToContents) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">this</span>.fitToContents = fitToContents;        <span class="hljs-comment">// If sheet is already laid out, recalculate the collapsed offset based on new setting.</span>        <span class="hljs-comment">// Otherwise, let onLayoutChild handle this later.</span>        <span class="hljs-keyword">if</span> (viewRef != <span class="hljs-keyword">null</span>) &#123;            calculateCollapsedOffset();        &#125;        <span class="hljs-comment">// Fix incorrect expanded settings depending on whether or not we are fitting sheet to contents.</span>        setStateInternal((<span class="hljs-keyword">this</span>.fitToContents &amp;&amp; state == STATE_HALF_EXPANDED) ? STATE_EXPANDED : state);        updateAccessibilityActions();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets the height of the bottom sheet when it is collapsed.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> peekHeight The height of the collapsed bottom sheet in pixels, or &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">     *                   #PEEK_HEIGHT_AUTO&#125; to configure the sheet to peek automatically at 16:9 ratio keyline.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_peekHeight</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPeekHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> peekHeight)</span> </span>&#123;        setPeekHeight(peekHeight, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets the height of the bottom sheet when it is collapsed while optionally animating between the</span><span class="hljs-comment">     * old height and the new height.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> peekHeight The height of the collapsed bottom sheet in pixels, or &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">     *                   #PEEK_HEIGHT_AUTO&#125; to configure the sheet to peek automatically at 16:9 ratio keyline.</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> animate    Whether to animate between the old height and the new height.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_peekHeight</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPeekHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> peekHeight, <span class="hljs-keyword">boolean</span> animate)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> layout = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (peekHeight == PEEK_HEIGHT_AUTO) &#123;            <span class="hljs-keyword">if</span> (!peekHeightAuto) &#123;                peekHeightAuto = <span class="hljs-keyword">true</span>;                layout = <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (peekHeightAuto || <span class="hljs-keyword">this</span>.peekHeight != peekHeight) &#123;            peekHeightAuto = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">this</span>.peekHeight = Math.max(<span class="hljs-number">0</span>, peekHeight);            layout = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// If sheet is already laid out, recalculate the collapsed offset based on new setting.</span>        <span class="hljs-comment">// Otherwise, let onLayoutChild handle this later.</span>        <span class="hljs-keyword">if</span> (layout &amp;&amp; viewRef != <span class="hljs-keyword">null</span>) &#123;            calculateCollapsedOffset();            <span class="hljs-keyword">if</span> (state == STATE_COLLAPSED) &#123;                V view = viewRef.get();                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (animate) &#123;                        settleToStatePendingLayout(state);                    &#125; <span class="hljs-keyword">else</span> &#123;                        view.requestLayout();                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Gets the height of the bottom sheet when it is collapsed.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The height of the collapsed bottom sheet in pixels, or &#123;<span class="hljs-doctag">@link</span> #PEEK_HEIGHT_AUTO&#125; if the</span><span class="hljs-comment">     * sheet is configured to peek automatically at 16:9 ratio keyline</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_peekHeight</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPeekHeight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> peekHeightAuto ? PEEK_HEIGHT_AUTO : peekHeight;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Determines the height of the BottomSheet in the &#123;<span class="hljs-doctag">@link</span> #STATE_HALF_EXPANDED&#125; state. The</span><span class="hljs-comment">     * material guidelines recommended a value of 0.5, which results in the sheet filling half of the</span><span class="hljs-comment">     * parent. The height of the BottomSheet will be smaller as this ratio is decreased and taller as</span><span class="hljs-comment">     * it is increased. The default value is 0.5.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ratio a float between 0 and 1, representing the &#123;<span class="hljs-doctag">@link</span> #STATE_HALF_EXPANDED&#125; ratio.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_halfExpandedRatio</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHalfExpandedRatio</span><span class="hljs-params">(<span class="hljs-meta">@FloatRange(from = 0.0f, to = 1.0f)</span> <span class="hljs-keyword">float</span> ratio)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((ratio &lt;= <span class="hljs-number">0</span>) || (ratio &gt;= <span class="hljs-number">1</span>)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;ratio must be a float value between 0 and 1&quot;</span>);        &#125;        <span class="hljs-keyword">this</span>.halfExpandedRatio = ratio;        <span class="hljs-comment">// If sheet is already laid out, recalculate the half expanded offset based on new setting.</span>        <span class="hljs-comment">// Otherwise, let onLayoutChild handle this later.</span>        <span class="hljs-keyword">if</span> (viewRef != <span class="hljs-keyword">null</span>) &#123;            calculateHalfExpandedOffset();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Gets the ratio for the height of the BottomSheet in the &#123;<span class="hljs-doctag">@link</span> #STATE_HALF_EXPANDED&#125; state.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_halfExpandedRatio</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@FloatRange(from = 0.0f, to = 1.0f)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getHalfExpandedRatio</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> halfExpandedRatio;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Determines the top offset of the BottomSheet in the &#123;<span class="hljs-doctag">@link</span> #STATE_EXPANDED&#125; state when</span><span class="hljs-comment">     * fitsToContent is false. The default value is 0, which results in the sheet matching the</span><span class="hljs-comment">     * parent&#x27;s top.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset an integer value greater than equal to 0, representing the &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">     *               #STATE_EXPANDED&#125; offset. Value must not exceed the offset in the half expanded state.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_expandedOffset</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExpandedOffset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset)</span> </span>&#123;        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;offset must be greater than or equal to 0&quot;</span>);        &#125;        <span class="hljs-keyword">this</span>.expandedOffset = offset;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the current expanded offset. If &#123;<span class="hljs-doctag">@code</span> fitToContents&#125; is true, it will automatically</span><span class="hljs-comment">     * pick the offset depending on the height of the content.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_expandedOffset</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getExpandedOffset</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> fitToContents ? fitToContentsOffset : expandedOffset;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets whether this bottom sheet can hide when it is swiped down.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> hideable &#123;<span class="hljs-doctag">@code</span> true&#125; to make this bottom sheet hideable.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_hideable</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHideable</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hideable)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hideable != hideable) &#123;            <span class="hljs-keyword">this</span>.hideable = hideable;            <span class="hljs-keyword">if</span> (!hideable &amp;&amp; state == STATE_HIDDEN) &#123;                <span class="hljs-comment">// Lift up to collapsed state</span>                setState(STATE_COLLAPSED);            &#125;            updateAccessibilityActions();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Gets whether this bottom sheet can hide when it is swiped down.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if this bottom sheet can hide.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_hideable</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHideable</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> hideable;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets whether this bottom sheet should skip the collapsed state when it is being hidden after it</span><span class="hljs-comment">     * is expanded once. Setting this to true has no effect unless the sheet is hideable.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> skipCollapsed True if the bottom sheet should skip the collapsed state.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_skipCollapsed</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkipCollapsed</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> skipCollapsed)</span> </span>&#123;        <span class="hljs-keyword">this</span>.skipCollapsed = skipCollapsed;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets whether this bottom sheet should skip the collapsed state when it is being hidden after it</span><span class="hljs-comment">     * is expanded once.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Whether the bottom sheet should skip the collapsed state.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref</span><span class="hljs-comment">     * com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_skipCollapsed</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getSkipCollapsed</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> skipCollapsed;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets whether this bottom sheet is can be collapsed/expanded by dragging. Note: When disabling</span><span class="hljs-comment">     * dragging, an app will require to implement a custom way to expand/collapse the bottom sheet</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> draggable &#123;<span class="hljs-doctag">@code</span> false&#125; to prevent dragging the sheet to collapse and expand</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_draggable</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDraggable</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> draggable)</span> </span>&#123;        <span class="hljs-keyword">this</span>.draggable = draggable;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDraggable</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> draggable;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets save flags to be preserved in bottomsheet on configuration change.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> flags bitwise int of &#123;<span class="hljs-doctag">@link</span> #SAVE_PEEK_HEIGHT&#125;, &#123;<span class="hljs-doctag">@link</span> #SAVE_FIT_TO_CONTENTS&#125;, &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">     *              #SAVE_HIDEABLE&#125;, &#123;<span class="hljs-doctag">@link</span> #SAVE_SKIP_COLLAPSED&#125;, &#123;<span class="hljs-doctag">@link</span> #SAVE_ALL&#125; and &#123;<span class="hljs-doctag">@link</span> #SAVE_NONE&#125;.</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_saveFlags</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #getSaveFlags()</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSaveFlags</span><span class="hljs-params">(<span class="hljs-meta">@SaveFlags</span> <span class="hljs-keyword">int</span> flags)</span> </span>&#123;        <span class="hljs-keyword">this</span>.saveFlags = flags;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns the save flags.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref com.google.android.material.R.styleable#BottomSheetBehavior_Layout_behavior_saveFlags</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #setSaveFlags(int)</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SaveFlags</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSaveFlags</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.saveFlags;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets a callback to be notified of bottom sheet events.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> callback The callback to notify when bottom sheet events occur.</span><span class="hljs-comment">     * <span class="hljs-doctag">@deprecated</span> use &#123;<span class="hljs-doctag">@link</span> #addBottomSheetCallback(BottomSheetCallback)&#125; and &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">     * #removeBottomSheetCallback(BottomSheetCallback)&#125; instead</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Deprecated</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBottomSheetCallback</span><span class="hljs-params">(BottomSheetCallback callback)</span> </span>&#123;        Log.w(                TAG,                <span class="hljs-string">&quot;BottomSheetBehavior now supports multiple callbacks. `setBottomSheetCallback()` removes&quot;</span>                        + <span class="hljs-string">&quot; all existing callbacks, including ones set internally by library authors, which&quot;</span>                        + <span class="hljs-string">&quot; may result in unintended behavior. This may change in the future. Please use&quot;</span>                        + <span class="hljs-string">&quot; `addBottomSheetCallback()` and `removeBottomSheetCallback()` instead to set your&quot;</span>                        + <span class="hljs-string">&quot; own callbacks.&quot;</span>);        callbacks.clear();        <span class="hljs-keyword">if</span> (callback != <span class="hljs-keyword">null</span>) &#123;            callbacks.add(callback);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Adds a callback to be notified of bottom sheet events.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> callback The callback to notify when bottom sheet events occur.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBottomSheetCallback</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> BottomSheetCallback callback)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!callbacks.contains(callback)) &#123;            callbacks.add(callback);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Removes a previously added callback.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> callback The callback to remove.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBottomSheetCallback</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> BottomSheetCallback callback)</span> </span>&#123;        callbacks.remove(callback);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets the state of the bottom sheet. The bottom sheet will transition to that state with</span><span class="hljs-comment">     * animation.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> state One of &#123;<span class="hljs-doctag">@link</span> #STATE_COLLAPSED&#125;, &#123;<span class="hljs-doctag">@link</span> #STATE_EXPANDED&#125;, &#123;<span class="hljs-doctag">@link</span> #STATE_HIDDEN&#125;,</span><span class="hljs-comment">     *              or &#123;<span class="hljs-doctag">@link</span> #STATE_HALF_EXPANDED&#125;.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-meta">@State</span> <span class="hljs-keyword">int</span> state)</span> </span>&#123;        <span class="hljs-keyword">if</span> (state == <span class="hljs-keyword">this</span>.state) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (viewRef == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// The view is not laid out yet; modify mState and let onLayoutChild handle it later</span>            <span class="hljs-keyword">if</span> (state == STATE_COLLAPSED                    || state == STATE_EXPANDED                    || state == STATE_HALF_EXPANDED                    || (hideable &amp;&amp; state == STATE_HIDDEN)) &#123;                <span class="hljs-keyword">this</span>.state = state;            &#125;            <span class="hljs-keyword">return</span>;        &#125;        settleToStatePendingLayout(state);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets whether this bottom sheet should adjust it&#x27;s position based on the system gesture area on</span><span class="hljs-comment">     * Android Q and above.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;Note: the bottom sheet will only adjust it&#x27;s position if it would be unable to be scrolled</span><span class="hljs-comment">     * upwards because the peekHeight is less than the gesture inset margins,(because that would cause</span><span class="hljs-comment">     * a gesture conflict), gesture navigation is enabled, and this &#123;<span class="hljs-doctag">@code</span> ignoreGestureInsetBottom&#125;</span><span class="hljs-comment">     * flag is false.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGestureInsetBottomIgnored</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> gestureInsetBottomIgnored)</span> </span>&#123;        <span class="hljs-keyword">this</span>.gestureInsetBottomIgnored = gestureInsetBottomIgnored;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns whether this bottom sheet should adjust it&#x27;s position based on the system gesture area.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isGestureInsetBottomIgnored</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> gestureInsetBottomIgnored;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">settleToStatePendingLayout</span><span class="hljs-params">(<span class="hljs-meta">@State</span> <span class="hljs-keyword">int</span> state)</span> </span>&#123;        <span class="hljs-keyword">final</span> V child = viewRef.get();        <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// Start the animation; wait until a pending layout if there is one.</span>        ViewParent parent = child.getParent();        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span> &amp;&amp; parent.isLayoutRequested() &amp;&amp; ViewCompat.isAttachedToWindow(child)) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> finalState = state;            child.post(                    <span class="hljs-keyword">new</span> Runnable() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                            settleToState(child, finalState);                        &#125;                    &#125;);        &#125; <span class="hljs-keyword">else</span> &#123;            settleToState(child, state);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Gets the current state of the bottom sheet.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> One of &#123;<span class="hljs-doctag">@link</span> #STATE_EXPANDED&#125;, &#123;<span class="hljs-doctag">@link</span> #STATE_HALF_EXPANDED&#125;, &#123;<span class="hljs-doctag">@link</span> #STATE_COLLAPSED&#125;,</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> #STATE_DRAGGING&#125;, &#123;<span class="hljs-doctag">@link</span> #STATE_SETTLING&#125;, or &#123;<span class="hljs-doctag">@link</span> #STATE_HALF_EXPANDED&#125;.</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@State</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> state;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setStateInternal</span><span class="hljs-params">(<span class="hljs-meta">@State</span> <span class="hljs-keyword">int</span> state)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state == state) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">this</span>.state = state;        <span class="hljs-keyword">if</span> (viewRef == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        View bottomSheet = viewRef.get();        <span class="hljs-keyword">if</span> (bottomSheet == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (state == STATE_EXPANDED) &#123;            updateImportantForAccessibility(<span class="hljs-keyword">true</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == STATE_HALF_EXPANDED || state == STATE_HIDDEN || state == STATE_COLLAPSED) &#123;            updateImportantForAccessibility(<span class="hljs-keyword">false</span>);        &#125;        updateDrawableForTargetState(state);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; callbacks.size(); i++) &#123;            callbacks.get(i).onStateChanged(bottomSheet, state);        &#125;        updateAccessibilityActions();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateDrawableForTargetState</span><span class="hljs-params">(<span class="hljs-meta">@State</span> <span class="hljs-keyword">int</span> state)</span> </span>&#123;        <span class="hljs-keyword">if</span> (state == STATE_SETTLING) &#123;            <span class="hljs-comment">// Special case: we want to know which state we&#x27;re settling to, so wait for another call.</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">boolean</span> expand = state == STATE_EXPANDED;        <span class="hljs-keyword">if</span> (isShapeExpanded != expand) &#123;            isShapeExpanded = expand;            <span class="hljs-keyword">if</span> (materialShapeDrawable != <span class="hljs-keyword">null</span> &amp;&amp; interpolatorAnimator != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (interpolatorAnimator.isRunning()) &#123;                    interpolatorAnimator.reverse();                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">float</span> to = expand ? <span class="hljs-number">0f</span> : <span class="hljs-number">1f</span>;                    <span class="hljs-keyword">float</span> from = <span class="hljs-number">1f</span> - to;                    interpolatorAnimator.setFloatValues(from, to);                    interpolatorAnimator.start();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculatePeekHeight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (peekHeightAuto) &#123;            <span class="hljs-keyword">return</span> Math.max(peekHeightMin, parentHeight - parentWidth * <span class="hljs-number">9</span> / <span class="hljs-number">16</span>);        &#125;        <span class="hljs-keyword">return</span> peekHeight;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculateCollapsedOffset</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> peek = calculatePeekHeight();        <span class="hljs-keyword">if</span> (fitToContents) &#123;            collapsedOffset = Math.max(parentHeight - peek, fitToContentsOffset);        &#125; <span class="hljs-keyword">else</span> &#123;            collapsedOffset = parentHeight - peek;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculateHalfExpandedOffset</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.halfExpandedOffset = (<span class="hljs-keyword">int</span>) (parentHeight * (<span class="hljs-number">1</span> - halfExpandedRatio));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;        activePointerId = ViewDragHelper.INVALID_POINTER;        <span class="hljs-keyword">if</span> (velocityTracker != <span class="hljs-keyword">null</span>) &#123;            velocityTracker.recycle();            velocityTracker = <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restoreOptionalState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SavedState ss)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.saveFlags == SAVE_NONE) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.saveFlags == SAVE_ALL || (<span class="hljs-keyword">this</span>.saveFlags &amp; SAVE_PEEK_HEIGHT) == SAVE_PEEK_HEIGHT) &#123;            <span class="hljs-keyword">this</span>.peekHeight = ss.peekHeight;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.saveFlags == SAVE_ALL                || (<span class="hljs-keyword">this</span>.saveFlags &amp; SAVE_FIT_TO_CONTENTS) == SAVE_FIT_TO_CONTENTS) &#123;            <span class="hljs-keyword">this</span>.fitToContents = ss.fitToContents;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.saveFlags == SAVE_ALL || (<span class="hljs-keyword">this</span>.saveFlags &amp; SAVE_HIDEABLE) == SAVE_HIDEABLE) &#123;            <span class="hljs-keyword">this</span>.hideable = ss.hideable;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.saveFlags == SAVE_ALL                || (<span class="hljs-keyword">this</span>.saveFlags &amp; SAVE_SKIP_COLLAPSED) == SAVE_SKIP_COLLAPSED) &#123;            <span class="hljs-keyword">this</span>.skipCollapsed = ss.skipCollapsed;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldHide</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-keyword">float</span> yvel)</span> </span>&#123;        <span class="hljs-keyword">if</span> (skipCollapsed) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span> (child.getTop() &lt; collapsedOffset) &#123;            <span class="hljs-comment">// It should not hide, but collapse.</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> peek = calculatePeekHeight();        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> newTop = child.getTop() + yvel * HIDE_FRICTION;        <span class="hljs-keyword">return</span> Math.abs(newTop - collapsedOffset) / (<span class="hljs-keyword">float</span>) peek &gt; HIDE_THRESHOLD;    &#125;    <span class="hljs-comment">//针对viewpager联动</span>    <span class="hljs-keyword">boolean</span> isFirstFind = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//第一次寻找联动View，为viewPager添加滑动监听</span>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Boolean&gt; isScrollViewOnTopMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">//关联页数与能否滑动flag的Map</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentPagePosition = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前ViewPager的页数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCurrentScrollViewOnTop</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> scrollViewOnTop)</span> </span>&#123;        isScrollViewOnTopMap.put(currentPagePosition, scrollViewOnTop);        Log.d(<span class="hljs-string">&quot;~~~~~~~~~&quot;</span>,isScrollViewOnTopMap.toString());        notifyScrollView();    &#125;    <span class="hljs-keyword">private</span> View globalView;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyScrollView</span><span class="hljs-params">()</span> </span>&#123;        nestedScrollingChildRef = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(findScrollingChild(globalView));    &#125;    <span class="hljs-meta">@Nullable</span>    <span class="hljs-meta">@VisibleForTesting</span>    <span class="hljs-function">View <span class="hljs-title">findScrollingChild</span><span class="hljs-params">(View view)</span> </span>&#123;        <span class="hljs-keyword">if</span>(view==<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        globalView = view;        <span class="hljs-keyword">boolean</span> b = isScrollViewOnTopMap.getOrDefault(currentPagePosition,<span class="hljs-keyword">false</span> );        <span class="hljs-keyword">if</span> (b) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (ViewCompat.isNestedScrollingEnabled(view)) &#123;            <span class="hljs-keyword">return</span> view;        &#125;        <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> ViewPager) &#123;            ViewPager viewPager = (ViewPager) view;            <span class="hljs-keyword">if</span> (isFirstFind) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Objects.requireNonNull(viewPager.getAdapter()).getCount(); i++) &#123;                    isScrollViewOnTopMap.put(i,<span class="hljs-keyword">true</span>);                &#125;                viewPager.addOnPageChangeListener(<span class="hljs-keyword">new</span> ViewPager.OnPageChangeListener() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageScrolled</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">float</span> positionOffset, <span class="hljs-keyword">int</span> positionOffsetPixels)</span> </span>&#123;                        currentPagePosition = position;                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageScrollStateChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>&#123;                    &#125;                &#125;);                isFirstFind = <span class="hljs-keyword">false</span>;            &#125;            View currentViewPagerChild = ViewPagerUtils.getCurrentView(viewPager);            View scrollingChild = findScrollingChild(currentViewPagerChild);            <span class="hljs-keyword">if</span> (scrollingChild != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> scrollingChild;            &#125;            <span class="hljs-keyword">return</span> currentViewPagerChild;        &#125;        <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> ViewGroup) &#123;            ViewGroup group = (ViewGroup) view;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, count = group.getChildCount(); i &lt; count; i++) &#123;                View scrollingChild = findScrollingChild(group.getChildAt(i));                <span class="hljs-keyword">if</span> (scrollingChild != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> scrollingChild;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createMaterialShapeDrawable</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> Context context, AttributeSet attrs, <span class="hljs-keyword">boolean</span> hasBackgroundTint)</span> </span>&#123;        <span class="hljs-keyword">this</span>.createMaterialShapeDrawable(context, attrs, hasBackgroundTint, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createMaterialShapeDrawable</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> Context context,</span></span><span class="hljs-function"><span class="hljs-params">            AttributeSet attrs,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> hasBackgroundTint,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> ColorStateList bottomSheetColor)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.shapeThemingEnabled) &#123;            <span class="hljs-keyword">this</span>.shapeAppearanceModelDefault =                    ShapeAppearanceModel.builder(context, attrs, R.attr.bottomSheetStyle, DEF_STYLE_RES)                            .build();            <span class="hljs-keyword">this</span>.materialShapeDrawable = <span class="hljs-keyword">new</span> MaterialShapeDrawable(shapeAppearanceModelDefault);            <span class="hljs-keyword">this</span>.materialShapeDrawable.initializeElevationOverlay(context);            <span class="hljs-keyword">if</span> (hasBackgroundTint &amp;&amp; bottomSheetColor != <span class="hljs-keyword">null</span>) &#123;                materialShapeDrawable.setFillColor(bottomSheetColor);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// If the tint isn&#x27;t set, use the theme default background color.</span>                TypedValue defaultColor = <span class="hljs-keyword">new</span> TypedValue();                context.getTheme().resolveAttribute(android.R.attr.colorBackground, defaultColor, <span class="hljs-keyword">true</span>);                materialShapeDrawable.setTint(defaultColor.data);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createShapeValueAnimator</span><span class="hljs-params">()</span> </span>&#123;        interpolatorAnimator = ValueAnimator.ofFloat(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>);        interpolatorAnimator.setDuration(CORNER_ANIMATION_DURATION);        interpolatorAnimator.addUpdateListener(                <span class="hljs-keyword">new</span> AnimatorUpdateListener() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ValueAnimator animation)</span> </span>&#123;                        <span class="hljs-keyword">float</span> value = (<span class="hljs-keyword">float</span>) animation.getAnimatedValue();                        <span class="hljs-keyword">if</span> (materialShapeDrawable != <span class="hljs-keyword">null</span>) &#123;                            materialShapeDrawable.setInterpolation(value);                        &#125;                    &#125;                &#125;);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSystemGestureInsets</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> CoordinatorLayout parent)</span> </span>&#123;        <span class="hljs-keyword">if</span> (VERSION.SDK_INT &gt;= VERSION_CODES.Q &amp;&amp; !isGestureInsetBottomIgnored()) &#123;            WindowInsets windowInsets = parent.getRootWindowInsets();            <span class="hljs-keyword">if</span> (windowInsets != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">int</span> systemMandatoryInsetsBottom = windowInsets.getSystemGestureInsets().bottom;                peekHeight += systemMandatoryInsetsBottom;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getYVelocity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (velocityTracker == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        velocityTracker.computeCurrentVelocity(<span class="hljs-number">1000</span>, maximumVelocity);        <span class="hljs-keyword">return</span> velocityTracker.getYVelocity(activePointerId);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">settleToState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-keyword">int</span> state)</span> </span>&#123;        <span class="hljs-keyword">int</span> top;        <span class="hljs-keyword">if</span> (state == STATE_COLLAPSED) &#123;            top = collapsedOffset;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == STATE_HALF_EXPANDED) &#123;            top = halfExpandedOffset;            <span class="hljs-keyword">if</span> (fitToContents &amp;&amp; top &lt;= fitToContentsOffset) &#123;                <span class="hljs-comment">// Skip to the expanded state if we would scroll past the height of the contents.</span>                state = STATE_EXPANDED;                top = fitToContentsOffset;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == STATE_EXPANDED) &#123;            top = getExpandedOffset();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hideable &amp;&amp; state == STATE_HIDDEN) &#123;            top = parentHeight;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal state argument: &quot;</span> + state);        &#125;        startSettlingAnimation(child, state, top, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startSettlingAnimation</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> state, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">boolean</span> settleFromViewDragHelper)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> startedSettling =                settleFromViewDragHelper                        ? viewDragHelper.settleCapturedViewAt(child.getLeft(), top)                        : viewDragHelper.smoothSlideViewTo(child, child.getLeft(), top);        <span class="hljs-keyword">if</span> (startedSettling) &#123;            setStateInternal(STATE_SETTLING);            <span class="hljs-comment">// STATE_SETTLING won&#x27;t animate the material shape, so do that here with the target state.</span>            updateDrawableForTargetState(state);            <span class="hljs-keyword">if</span> (settleRunnable == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// If the singleton SettleRunnable instance has not been instantiated, create it.</span>                settleRunnable = <span class="hljs-keyword">new</span> SettleRunnable(child, state);            &#125;            <span class="hljs-comment">// If the SettleRunnable has not been posted, post it with the correct state.</span>            <span class="hljs-keyword">if</span> (settleRunnable.isPosted == <span class="hljs-keyword">false</span>) &#123;                settleRunnable.targetState = state;                ViewCompat.postOnAnimation(child, settleRunnable);                settleRunnable.isPosted = <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// Otherwise, if it has been posted, just update the target state.</span>                settleRunnable.targetState = state;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            setStateInternal(state);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ViewDragHelper.Callback dragCallback =            <span class="hljs-keyword">new</span> ViewDragHelper.Callback() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryCaptureView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-keyword">int</span> pointerId)</span> </span>&#123;                    <span class="hljs-keyword">if</span> (state == STATE_DRAGGING) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                    &#125;                    <span class="hljs-keyword">if</span> (touchingScrollingChild) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                    &#125;                    <span class="hljs-keyword">if</span> (state == STATE_EXPANDED &amp;&amp; activePointerId == pointerId) &#123;                        View scroll = nestedScrollingChildRef != <span class="hljs-keyword">null</span> ? nestedScrollingChildRef.get() : <span class="hljs-keyword">null</span>;                        <span class="hljs-keyword">if</span> (scroll != <span class="hljs-keyword">null</span> &amp;&amp; scroll.canScrollVertically(-<span class="hljs-number">1</span>)) &#123;                            <span class="hljs-comment">// Let the content scroll up</span>                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                        &#125;                    &#125;                    <span class="hljs-keyword">return</span> viewRef != <span class="hljs-keyword">null</span> &amp;&amp; viewRef.get() == child;                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewPositionChanged</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-meta">@NonNull</span> View changedView, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy)</span> </span>&#123;                    dispatchOnSlide(top);                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDragStateChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>&#123;                    <span class="hljs-keyword">if</span> (state == ViewDragHelper.STATE_DRAGGING &amp;&amp; draggable) &#123;                        setStateInternal(STATE_DRAGGING);                    &#125;                &#125;                <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releasedLow</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child)</span> </span>&#123;                    <span class="hljs-comment">// Needs to be at least half way to the bottom.</span>                    <span class="hljs-keyword">return</span> child.getTop() &gt; (parentHeight + getExpandedOffset()) / <span class="hljs-number">2</span>;                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewReleased</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View releasedChild, <span class="hljs-keyword">float</span> xvel, <span class="hljs-keyword">float</span> yvel)</span> </span>&#123;                    <span class="hljs-keyword">int</span> top;                    <span class="hljs-meta">@State</span> <span class="hljs-keyword">int</span> targetState;                    <span class="hljs-keyword">if</span> (yvel &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Moving up</span>                        <span class="hljs-keyword">if</span> (fitToContents) &#123;                            top = fitToContentsOffset;                            targetState = STATE_EXPANDED;                        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">int</span> currentTop = releasedChild.getTop();                            <span class="hljs-keyword">if</span> (currentTop &gt; halfExpandedOffset) &#123;                                top = halfExpandedOffset;                                targetState = STATE_HALF_EXPANDED;                            &#125; <span class="hljs-keyword">else</span> &#123;                                top = expandedOffset;                                targetState = STATE_EXPANDED;                            &#125;                        &#125;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hideable &amp;&amp; shouldHide(releasedChild, yvel)) &#123;                        <span class="hljs-comment">// Hide if the view was either released low or it was a significant vertical swipe</span>                        <span class="hljs-comment">// otherwise settle to closest expanded state.</span>                        <span class="hljs-keyword">if</span> ((Math.abs(xvel) &lt; Math.abs(yvel) &amp;&amp; yvel &gt; SIGNIFICANT_VEL_THRESHOLD)                                || releasedLow(releasedChild)) &#123;                            top = parentHeight;                            targetState = STATE_HIDDEN;                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fitToContents) &#123;                            top = fitToContentsOffset;                            targetState = STATE_EXPANDED;                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Math.abs(releasedChild.getTop() - expandedOffset)                                &lt; Math.abs(releasedChild.getTop() - halfExpandedOffset)) &#123;                            top = expandedOffset;                            targetState = STATE_EXPANDED;                        &#125; <span class="hljs-keyword">else</span> &#123;                            top = halfExpandedOffset;                            targetState = STATE_HALF_EXPANDED;                        &#125;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (yvel == <span class="hljs-number">0.f</span> || Math.abs(xvel) &gt; Math.abs(yvel)) &#123;                        <span class="hljs-comment">// If the Y velocity is 0 or the swipe was mostly horizontal indicated by the X velocity</span>                        <span class="hljs-comment">// being greater than the Y velocity, settle to the nearest correct height.</span>                        <span class="hljs-keyword">int</span> currentTop = releasedChild.getTop();                        <span class="hljs-keyword">if</span> (fitToContents) &#123;                            <span class="hljs-keyword">if</span> (Math.abs(currentTop - fitToContentsOffset)                                    &lt; Math.abs(currentTop - collapsedOffset)) &#123;                                top = fitToContentsOffset;                                targetState = STATE_EXPANDED;                            &#125; <span class="hljs-keyword">else</span> &#123;                                top = collapsedOffset;                                targetState = STATE_COLLAPSED;                            &#125;                        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (currentTop &lt; halfExpandedOffset) &#123;                                <span class="hljs-keyword">if</span> (currentTop &lt; Math.abs(currentTop - collapsedOffset)) &#123;                                    top = expandedOffset;                                    targetState = STATE_EXPANDED;                                &#125; <span class="hljs-keyword">else</span> &#123;                                    top = halfExpandedOffset;                                    targetState = STATE_HALF_EXPANDED;                                &#125;                            &#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-keyword">if</span> (Math.abs(currentTop - halfExpandedOffset)                                        &lt; Math.abs(currentTop - collapsedOffset)) &#123;                                    top = halfExpandedOffset;                                    targetState = STATE_HALF_EXPANDED;                                &#125; <span class="hljs-keyword">else</span> &#123;                                    top = collapsedOffset;                                    targetState = STATE_COLLAPSED;                                &#125;                            &#125;                        &#125;                    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Moving Down</span>                        <span class="hljs-keyword">if</span> (fitToContents) &#123;                            top = collapsedOffset;                            targetState = STATE_COLLAPSED;                        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-comment">// Settle to the nearest correct height.</span>                            <span class="hljs-keyword">int</span> currentTop = releasedChild.getTop();                            <span class="hljs-keyword">if</span> (Math.abs(currentTop - halfExpandedOffset)                                    &lt; Math.abs(currentTop - collapsedOffset)) &#123;                                top = halfExpandedOffset;                                targetState = STATE_HALF_EXPANDED;                            &#125; <span class="hljs-keyword">else</span> &#123;                                top = collapsedOffset;                                targetState = STATE_COLLAPSED;                            &#125;                        &#125;                    &#125;                    startSettlingAnimation(releasedChild, targetState, top, <span class="hljs-keyword">true</span>);                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">clampViewPositionVertical</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> dy)</span> </span>&#123;                    <span class="hljs-keyword">return</span> MathUtils.clamp(                            top, getExpandedOffset(), hideable ? parentHeight : collapsedOffset);                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">clampViewPositionHorizontal</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> dx)</span> </span>&#123;                    <span class="hljs-keyword">return</span> child.getLeft();                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getViewVerticalDragRange</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child)</span> </span>&#123;                    <span class="hljs-keyword">if</span> (hideable) &#123;                        <span class="hljs-keyword">return</span> parentHeight;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">return</span> collapsedOffset;                    &#125;                &#125;            &#125;;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchOnSlide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> top)</span> </span>&#123;        View bottomSheet = viewRef.get();        <span class="hljs-keyword">if</span> (bottomSheet != <span class="hljs-keyword">null</span> &amp;&amp; !callbacks.isEmpty()) &#123;            <span class="hljs-keyword">float</span> slideOffset =                    (top &gt; collapsedOffset || collapsedOffset == getExpandedOffset())                            ? (<span class="hljs-keyword">float</span>) (collapsedOffset - top) / (parentHeight - collapsedOffset)                            : (<span class="hljs-keyword">float</span>) (collapsedOffset - top) / (collapsedOffset - getExpandedOffset());            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; callbacks.size(); i++) &#123;                callbacks.get(i).onSlide(bottomSheet, slideOffset);            &#125;        &#125;    &#125;    <span class="hljs-meta">@VisibleForTesting</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPeekHeightMin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> peekHeightMin;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Disables the shaped corner &#123;<span class="hljs-doctag">@link</span> ShapeAppearanceModel&#125; interpolation transition animations.</span><span class="hljs-comment">     * Will have no effect unless the sheet utilizes a &#123;<span class="hljs-doctag">@link</span> MaterialShapeDrawable&#125; with set shape</span><span class="hljs-comment">     * theming properties. Only For use in UI testing.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@hide</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@RestrictTo(LIBRARY_GROUP)</span>    <span class="hljs-meta">@VisibleForTesting</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disableShapeAnimations</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Sets the shape value animator to null, prevents animations from occuring during testing.</span>        interpolatorAnimator = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SettleRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> View view;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPosted;        <span class="hljs-meta">@State</span>        <span class="hljs-keyword">int</span> targetState;        SettleRunnable(View view, <span class="hljs-meta">@State</span> <span class="hljs-keyword">int</span> targetState) &#123;            <span class="hljs-keyword">this</span>.view = view;            <span class="hljs-keyword">this</span>.targetState = targetState;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (viewDragHelper != <span class="hljs-keyword">null</span> &amp;&amp; viewDragHelper.continueSettling(<span class="hljs-keyword">true</span>)) &#123;                ViewCompat.postOnAnimation(view, <span class="hljs-keyword">this</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                setStateInternal(targetState);            &#125;            <span class="hljs-keyword">this</span>.isPosted = <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * State persisted across instances</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavedState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbsSavedState</span> </span>&#123;        <span class="hljs-meta">@State</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> state;        <span class="hljs-keyword">int</span> peekHeight;        <span class="hljs-keyword">boolean</span> fitToContents;        <span class="hljs-keyword">boolean</span> hideable;        <span class="hljs-keyword">boolean</span> skipCollapsed;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavedState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Parcel source)</span> </span>&#123;            <span class="hljs-keyword">this</span>(source, <span class="hljs-keyword">null</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavedState</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Parcel source, ClassLoader loader)</span> </span>&#123;            <span class="hljs-keyword">super</span>(source, loader);            <span class="hljs-comment">//noinspection ResourceType</span>            state = source.readInt();            peekHeight = source.readInt();            fitToContents = source.readInt() == <span class="hljs-number">1</span>;            hideable = source.readInt() == <span class="hljs-number">1</span>;            skipCollapsed = source.readInt() == <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavedState</span><span class="hljs-params">(Parcelable superState, <span class="hljs-meta">@NonNull</span> MyViewPagerBottomSheetBehavior&lt;?&gt; behavior)</span> </span>&#123;            <span class="hljs-keyword">super</span>(superState);            <span class="hljs-keyword">this</span>.state = behavior.getState();            <span class="hljs-keyword">this</span>.peekHeight = behavior.getPeekHeight();            <span class="hljs-keyword">this</span>.fitToContents = behavior.isFitToContents();            <span class="hljs-keyword">this</span>.hideable = behavior.isHideable();            <span class="hljs-keyword">this</span>.skipCollapsed = behavior.getSkipCollapsed();        &#125;        <span class="hljs-meta">@Deprecated</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavedState</span><span class="hljs-params">(Parcelable superstate, <span class="hljs-keyword">int</span> state)</span> </span>&#123;            <span class="hljs-keyword">super</span>(superstate);            <span class="hljs-keyword">this</span>.state = state;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeToParcel</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Parcel out, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;            <span class="hljs-keyword">super</span>.writeToParcel(out, flags);            out.writeInt(state);            out.writeInt(peekHeight);            out.writeInt(fitToContents ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);            out.writeInt(hideable ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);            out.writeInt(skipCollapsed ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Creator&lt;SavedState&gt; CREATOR =                <span class="hljs-keyword">new</span> ClassLoaderCreator&lt;SavedState&gt;() &#123;                    <span class="hljs-meta">@NonNull</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> SavedState <span class="hljs-title">createFromParcel</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Parcel in, ClassLoader loader)</span> </span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SavedState(in, loader);                    &#125;                    <span class="hljs-meta">@Nullable</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> SavedState <span class="hljs-title">createFromParcel</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Parcel in)</span> </span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SavedState(in, <span class="hljs-keyword">null</span>);                    &#125;                    <span class="hljs-meta">@NonNull</span>                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> SavedState[] newArray(<span class="hljs-keyword">int</span> size) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SavedState[size];                    &#125;                &#125;;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * A utility function to get the &#123;<span class="hljs-doctag">@link</span> BottomSheetBehavior&#125; associated with the &#123;<span class="hljs-doctag">@code</span> view&#125;.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> view The &#123;<span class="hljs-doctag">@link</span> View&#125; with &#123;<span class="hljs-doctag">@link</span> BottomSheetBehavior&#125;.</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The &#123;<span class="hljs-doctag">@link</span> BottomSheetBehavior&#125; associated with the &#123;<span class="hljs-doctag">@code</span> view&#125;.</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V extends View&gt; <span class="hljs-function">MyViewPagerBottomSheetBehavior&lt;V&gt; <span class="hljs-title">from</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> V view)</span> </span>&#123;        ViewGroup.LayoutParams params = view.getLayoutParams();        <span class="hljs-keyword">if</span> (!(params <span class="hljs-keyword">instanceof</span> CoordinatorLayout.LayoutParams)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;The view is not a child of CoordinatorLayout&quot;</span>);        &#125;        CoordinatorLayout.Behavior&lt;?&gt; behavior =                ((CoordinatorLayout.LayoutParams) params).getBehavior();        <span class="hljs-keyword">if</span> (!(behavior <span class="hljs-keyword">instanceof</span> MyViewPagerBottomSheetBehavior)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;The view is not associated with BottomSheetBehavior&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> (MyViewPagerBottomSheetBehavior&lt;V&gt;) behavior;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Sets whether the BottomSheet should update the accessibility status of its &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">     * CoordinatorLayout&#125; siblings when expanded.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * &lt;p&gt;Set this to true if the expanded state of the sheet blocks access to siblings (e.g., when</span><span class="hljs-comment">     * the sheet expands over the full screen).</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpdateImportantForAccessibilityOnSiblings</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> updateImportantForAccessibilityOnSiblings)</span> </span>&#123;        <span class="hljs-keyword">this</span>.updateImportantForAccessibilityOnSiblings = updateImportantForAccessibilityOnSiblings;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateImportantForAccessibility</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> expanded)</span> </span>&#123;        <span class="hljs-keyword">if</span> (viewRef == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        ViewParent viewParent = viewRef.get().getParent();        <span class="hljs-keyword">if</span> (!(viewParent <span class="hljs-keyword">instanceof</span> CoordinatorLayout)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        CoordinatorLayout parent = (CoordinatorLayout) viewParent;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childCount = parent.getChildCount();        <span class="hljs-keyword">if</span> ((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &amp;&amp; expanded) &#123;            <span class="hljs-keyword">if</span> (importantForAccessibilityMap == <span class="hljs-keyword">null</span>) &#123;                importantForAccessibilityMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(childCount);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// The important for accessibility values of the child views have been saved already.</span>                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;            <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);            <span class="hljs-keyword">if</span> (child == viewRef.get()) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (expanded) &#123;                <span class="hljs-comment">// Saves the important for accessibility value of the child view.</span>                <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;                    importantForAccessibilityMap.put(child, child.getImportantForAccessibility());                &#125;                <span class="hljs-keyword">if</span> (updateImportantForAccessibilityOnSiblings) &#123;                    ViewCompat.setImportantForAccessibility(                            child, ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS);                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (updateImportantForAccessibilityOnSiblings                        &amp;&amp; importantForAccessibilityMap != <span class="hljs-keyword">null</span>                        &amp;&amp; importantForAccessibilityMap.containsKey(child)) &#123;                    <span class="hljs-comment">// Restores the original important for accessibility value of the child view.</span>                    ViewCompat.setImportantForAccessibility(child, importantForAccessibilityMap.get(child));                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (!expanded) &#123;            importantForAccessibilityMap = <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAccessibilityActions</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (viewRef == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        V child = viewRef.get();        <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        ViewCompat.removeAccessibilityAction(child, AccessibilityNodeInfoCompat.ACTION_COLLAPSE);        ViewCompat.removeAccessibilityAction(child, AccessibilityNodeInfoCompat.ACTION_EXPAND);        ViewCompat.removeAccessibilityAction(child, AccessibilityNodeInfoCompat.ACTION_DISMISS);        <span class="hljs-keyword">if</span> (hideable &amp;&amp; state != STATE_HIDDEN) &#123;            addAccessibilityActionForState(child, AccessibilityActionCompat.ACTION_DISMISS, STATE_HIDDEN);        &#125;        <span class="hljs-keyword">switch</span> (state) &#123;            <span class="hljs-keyword">case</span> STATE_EXPANDED: &#123;                <span class="hljs-keyword">int</span> nextState = fitToContents ? STATE_COLLAPSED : STATE_HALF_EXPANDED;                addAccessibilityActionForState(                        child, AccessibilityActionCompat.ACTION_COLLAPSE, nextState);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">case</span> STATE_HALF_EXPANDED: &#123;                addAccessibilityActionForState(                        child, AccessibilityActionCompat.ACTION_COLLAPSE, STATE_COLLAPSED);                addAccessibilityActionForState(                        child, AccessibilityActionCompat.ACTION_EXPAND, STATE_EXPANDED);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">case</span> STATE_COLLAPSED: &#123;                <span class="hljs-keyword">int</span> nextState = fitToContents ? STATE_EXPANDED : STATE_HALF_EXPANDED;                addAccessibilityActionForState(child, AccessibilityActionCompat.ACTION_EXPAND, nextState);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">default</span>: <span class="hljs-comment">// fall out</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAccessibilityActionForState</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            V child, AccessibilityActionCompat action, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> state)</span> </span>&#123;        ViewCompat.replaceAccessibilityAction(                child,                action,                <span class="hljs-keyword">null</span>,                <span class="hljs-keyword">new</span> AccessibilityViewCommand() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">perform</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, <span class="hljs-meta">@Nullable</span> CommandArguments arguments)</span> </span>&#123;                        setState(state);                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                    &#125;                &#125;);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高效加载BitMap</title>
    <link href="/Blog/2020/11/27/%E9%AB%98%E6%95%88%E5%8A%A0%E8%BD%BDBitMap/"/>
    <url>/Blog/2020/11/27/%E9%AB%98%E6%95%88%E5%8A%A0%E8%BD%BDBitMap/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在Android加载图片时，我们常常使用BitMap，但由于Android对单个应用施加的内存限制，常导致我们加载BitMap时容易出现内存泄漏并导致：java.lang.OutofMemoryError:bitmap size exceedsVM budget</p></blockquote><p>##如何解决？</p><ul><li>高效、按需加载图片</li></ul><p>开始之前，先对BitMap的加载做一个简单回顾（介绍）</p><blockquote><p>BitMap在Android中指的是一张图片，可以是png等任何常见的图片格式<br>BitMapFactory为我们提供了4类加载方法</p></blockquote><ul><li>decodeFile 从文件系统加载</li><li>decodeResource 从资源加载</li><li>decodeStream 从输入流加载</li><li>decodeByteArray 从字节数组加载<br>##采样率 <code>inSampleSize</code><blockquote><p>很多时候，ImageView本身加载不完一个图片的原始大小，于是我们加载整张图片就是在浪费资源。优化方案就是通过更改 BitmapFactory.Options.inSampleSize （采样率）对图片进行采样缩放，将缩放后的图片展示在ImageView上。</p></blockquote></li></ul><p>当inSampleSize为1时，采样后的图片大小为原始图片大小（不变）；<br>当inSampleSize大于1，如 2 时，采样后的图片宽高均为原来的 1/2 。像素数自然变为原来了 1/4，自然其内存占用也为原来的 1/4<br>####举个栗子<br>一张1024 * 1024像素的图片，采用ARGB8888格式存储，内存占有率就为1024 * 1024 * 4(4MB)，如果将 inSampleSize 调整为2，采样后的图片像素变为 512 * 512，内存变为 512 * 512 * 4（1MB）<br>发现：（像素、内存占用）缩放比例均变为原来的 <code>1/(inSampleSize^2)</code><br>另外 </p><p><strong>官方指出：inSampleSize的取值应为 2 的指数，如果传的不是 2 的指数，系统将向下选择一个最近的2的指数作值（实验证明：当作建议即可）</strong></p><p>###步骤</p><ol><li><p>将BitmapFactory.Options的 <code>inJustDecodeBounds</code> 参数设置为true并加载图片</p></li><li><p>从BitmapFactory.options中取出图片的原始宽高信息，对应 <code>outWidth</code> 和 <code>outHeight</code></p></li><li><p>根据采样率规则并结合目标View所需大小计算出采样率 <code>inSampleSize</code></p></li><li><p>将BitmapFactory.options 的 <code>inJustDecodeBounds</code> 设置为false，然后重新加载图片</p></li></ol><p>  ####代码</p><pre><code class="hljs reasonml">    public static Bitmap decode<span class="hljs-constructor">SampleBitmapFromResource(Resources <span class="hljs-params">res</span>, <span class="hljs-params">int</span> <span class="hljs-params">resId</span>, <span class="hljs-params">int</span> <span class="hljs-params">reqWidth</span>, <span class="hljs-params">int</span> <span class="hljs-params">reqHeight</span>)</span> &#123;        final BitmapFactory.Options options = <span class="hljs-keyword">new</span> BitmapFactory.<span class="hljs-constructor">Options()</span>;        options.inJustDecodeBounds = <span class="hljs-literal">true</span>;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BitmapFactory</span>.</span></span>decode<span class="hljs-constructor">Resource(<span class="hljs-params">res</span>, <span class="hljs-params">resId</span>, <span class="hljs-params">options</span>)</span>;        <span class="hljs-comment">//根据目标尺寸计算采样率</span>        options.inSampleSize = calculate<span class="hljs-constructor">InSampleSize(<span class="hljs-params">options</span>, <span class="hljs-params">reqWidth</span>, <span class="hljs-params">reqHeight</span>)</span>;        options.inJustDecodeBounds = <span class="hljs-literal">false</span>;        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BitmapFactory</span>.</span></span>decode<span class="hljs-constructor">Resource(<span class="hljs-params">res</span>, <span class="hljs-params">resId</span>, <span class="hljs-params">options</span>)</span>;    &#125;    <span class="hljs-keyword">private</span> static <span class="hljs-built_in">int</span> calculate<span class="hljs-constructor">InSampleSize(BitmapFactory.Options <span class="hljs-params">options</span>, <span class="hljs-params">int</span> <span class="hljs-params">reqWidth</span>, <span class="hljs-params">int</span> <span class="hljs-params">reqHeight</span>)</span> &#123;        final <span class="hljs-built_in">int</span> height = options.outHeight;        final <span class="hljs-built_in">int</span> width = options.outWidth;        <span class="hljs-built_in">int</span> inSampleSize = <span class="hljs-number">1</span>;        <span class="hljs-comment">//长宽都大于目标时，提高采样率（缩小图片）</span>        <span class="hljs-keyword">if</span> (height &gt; reqHeight<span class="hljs-operator"> || </span>width &gt; reqWidth) &#123;            final <span class="hljs-built_in">int</span> halfHeight = height<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;            final <span class="hljs-built_in">int</span> halfWidth = width<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;            <span class="hljs-comment">//不停缩放，直到长宽中任意一个再缩就小于目标为止</span>            <span class="hljs-keyword">while</span> ((halfHeight<span class="hljs-operator"> / </span>inSampleSize) &gt;= reqHeight<span class="hljs-operator">                    &amp;&amp; </span>(halfWidth<span class="hljs-operator"> / </span>inSampleSize) &gt;= reqWidth) &#123;                inSampleSize *= <span class="hljs-number">2</span>;            &#125;        &#125;        return inSampleSize;    &#125;<span class="hljs-comment">//使用</span>mImageView.set<span class="hljs-constructor">ImageBitmap(<span class="hljs-params">decodeSampleBitmapFromResource</span>(,R.<span class="hljs-params">id</span>.<span class="hljs-params">myimage</span>,100,100)</span>);</code></pre><blockquote><p>注意：当inJustDecodeBounds为true时，BitmapFactory只会解析图的原始宽/高信息，并不会真的获取图片，所以这个操作很轻量。另外这时候获取到的宽高信息与图片的位置以及程序运行的设备有关，同一张drawable目录下的图片在不同屏幕密度的设备上可能得到不同的结果。这与Android资源加载机制有关，这一点平时开发的时候应该也注意到了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试官：哈希表都不知道，你是怎么看懂HashMap的？</title>
    <link href="/Blog/2020/11/27/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8%E9%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%8C%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%9C%8B%E6%87%82HashMap%E7%9A%84%EF%BC%9F/"/>
    <url>/Blog/2020/11/27/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8%E9%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%8C%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%9C%8B%E6%87%82HashMap%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>HashMap是Java面试中的必问考点之一，网上关于HashMap实现原理的文章数不胜数。但是在翻阅了大部分HashMap相关的文章之后，发现大多数文章都是对HashMap源码的分析，丝毫没有提到哈希表的概念。</p><p>这就导致了很多人只记住了HashMap的原理，却不知哈希表为何物的奇特现象。很多情况下，面试官可能并不会直接问HashMap是如何实现的，而是抛出一个质问三连：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxevqENm0icngzAhGuOaXPJNYgYF2ZqnZVAhb530ZibQ9aaQSwku7ZmyTzQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>搞错了，重来！<strong>什么是哈希表？什么是哈希冲突？如何处理哈希冲突？</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxegKXgm09xstyrP0Q8gIUrciaAvqiaibvxf3NSLYYcYSozYlib2aS1b7ULuw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>对于不了解哈希表的同学，这三个问题确实触及到了知识盲区。</p><p>为了避免这种尴尬，接下来就一起来学习一下哈希表吧。</p><p><em>1</em></p><p>什么是哈希表？</p><p>在回答这个问题之前我们先来思考一个问题：如何在一个无序的线性表中查找一个数据元素？</p><p>注意，这是一个无序的线性表，也就是说要查找的这个元素在线性表中的位置是随机的。</p><p>对于这样的情况，想要找到这个元素就必须对这个线性表进行遍历，然后与要查找的这个元素进行比较。<strong>这就意味着查找这个元素的时间复杂度为o(n)。</strong></p><p>对于o(n)的时间复杂度，在查找海量数据的时候也是一个非常消耗性能的操作。那么有没有一种数据结构，这个数据结构中的元素与它所在的位置存在一个对应关系，这样的话我们就可以通过这个元素直接找到它所在的位置，而此时查找这个元素的时间复杂度就变成了o(1),可以大大节省程序的查找效率。</p><p>当然，这种数据结构是存在的，它就是我们今天要讲的哈希表。</p><p>我们先来看一下哈希表的定义：</p><blockquote><p>哈希表又叫散列表，是一种根据设定的映射函数f(key)将一组关键字映射到一个有限且连续的地址区间上，并以关键字在地址区间中的“像”作为元素在表中的存储位置的一种数据结构。这个映射过程称为哈希造表或者散列，这个映射函数f(key)即为哈希函数也叫散列函数，通过哈希函数得到的存储位置称为哈希地址或散列地址</p></blockquote><p>定义总是这么的拗口且难以理解。简单来说，哈希表就是通过一个映射函数f(key)将一组数据散列存储在数组中的一种数据结构。</p><p>在这哈希表中，每一个元素的key和它的存储位置都存在一个f(key)的映射关系，我们可以通过f(key)快速的查找到这个元素在表中的位置。</p><p>举个例子，有一组数据：[19,24,6,33,51,15]，我们用散列存储的方式将其存储在一个长度为11的数组中。采用除留取余法，将这组数据分别模上数组的长度（即f(key)=key % 11），以余数作为该元素在数组中的存储的位置。则会得到一个如下图所示的哈希表：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeqnoKsktfSFHk3SK5pnkcu6a03Csly8NU49m3aNZyftZQWh1LbyTtSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>此时，如果我们想从这个表中找到值为15的元素，只需要将15模上11即可得到15在数组中的存储位置。可见哈希表对于查找元素的效率是非常高的。</p><p><em>2</em></p><p>什么是哈希冲突</p><p>上一节中我们举了一个很简单的例子来解释什么是哈希表，例子中的这组数据只有6个元素。</p><p>假如我们向这组数据中再插入一些元素，插入后的数据为：[19,24,6,33,51,15,25,72]，新元素25模11后得到3，存储到3的位置没有问题。而接下来我们对72模11之后得到了6，而此时在数组中6的位置已经被其他元素给占据了。</p><p>“72“只能很无奈的表示我放哪呢？</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeyVyqzP3rUl9PpRqhxINcXzaqO172rutkIdSXuO34fSic0DAia9aVQyRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">对于上述情况我们将其称之为哈希冲突。哈希冲突比较官方的定义为：</p><blockquote><p>对于不同的关键字，可能得到同一个哈希地址，即key1≠key2,而 f(key1)=f(key2)，对于这种现象我们称之为哈希冲突，也叫哈希碰撞</p></blockquote><p><strong>一般情况下，哈希冲突只能尽可能的减少，但不可能完全避免。</strong></p><p>因为哈希函数是从关键字集合到地址集合的映射，通常来说关键字集合比较大，它的元素理论上包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。</p><p>这就导致了哈希冲突的必然性。</p><h3 id="1-如何减少哈希冲突？"><a href="#1-如何减少哈希冲突？" class="headerlink" title="1.如何减少哈希冲突？"></a><strong>1.如何减少哈希冲突？</strong></h3><p>尽管哈希冲突不可避免，但是我们也要尽可能的减少哈希冲突的出现。</p><p>一个好的哈希函数可以有效的减少哈希冲突的出现。那什么样的哈希函数才是一个好的哈希函数呢？通常来说，一个好的哈希函数对于关键字集合中的任意一个关键字，经过这个函数映射到地址集合中任何一个集合的概率是相等的。</p><p>常用的构造哈希函数的方法有以下几种：</p><p><strong>（1）除留取余法</strong></p><p>这个方法我们在上边已经有接触过了。取关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址。即：f(key)=key % p, p≤m;</p><p><strong>（2）直接定址法</strong></p><p>**<br>**</p><p>直接定址法是指取关键字或关键字的某个线性函数值为哈希地址。即：f(key)=key 或者 f(key)=a*key+b、</p><p><strong>（3）数字分析法</strong></p><p>假设关键字是以为基的数（如以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可以选取关键字的若干位数组成哈希表。</p><p>当然，除了上边列举的几种方法，还有很多种选取哈希函数的方法，就不一一列举了。我们只要知道，选取合适的哈希函数可以有效减少哈希冲突即可。</p><h3 id="2-如何处理哈希冲突？"><a href="#2-如何处理哈希冲突？" class="headerlink" title="2.如何处理哈希冲突？"></a><strong>2.如何处理哈希冲突？</strong></h3><p>虽然我们可以通过选取好的哈希函数来减少哈希冲突，但是哈希冲突终究是避免不了的。那么，碰到哈希冲突应该怎么处理呢？接下来我们来介绍几种处理哈希冲突的方法。</p><p><strong>（1）开放定址法</strong></p><p>开放定址法是指当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</p><p>我们以本节开头的例子来讲解开放定址法是如何处理冲突的。72模11后得到6，而此时6的位置已经被其他元素占用了，那么将6加1得到7， 此时发现7的位置也被占用了，那就再加1得到下一个地址为8，而此时8仍然被占用，再接着加1得到9，此时9处为空，则将72存入其中，即得到如下哈希表：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxezOg8ial4laYHeiaIUMzCEiaW2WwxJqiaZWMCfU7qRAjFJOoTDurpy4gKgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">像上边的这种探测方法称为线性探测再散列。当然除了线性探测再散列之外还有二次探测再散列，探测地址的方式为原哈希地址加上d (d= <img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeQFWHgKCB2o2ibVBU2aeKza7v4qHe7oibV8Fo7ABzpCKTGql8Tel2VkkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">、<img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxelDqicKkIIZpwyheyicfdcBvKshdtunPbhtCmKP75jzvZZhXeWqap4dCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">、<img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxe1nGhymCDzxwKb1GpXdicASN6vldHibGOXG0rMDb6S7wAXbF2zcY8Jiagw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">……<img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeY80IrrLQKakd8FEz9Qpj1rV9ZZsEIlyXNOtET8ibcMCo6j1EhMyKibnQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)，经过二次探测再散列后会得到求得72的哈希地址为5，存储如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeLgqkFwb9VvTcHIwf3ogwunhXexRGt80DurHNnfKkTkzmp0c4sQsNJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><strong>（2）再哈希法</strong></p><p>再哈希法即选取若干个不同的哈希函数，在产生哈希冲突的时候计算另一个哈希函数，直到不再发生冲突为止。</p><p><strong>（3）建立公共溢出区</strong></p><p>专门维护一个溢出表，当发生哈希冲突时，将值填入溢出表。</p><p><strong>（4）链地址法</strong></p><p>链地址法是指在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储。也就是凡是哈希地址为i的元素都插入到同一个链表中，元素插入的位置可以是表头（头插法），也可以是表尾（尾插法）。我们以仍然以[19,24,6,33,51,15,25,72] 这一组数据为例，用链地址法来进行哈希冲突的处理，得到如下图所示的哈希表：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeakrvWuLI79UUa2UGAO7TMwX0Pde27jv2zosdKA2eicKKaZIpOl440UQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">我们可以向这组数据中再添加一些元素，得到一组新的数据[19,24,6,33,51,15,25,72,37,17,4,55,83]。使用链地址法得到如下哈希表：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeBNDofs2fTVsUJAa30YUKDCKz1kWCqH7Tto7QJ0uWdE9Cjy7ADsibaVg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p><em>3</em></p><p>链地址法的弊端与优化</p><p>上一节中我们讲解了几种常用的处理哈希冲突的方法。</p><p>其中比较常用的是链地址法，比如HashMap就是基于链地址法的哈希表结构。虽然链地址法是一种很好的处理哈希冲突的方法，但是在一些极端情况下链地址法也会出现问题。举个例子，我们现在有这样一组数据：[48,15,26,4,70,82,59]。我们将这组数据仍然散列存储到长度为11的数组中，此时则得到了如下的结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeINUolDgDNkPfnNFvfeKEyH86TrT5GRz52TzTl062Lgh7EBwYQP0h3A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>可以发现，此时的哈希表俨然已经退化成了一个链表，当我们在这样的数据结构中去查找某个元素的话，时间复杂度又变回了o(n)。</p><p>这显然不符合我们的预期。因此，当哈希表中的链表过长时就需要我们对其进行优化。我们知道，二叉查找树的查询效率是远远高于链表的。</p><p>因此，当哈希表中的链表过长时我们就可以把这个链表变成一棵红黑树。上面的一组数据优化后可得到如下结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxemffgpRTcQTC9cibLXo7FEcNsjaVTRmsVSWWb4iaDCmy8wQOZJkgiaMG5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>红黑树是一个可以自平衡的二叉查找树。</p><p><strong>它的查询的时间复杂度为o(lgn)。通过这样的优化可以提高哈希表的查询效率。</strong></p><p><em>4</em></p><p>哈希表的扩容与Rehash</p><p>在哈希表长度不变的情况下，随着哈希表中插入的元素越来越多，发生哈希冲突的概率会越来越大，相应的查找的效率就会越来越低。</p><p>这意味着影响哈希表性能的因素除了哈希函数与处理冲突的方法之外，还与哈希表的装填因子大小有关。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxe37a95Iuywt41hibOITT4icicefiaCC71cyssVRvpPUmibucxk2kQrYR2VBQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>很显然，α的值越小哈希冲突的概率越小，查找时的效率也就越高。而减小α的值就意味着降低了哈希表的使用率。显然这是一个矛盾的关系，不可能有完美解。</p><p>为了兼顾彼此，装填因子的最大值一般选在0.65~0.9之间。比如HashMap中就将装填因子定为0.75。</p><p>一旦HashMap的装填因子大于0.75的时候，为了减少哈希冲突，就需要对哈希表进行扩容操作。比如我们可以将哈希表的长度扩大到原来的2倍。</p><p>这里我们应该知道，扩容并不是在原数组基础上扩大容量，而是需要申请一个长度为原来2倍的新数组。因此，扩容之后就需要将原来的数据从旧数组中重新散列存放到扩容后的新数组。这个过程我们称之为Rehash。</p><p>接下来我们仍然以[19,24,6,33,51,15,25,72,37,17,4,55,83]这组数据为例来演示哈希表扩容与Rehash的过程。假设哈希表的初始长度为11，装载因子的最大值定位0.75，扩容前的数据插入如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeT5iaWZicuKAndZ2sk0WJmNFHH7UEFic1UdpBmNF5sGrXSnYqYryK9FvLw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>当我们插入第11个元素的时候发现此时的装填因子已经大于了0.75，因此触发了扩容操作。为了方便画图，这里将数组长度扩展到了18。</p><p>扩容后将[19,24,6,33,51,15,25,72,37,17,4,55,83]这组数据重新散列，会得到如下图所示的结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwPJGsaiaQDEEDGGEHiblbcZxeZR82OMzgXsZRU1cgJXXej9eSF5icxwsmn1BxcibK6f8uBMDzlRl9FNZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>可以看到扩容前后元素存储位置大相径庭。</p><p>Rehash的操作将会重新散列扩容前已经存储的数据，这一操作涉及大量的元素移动，是一个非常消耗性能的操作。</p><p>因此，在开发中我们应该尽量避免Rehash的出现。比如，可以预估元素的个数，事先指定哈希表的长度，这样可以有效减少Rehash。</p><p><em>5</em></p><p>总结</p><p>哈希表是数据结构中非常重要的一个知识点，本篇文章详细的讲解了哈希表的相关概念，让大家对哈希表有了一个清晰的认识。</p><p>哈希表弥补了线性表或者树的查找效率低的问题，通过哈希表在理想的情况下可以将查找某个元素的时间复杂度降低到o(1),但是由于哈希冲突的存在，哈希表的查找效率很难达到理想的效果。</p><p>另外，哈希表的扩容与Rehash的操作对哈希表存储时的性能也有很大的影响。</p><p>由此可见使用哈希表存储数据也并非一个完美的方案。但是，对于查找性能要求高的情况下哈希表的数据结构还是我们的不二选择。</p><p>最后了解了哈希表对于理解HashMap会有莫大的帮助。毕竟HashMap本身就是基于哈希表实现的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android多线程的一切</title>
    <link href="/Blog/2020/11/23/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E5%88%87/"/>
    <url>/Blog/2020/11/23/Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E5%88%87/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍**"></a>1. 基本介绍**</h3><p>**<br>**</p><p>在我学习 Android 多线程优化方法的过程中，发现我对多线程优化的了解太片面。</p><p>写这篇文章的目的是完善我对 Android 多线程优化方法的认识，分享这篇文章的目的是希望大家也能从这些知识从得到一些启发。</p><p>这篇文章分为下面三部分。</p><ul><li>第一部分讲的是多线程优化的基础知识，包括线程的介绍和线程调度基本原理的介绍。</li><li>第二部分讲的是多线程优化需要预防的一些问题，包括线程安全问题的介绍和实现线程安全的办法。</li><li>第三部分讲的是多线程优化可以使用的一些方法，包括线程之间的协作方式与 Android 执行异步任务的常用方式。</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-阅读技巧"><a href="#2-阅读技巧" class="headerlink" title="2. 阅读技巧"></a><strong>2. 阅读技巧</strong></h3><p>**<br>**</p><p>阅读本文时，可以带着下面这些问题边思考边阅读。</p><ul><li>这个说法的依据是什么？</li><li>怎么以自己的方式去解释这个概念？</li><li>怎么在自己的项目中应用这个技巧？</li><li>这个概念的具体代码实现是怎样的？</li><li>这个实现存在哪些问题？</li></ul><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="3-缩略词"><a href="#3-缩略词" class="headerlink" title="3. 缩略词"></a><strong>3. 缩略词</strong></h3><p>**<br>**</p><ul><li><p>GC</p></li><li><ul><li>Garbage Collector（垃圾回收器）</li><li>Garbage Collection（垃圾回收动作）</li></ul></li><li><p>ART</p><p>Android Runtime（Android 应用运行时环境）</p></li><li><p>JVM</p><p>Java Virtual Machine（Java 虚拟机）</p></li><li><p>JUC</p><p>java.util.concurrent（Java 并发包）</p></li></ul><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p><em>1</em></p><p>什么是线程？</p><p>我们这一节的内容包括下面几个部分。</p><ul><li>线程简介</li><li>线程的四个属性</li><li>线程的六个方法</li><li>线程的六种状态</li></ul><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a><strong>1.1 线程</strong></h3><p>**<br>**</p><p>线程是进程中可独立执行的最小单位，也是 CPU 资源分配的基本单位。</p><p>进程是程序向操作系统申请资源的基本条件，一个进程可以包含多个线程，同一个进程中的线程可以共享进程中的资源，如内存空间和文件句柄。</p><p>操作系统会把资源分配给进程，但是 CPU 资源比较特殊，它是分配给线程的，这里说的 CPU 资源也就是 CPU 时间片。</p><p>进程与线程的关系，就像是饭店与员工的关系，饭店为顾客提供服务，而提供服务的具体方式是通过一个个员工实现的。</p><p>线程的作用是执行特定任务，这个任务可以是下载文件、加载图片、绘制界面等。</p><h3 id="1-2-线程的四个属性"><a href="#1-2-线程的四个属性" class="headerlink" title="1.2 线程的四个属性"></a><strong>1.2 线程的四个属性</strong></h3><p>**<br>**</p><p>线程有编号、名字、类别以及优先级四个属性，除此之外，线程的部分属性还具有继承性，下面我们就来看看线程的四个属性的作用和线程的继承性。</p><h4 id="1-2-1-编号"><a href="#1-2-1-编号" class="headerlink" title="1.2.1 编号"></a><strong>1.2.1 编号</strong></h4><p>**<br>**</p><ul><li><p>作用</p><p>线程的编号（id）用于标识不同的线程，每条线程拥有不同的编号。</p></li><li><p>注意事项</p></li><li><ul><li><p>不能作为唯一标识</p><p>某个编号的线程运行结束后，该编号可能被后续创建的线程使用，因此编号不适合用作唯一标识</p></li><li><p>只读</p><p>编号是只读属性，不能修改</p></li></ul></li></ul><h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><h4 id="1-2-2-名字"><a href="#1-2-2-名字" class="headerlink" title="1.2.2 名字"></a><strong>1.2.2 名字</strong></h4><p>**<br>**</p><p>每个线程都有自己的名字（name），名字的默认值是 Thread-线程编号，比如 Thread-0 。</p><p>除了默认值，我们也可以给线程设置名字，以我们自己的方式去区分每一条线程。</p><ul><li><p>作用</p><p>给线程设置名字可以让我们在某条线程出现问题时，用该线程的名字快速定位出问题的地方</p></li></ul><h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4><h4 id="1-2-3-类别"><a href="#1-2-3-类别" class="headerlink" title="1.2.3 类别"></a><strong>1.2.3 类别</strong></h4><p>**<br>**</p><p>线程的类别（daemon）分为守护线程和用户线程，我们可以通过 setDaemon(true) 把线程设置为守护线程。</p><p>当 JVM 要退出时，它会考虑是否所有的用户线程都已经执行完毕，是的话则退出。</p><p>而对于守护线程，JVM 在退出时不会考虑它是否执行完成。</p><ul><li><p>作用</p><p>守护线程通常用于执行不重要的任务，比如监控其他线程的运行情况，GC 线程就是一个守护线程。</p></li><li><p>注意事项</p><p>setDaemon() 要在线程启动前设置，否则 JVM 会抛出非法线程状态异常（IllegalThreadStateException）。</p></li></ul><h4 id="-6"><a href="#-6" class="headerlink" title=""></a></h4><h4 id="1-2-4-优先级"><a href="#1-2-4-优先级" class="headerlink" title="1.2.4 优先级"></a><strong>1.2.4 优先级</strong></h4><p>**<br>**</p><ul><li><p>作用</p><p>线程的优先级（Priority）用于表示应用希望优先运行哪个线程，线程调度器会根据这个值来决定优先运行哪个线程。</p></li><li><p>取值范围</p><p>Java 中线程优先级的取值范围为 1~10，默认值是 5，Thread 中定义了下面三个优先级常量。</p></li><li><ul><li>最低优先级：MIN_PRIORITY = 1</li><li>默认优先级：NORM_PRIORITY = 5</li><li>最高优先级：MAX_PRIORITY = 10</li></ul></li><li><p>注意事项</p></li><li><ul><li><p>不保证</p><p>线程调度器把线程的优先级当作一个参考值，不一定会按我们设定的优先级顺序执行线程</p></li><li><p>线程饥饿</p><p>优先级使用不当会导致某些线程永远无法执行，也就是线程饥饿的情况，关于线程饥饿，在第 7 大节会有更多的介绍</p></li></ul></li></ul><h4 id="-7"><a href="#-7" class="headerlink" title=""></a></h4><h4 id="1-2-5-继承性"><a href="#1-2-5-继承性" class="headerlink" title="1.2.5 继承性"></a><strong>1.2.5 继承性</strong></h4><p>**<br>**</p><p>线程的继承性指的是线程的类别和优先级属性是会被继承的，线程的这两个属性的初始值由开启该线程的线程决定。</p><p>假如优先级为 5 的守护线程 A 开启了线程 B，那么线程 B 也是一个守护线程，而且优先级也是 5 。</p><p>这时我们就把线程 A 叫做线程 B 的父线程，把线程 B 叫做线程 A 的子线程。</p><h3 id="1-3-线程的六个方法"><a href="#1-3-线程的六个方法" class="headerlink" title="1.3 线程的六个方法"></a><strong>1.3 线程的六个方法</strong></h3><p>**<br>**</p><p>线程的常用方法有六个，它们分别是三个非静态方法 start()、run()、join() 和三个静态方法 currentThread()、yield()、sleep() 。</p><p>下面我们就来看下这六个方法都有哪些作用和注意事项。</p><h4 id="1-3-1-start"><a href="#1-3-1-start" class="headerlink" title="1.3.1 start()"></a><strong>1.3.1 start()</strong></h4><p>**<br>**</p><ul><li><p>作用</p><p>start() 方法的作用是启动线程。</p></li><li><p>注意事项</p><p>该方法只能调用一次，再次调用不仅无法让线程再次执行，还会抛出非法线程状态异常。</p></li></ul><h4 id="-8"><a href="#-8" class="headerlink" title=""></a></h4><h4 id="1-3-2-run"><a href="#1-3-2-run" class="headerlink" title="1.3.2 run()"></a><strong>1.3.2 run()</strong></h4><p>**<br>**</p><ul><li><p>作用</p><p>run() 方法中放的是任务的具体逻辑，该方法由 JVM 调用，一般情况下开发者不需要直接调用该方法。</p></li><li><p>注意事项</p><p>如果你调用了 run() 方法，加上 JVM 也调用了一次，那这个方法就会执行两次</p></li></ul><h4 id="-9"><a href="#-9" class="headerlink" title=""></a></h4><h4 id="1-3-3-join"><a href="#1-3-3-join" class="headerlink" title="1.3.3 join()"></a><strong>1.3.3 join()</strong></h4><p>**<br>**</p><ul><li><p>作用</p><p>join() 方法用于等待其他线程执行结束。</p><p>如果线程 A 调用了线程 B 的 join() 方法，那线程 A 会进入等待状态，直到线程 B 运行结束。</p></li><li><p>注意事项</p><p>join() 方法导致的等待状态是可以被中断的，所以调用这个方法需要捕获中断异常</p></li></ul><h4 id="-10"><a href="#-10" class="headerlink" title=""></a></h4><h4 id="1-3-4-Thread-currentThread"><a href="#1-3-4-Thread-currentThread" class="headerlink" title="1.3.4 Thread.currentThread()"></a><strong>1.3.4 Thread.currentThread()</strong></h4><p>**<br>**</p><ul><li><p>作用</p><p>currentThread() 方法是一个静态方法，用于获取执行当前方法的线程。</p><p>我们可以在任意方法中调用 Thread.currentThread() 获取当前线程，并设置它的名字和优先级等属性。</p></li></ul><h4 id="-11"><a href="#-11" class="headerlink" title=""></a></h4><h4 id="1-3-5-Thread-yield"><a href="#1-3-5-Thread-yield" class="headerlink" title="1.3.5 Thread.yield()"></a><strong>1.3.5 Thread.yield()</strong></h4><p>**<br>**</p><ul><li><p>作用</p><p>yield() 方法是一个静态方法，用于使当前线程放弃对处理器的占用，相当于是降低线程优先级。</p><p>调用该方法就像是是对线程调度器说：“如果其他线程要处理器资源，那就给它们，否则我继续用”。</p></li><li><p>注意事项</p><p>该方法不一定会让线程进入暂停状态。</p></li></ul><h4 id="-12"><a href="#-12" class="headerlink" title=""></a></h4><h4 id="1-3-6-Thread-sleep-ms"><a href="#1-3-6-Thread-sleep-ms" class="headerlink" title="1.3.6 Thread.sleep(ms)"></a><strong>1.3.6 Thread.sleep(ms)</strong></h4><p>**<br>**</p><ul><li><p>作用</p><p>sleep(ms) 方法是一个静态方法，用于使当前线程在指定时间内休眠（暂停）。</p></li></ul><p>线程不止提供了上面的 6 个方法给我们使用，而其他方法的使用在文章的后面会有一个更详细的介绍。</p><h3 id="1-4-线程的六种状态"><a href="#1-4-线程的六种状态" class="headerlink" title="1.4 线程的六种状态"></a><strong>1.4 线程的六种状态</strong></h3><h4 id="-13"><a href="#-13" class="headerlink" title=""></a></h4><h4 id="1-4-1-线程的生命周期"><a href="#1-4-1-线程的生命周期" class="headerlink" title="1.4.1 线程的生命周期"></a><strong>1.4.1 线程的生命周期</strong></h4><p>**<br>**</p><p>和 Activity 一样，线程也有自己的生命周期，而且生命周期事件也是由用户（开发者）触发的。</p><p>从 Activity 的角度来看，用户点击按钮后打开一个 Activity，就相当于是触发了 Activity 的 onCreate() 方法。</p><p>从线程的角度来看，开发者调用了 start() 方法，就相当于是触发了 Thread 的 run() 方法。</p><p>如果我们在上一个 Activity 的 onPause() 方法中进行了耗时操作，那么下一个 Activity 的显示也会因为这个耗时操作而慢一点显示，这就相当于是 Thread 的等待状态。</p><p>线程的生命周期不仅可以由开发者触发，还会受到其他线程的影响，下面是线程各个状态之间的转换示意图。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>我们可以通过 Thread.getState() 获取线程的状态，该方法返回的是一个枚举类 Thread.State。</p><p>线程的状态有新建、可运行、阻塞、等待、限时等待和终止 6 种，下面我们就来看看这 6 种状态之间的转换过程。</p><h4 id="1-4-2-新建状态"><a href="#1-4-2-新建状态" class="headerlink" title="1.4.2 新建状态"></a><strong>1.4.2 新建状态</strong></h4><p>**<br>**</p><p>当一个线程创建后未启动时，它就处于新建（NEW）状态。</p><h4 id="1-4-3-可运行状态"><a href="#1-4-3-可运行状态" class="headerlink" title="1.4.3 可运行状态"></a><strong>1.4.3 可运行状态</strong></h4><p>**<br>**</p><p>当我们调用线程的 start() 方法后，线程就进入了可运行（RUNNABLE）状态。</p><p>可运行状态又分为预备（READY）和运行（RUNNING）状态。</p><ul><li><p>预备状态</p><p>处于预备状态的线程可被线程调度器调度，调度后线程的状态会从预备转换为运行状态，处于预备状态的线程也叫活跃线程。</p></li><li><p>运行状态</p><p>运行状态表示线程正在运行，也就是处理器正在执行线程的 run() 方法。</p><p>当线程的 yield() 方法被调用后，线程的状态可能由运行状态变为预备状态。</p></li></ul><h4 id="-14"><a href="#-14" class="headerlink" title=""></a></h4><h4 id="1-4-4-阻塞状态"><a href="#1-4-4-阻塞状态" class="headerlink" title="1.4.4 阻塞状态"></a><strong>1.4.4 阻塞状态</strong></h4><p>**<br>**</p><p>当下面几种情况发生时，线程就处于阻塞（BLOCKED）状态。</p><ul><li>发起阻塞式 I/O 操作</li><li>申请其他线程持有的锁</li><li>进入一个 synchronized 方法或代码块失败</li></ul><h4 id="-15"><a href="#-15" class="headerlink" title=""></a></h4><h4 id="1-4-5-等待状态"><a href="#1-4-5-等待状态" class="headerlink" title="1.4.5 等待状态"></a><strong>1.4.5 等待状态</strong></h4><p>**<br>**</p><p>一个线程执行特定方法后，会等待其他线程执行执行完毕，此时线程进入了等待（WAITING）状态。</p><ul><li><p>等待状态</p><p>下面的几个方法可以让线程进入等待状态。</p></li><li><ul><li>Object.wait()</li><li>LockSupport.park()</li><li>Thread.join()</li></ul></li><li><p>可运行状态</p><p>下面的几个方法可以让线程从等待状态转变为可运行状态，而这种转变又叫唤醒。</p></li><li><ul><li>Object.notify()</li><li>Object.notifyAll()</li><li>LockSupport.unpark()</li></ul></li></ul><h4 id="-16"><a href="#-16" class="headerlink" title=""></a></h4><h4 id="1-4-6-限时等待状态"><a href="#1-4-6-限时等待状态" class="headerlink" title="1.4.6 限时等待状态"></a><strong>1.4.6 限时等待状态</strong></h4><p>**<br>**</p><p>限时等待状态 （TIMED_WAITING）与等待状态的区别就是，限时等待是等待一段时间，时间到了之后就会转换为可运行状态。</p><p>下面的几个方法可以让线程进入限时等待状态，下面的方法中的 ms、ns、time 参数分别代表毫秒、纳秒以及绝对时间。</p><ul><li>Thread.sleep(ms)</li><li>Thread.join(ms)</li><li>Object.wait(ms)</li><li>LockSupport.parkNonos(ns)</li><li>LockSupport.parkUntil(time)</li></ul><h4 id="-17"><a href="#-17" class="headerlink" title=""></a></h4><h4 id="1-4-7-终止状态"><a href="#1-4-7-终止状态" class="headerlink" title="1.4.7 终止状态"></a><strong>1.4.7 终止状态</strong></h4><p>当线程的任务执行完毕或者任务执行遇到异常时，线程就处于终止（TERMINATED）状态。</p><h2 id="-18"><a href="#-18" class="headerlink" title=""></a></h2><p><em>2</em></p><p>线程调度的原理是什么？</p><p>阅读完上一节的内容后，我们对线程有了基本的了解，知道了什么是线程，也知道了线程的生命周期是怎么流转的。</p><p>这一节我们就来看看线程是怎么被调度的，这一节包括以下内容。</p><ul><li>Java 内存模型简介</li><li>高速缓存</li><li>Java 线程调度机制</li></ul><h3 id="-19"><a href="#-19" class="headerlink" title=""></a></h3><h3 id="2-1-Java-的内存模型简介"><a href="#2-1-Java-的内存模型简介" class="headerlink" title="2.1 Java 的内存模型简介"></a><strong>2.1 Java 的内存模型简介</strong></h3><p>了解 Java 的内存模型，能帮助我们更好地理解线程的安全性问题，下面我们就来看看什么是 Java 的内存模型。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>Java 内存模型（Java Memory Model，JMM）规定了所有变量都存储在主内存中，每条线程都有自己的工作内存。</p><p>JVM 把内存划分成了好几块，其中方法区和堆内存区域是线程共享的。</p><p>假如现在有三个线程同时对值为 5 的变量 a 进行自增操作，那最终的结果应该是 8 。</p><p>但是自增的真正实现是分为下面三步的，而不是一个不可分割的（原子的）操作。</p><ol><li>将变量 a 的值赋值给临时变量 temp</li><li>将 temp 的值加 1</li><li>将 temp 的值重新赋给变量 a。</li></ol><p>假如线程 1 在进行到第二步的时候，其他两条线程读取了变量 a ，那么最终的结果就是 7，而不是预期的 8 。</p><p>这种现象就是线程安全的其中一个问题：原子性。</p><h3 id="2-2-高速缓存"><a href="#2-2-高速缓存" class="headerlink" title="2.2 高速缓存"></a><strong>2.2 高速缓存</strong></h3><p>**<br>**</p><h4 id="2-2-1-高速缓存简介"><a href="#2-2-1-高速缓存简介" class="headerlink" title="2.2.1 高速缓存简介"></a><strong>2.2.1 高速缓存简介</strong></h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>现代处理器的处理能力要远胜于主内存（DRAM）的访问速率，主内存执行一次内存读/写操作需要的时间，如果给处理器使用，处理器可以执行上百条指令。</p><p>为了弥补处理器与主内存之间的差距，硬件设计者在主内存与处理器之间加入了高速缓存（Cache）。</p><p>处理器执行内存读写操作时，不是直接与主内存打交道，而是通过高速缓存进行的。</p><p>高速缓存相当于是一个由硬件实现的容量极小的散列表，这个散列表的 key 是一个对象的内存地址，value 可以是内存数据的副本，也可以是准备写入内存的数据。</p><h4 id="2-2-2-高速缓存内部结构"><a href="#2-2-2-高速缓存内部结构" class="headerlink" title="2.2.2 高速缓存内部结构"></a><strong>2.2.2 高速缓存内部结构</strong></h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>从内部结构来看，高速缓存相当于是一个链式散列表（Chained Hash Table），它包含若干个桶，每个桶包含若干个缓存条目（Cache Entry）。</p><h4 id="2-2-3-缓存条目结构"><a href="#2-2-3-缓存条目结构" class="headerlink" title="2.2.3 缓存条目结构"></a><strong>2.2.3 缓存条目结构</strong></h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>缓存条目可进一步划分为 Tag、Data Block 和 Flag 三个部分。</p><ul><li><p>Tag</p><p>Tag 包含了与缓存行中数据对应的内存地址的部分信息（内存地址的高位部分比特）</p></li><li><p>Data Block</p><p>Data Block 也叫缓存行（Cache Line），是高速缓存与主内存之间数据交换的最小单元，可以存储从内存中读取的数据，也可以存储准备写进内存的数据。</p></li><li><p>Flag</p><p>Flag 用于表示对应缓存行的状态信息</p></li></ul><h3 id="-20"><a href="#-20" class="headerlink" title=""></a></h3><h3 id="2-3-Java-线程调度原理"><a href="#2-3-Java-线程调度原理" class="headerlink" title="2.3 Java 线程调度原理"></a><strong>2.3 Java 线程调度原理</strong></h3><p>**<br>**</p><p>在任意时刻，CPU 只能执行一条机器指令，每个线程只有获取到 CPU 的使用权后，才可以执行指令。</p><p>也就是在任意时刻，只有一个线程占用 CPU，处于运行的状态。</p><p>多线程并发运行实际上是指多个线程轮流获取 CPU 使用权，分别执行各自的任务。</p><p>线程的调度由 JVM 负责，线程的调度是按照特定的机制为多个线程分配 CPU 的使用权。</p><p>线程调度模型分为两类：分时调度模型和抢占式调度模型。</p><ul><li><p>分时调度模型</p><p>分时调度模型是让所有线程轮流获取 CPU 使用权，并且平均分配每个线程占用 CPU 的时间片。</p></li><li><p>抢占式调度模型</p><p>JVM 采用的是抢占式调度模型，也就是先让优先级高的线程占用 CPU，如果线程的优先级都一样，那就随机选择一个线程，并让该线程占用 CPU。</p><p>也就是如果我们同时启动多个线程，并不能保证它们能轮流获取到均等的时间片。</p><p>如果我们的程序想干预线程的调度过程，最简单的办法就是给每个线程设定一个优先级。</p></li></ul><h2 id="-21"><a href="#-21" class="headerlink" title=""></a></h2><p><em>3</em></p><p>什么是线程的安全性问题？</p><p>阅读完上一节的内容后，我们对 Java 的线程调度机制有了基本的了解。</p><p>这一节我们就来看看线程调度机制导致的线程安全问题，这一节的内容包括以下几个部分。</p><ul><li>竞态</li><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="-22"><a href="#-22" class="headerlink" title=""></a></h3><h3 id="3-1-竞态"><a href="#3-1-竞态" class="headerlink" title="3.1 竞态"></a><strong>3.1 竞态</strong></h3><p>**<br>**</p><p>线程安全问题指的是多个线程之间对一个或多个共享可变对象交错操作时，有可能导致数据异常。</p><p>多线程编程中经常遇到的问题就是一样的输入在不同的时间有不一样的输出，这种一个计算结果的正确性与时间有关的现象就是竞态，也就是计算的正确性依赖于相对时间顺序或线程的交错。</p><p>竞态不一定导致计算结果的不正确，而是不排除计算结果有时正确有时错误的可能。</p><p>竞态往往伴随着脏数据和丢失更新的问题，脏数据就是线程读到一个过时的数据，丢失更新就是一个线程对数据做的更新，没有体现在后续其他线程对该数据的读取上。</p><p>对于共享变量，竞态可以看成访问（读/写）同一组共享变量的多个线程锁执行的操作相互交错，比如一个线程读取共享变量，并以该共享变量为基础进行计算的期间，另一个线程更新了该共享变量的值，导致脏数据或丢失更新。</p><p>对于局部变量，由于不同的线程各自访问的是自己的局部变量，所以局部变量的使用不会导致竞态。</p><h3 id="3-2-原子性"><a href="#3-2-原子性" class="headerlink" title="3.2 原子性"></a><strong>3.2 原子性</strong></h3><p>**<br>**</p><p>原子（Atomic）的字面意识是不可分割的，对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程看来是不可分割的，那么该操作就是原子操作，相应地称该操作具有原子性（Atomicity）。</p><p>所谓不可分割，就是访问（读/写）某个共享变量的操作，从执行线程以外的其他线程看来，该操作只有未开始和结束两种状态，不会知道该操作的中间部分。</p><p>拿炒菜举例，炒菜可分为几个步骤：放油、放菜、放盐、放糖等。</p><p>但是从客人的角度来看，一个菜只有两种状态：没做好和做好了。</p><p>访问同一组共享变量的原子操作是不能被交错的，这就排除了一个线程执行一个操作的期间，另一个线程读取或更新该操作锁访问的共享变量，导致脏数据和丢失更新。</p><h3 id="3-3-可见性"><a href="#3-3-可见性" class="headerlink" title="3.3 可见性"></a><strong>3.3 可见性</strong></h3><p>**<br>**</p><p>在多线程环境下，一个线程对某个共享变量进行更新后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，甚至永远也无法读取到这个更新的结果，这就是线程安全问题的另一种表现形式：可见性。</p><p>可见性是指一个线程对共享变量的更新，对于其他读取该变量的线程是否可见。</p><p>可见性问题与计算机的存储系统有关，程序中的变量可能会被分配到寄存器而不是主内存中，每个处理器都有自己的寄存器，一个处理器无法读取另一个处理器的寄存器上的内容。</p><p>即使共享变量是分配到主内存中存储的，也不饿能保证可见性，因为处理器不是直接访问主内存，而是通过高速缓存进行的。</p><p>一个处理器上运行的线程对变量的更新，可能只是更新到该处理器的写缓冲器（Store Buffer）中，还没有到高速缓存中，更别说处理器了。</p><p>可见性描述的是一个线程对共享变量的更新，对于另一个线程是否可见，保证可见性意味着一个线程可以读取到对应共享变量的新值。</p><p>从保证线程安全的角度来看，光保证原子性还不够，还要保证可见性，同时保证可见性和原子性才能确保一个线程能正确地看到其他线程对共享变量做的更新。</p><h3 id="3-4-有序性"><a href="#3-4-有序性" class="headerlink" title="3.4 有序性"></a><strong>3.4 有序性</strong></h3><p>**<br>**</p><p>有序性是指一个处理器在为一个线程执行的内存访问操作，对于另一个处理器上运行的线程来看是乱序的。</p><p>顺序结构是结构化编程中的一种基本结构，它表示我们希望某个操作先于另外一个操作执行。</p><p>但是在多核处理器的环境下，代码的执行顺序是没保障的，编译器可能改变两个操作的先后顺序，处理器也可能不是按照程序代码的顺序执行指令。</p><p>重排序（Reordering）处理器和编译器是对代码做的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能，但是它会对多线程程序的正确性产生影响，导致线程安全问题。</p><p>现代处理器为了提高指令的执行效率，往往不是按程序顺序注意执行指令的，而是哪条指令就绪就先执行哪条指令，这就是处理器的乱序执行。</p><p><em>4</em></p><p>怎么实现线程安全？</p><p>要实现线程安全就要保证上面说到的原子性、可见性和有序性。</p><p>常见的实现线程安全的办法是使用锁和原子类型，而锁可分为内部锁、显式锁、读写锁、轻量级锁（volatile）四种。</p><p>下面我们就来看看这四种锁和原子类型的用法和特点。</p><h3 id="-23"><a href="#-23" class="headerlink" title=""></a></h3><h3 id="4-1-锁"><a href="#4-1-锁" class="headerlink" title="4.1 锁"></a><strong>4.1 锁</strong></h3><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>**4.1.1 锁的五个特点</p><p>**</p><ul><li><p>临界区</p><p>持有锁的线程获得锁后和释放锁前执行的代码叫做临界区（Critical Section）。</p></li><li><p>排他性</p><p>锁具有排他性，能够保障一个共享变量在任一时刻只能被一个线程访问，这就保证了临界区代码一次只能够被一个线程执行，临界区的操作具有不可分割性，也就保证了原子性。</p></li><li><p>串行</p><p>锁相当于是把多个线程对共享变量的操作从并发改为串行。</p></li><li><p>三种保障</p><p>锁能够保护共享变量实现线程安全，它的作用包括保障原子性、可见性和有序性。</p></li><li><p>调度策略</p><p>锁的调度策略分为公平策略和非公平策略，对应的锁就叫公平锁和非公平锁。</p><p>公平锁会在加锁前查看是否有排队等待的线程，有的话会优先处理排在前面的线程。</p><p>公平锁以增加上下文切换为代价，保障了锁调度的公平性，增加了线程暂停和唤醒的可能性。</p></li></ul><h4 id="-24"><a href="#-24" class="headerlink" title=""></a></h4><h4 id="4-1-2-锁的两个问题"><a href="#4-1-2-锁的两个问题" class="headerlink" title="4.1.2 锁的两个问题"></a>4.1.2 锁的两个问题</h4><ul><li><p>锁泄漏</p><p>锁泄漏是指一个线程获得锁后，由于程序的错误导致锁一直无法被释放，导致其他线程一直无法获得该锁。</p></li><li><p>活跃性问题</p><p>锁泄漏会导致活跃性问题，这些问题包括死锁、和锁死等。</p></li></ul><h3 id="-25"><a href="#-25" class="headerlink" title=""></a></h3><h3 id="4-2-内部锁"><a href="#4-2-内部锁" class="headerlink" title="4.2 内部锁"></a><strong>4.2 内部锁</strong></h3><p>**<br>**</p><h4 id="4-2-1-内部锁简介"><a href="#4-2-1-内部锁简介" class="headerlink" title="4.2.1 内部锁简介"></a><strong>4.2.1 内部锁简介</strong></h4><p>**<br>**</p><p>Java 为我们提供了 synchronized 关键字来实现内部锁，被 synchronized 关键字修饰的方法和代码块就叫同步方法和同步代码块。</p><p>下面我们来看下内部锁的七个特点。</p><ul><li><p>监视器锁</p><p>因为使用 synchronized 实现的线程同步是通过监视器（monitor）来实现的，所以内部锁也叫监视器锁。</p></li><li><p>自动获取/释放</p><p>线程对同步代码块的锁的申请和释放由 JVM 内部实施，线程在进入同步代码块前会自动获取锁，并在退出同步代码块时自动释放锁，这也是同步代码块被称为内部锁的原因。</p></li><li><p>锁定方法/类/对象</p><p>synchronized 关键字可以用来修饰方法，锁住特定类和特定对象。</p></li><li><p>临界区</p><p>同步代码块就是内部锁的临界区，线程在执行临界区代码前必须持有该临界区的内部锁。</p></li><li><p>锁句柄</p><p>内部锁锁的对象就叫锁句柄，锁句柄通常会用 private 和 final 关键字进行修饰。</p><p>因为锁句柄变量一旦改变，会导致执行同一个同步代码块的多个线程实际上用的是不同的锁。</p></li><li><p>不会泄漏</p><p>泄漏指的是锁泄漏，内部锁不会导致锁泄漏，因为 javac 编译器把同步代码块编译为字节码时，对临界区中可能抛出的异常做了特殊处理，这样临界区的代码出了异常也不会妨碍锁的释放。</p></li><li><p>非公平锁</p><p>内部锁是使用的是非公平策略，是非公平锁，也就是不会增加上下文切换开销。</p></li></ul><h4 id="-26"><a href="#-26" class="headerlink" title=""></a></h4><h4 id="4-2-2-内部锁基本用法"><a href="#4-2-2-内部锁基本用法" class="headerlink" title="4.2.2 内部锁基本用法"></a><strong>4.2.2 内部锁基本用法</strong></h4><p>**<br>**</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 锁句柄</span><span class="hljs-keyword">private</span> final String hello = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">private</span> void get<span class="hljs-constructor">Lock1()</span> &#123;  synchronized (hello) &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;ThreadA 拿到了内部锁&quot;</span>);    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadUtils</span>.</span></span>sleep(<span class="hljs-number">2</span><span class="hljs-operator"> * </span><span class="hljs-number">1000</span>);  &#125;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;ThreadA 释放了内部锁&quot;</span>);&#125;</code></pre><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void get<span class="hljs-constructor">Lock2()</span> &#123;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;ThreadB 尝试获取内部锁&quot;</span>);  synchronized (hello) &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;ThreadB 拿到了内部锁&quot;</span>);  &#125;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;ThreadB 继续执行&quot;</span>);&#125;</code></pre><p>当我们在两个线程中分别运行上面两个函数后，我们可以得到下面的输出。</p><pre><code class="hljs properties"><span class="hljs-attr">ThreadA</span> <span class="hljs-string">拿到了内部锁</span><span class="hljs-attr">ThreadB</span> <span class="hljs-string">尝试获取内部锁</span><span class="hljs-attr">ThreadA</span> <span class="hljs-string">释放了内部锁</span><span class="hljs-attr">ThreadB</span> <span class="hljs-string">拿到了内部锁</span><span class="hljs-attr">ThreadB</span> <span class="hljs-string">继续执行</span></code></pre><h3 id="-27"><a href="#-27" class="headerlink" title=""></a></h3><h3 id="4-3-显式锁"><a href="#4-3-显式锁" class="headerlink" title="4.3 显式锁"></a><strong>4.3 显式锁</strong></h3><p>**<br>**</p><h4 id="4-3-1-显式锁简介"><a href="#4-3-1-显式锁简介" class="headerlink" title="4.3.1 显式锁简介"></a><strong>4.3.1 显式锁简介</strong></h4><p>**<br>**</p><p>显式锁（Explict Lock）是 Lock 接口的实例，Lock 接口对显式锁进行了抽象，ReentrantLock 是它的实现类。</p><p>下面是显式锁的四个特点。</p><ul><li><p>可重入</p><p>显式锁是可重入锁，也就是一个线程持有了锁后，能再次成功申请这个锁。</p></li><li><p>手动获取/释放</p><p>显式锁与内部锁区别在于，使用显式锁，我们要自己释放和获取锁，为了避免锁泄漏，我们要在 finally 块中释放锁</p></li><li><p>临界区</p><p>lock() 与 unlock() 方法之间的代码就是显式锁的临界区</p></li><li><p>公平/非公平锁</p><p>显式锁允许我们自己选择锁调度策略。</p><p>ReentrantLock 有一个构造函数，允许我们传入一个 fair 值，当这个值为 true 时，说明现在创建的这个锁是一个公平锁。</p><p>由于公平锁的开销比非公平锁大，所以 ReentrantLock 的默认调度策略是非公平策略。</p></li></ul><h4 id="-28"><a href="#-28" class="headerlink" title=""></a></h4><h4 id="4-3-2-显式锁基本用法"><a href="#4-3-2-显式锁基本用法" class="headerlink" title="4.3.2 显式锁基本用法"></a><strong>4.3.2 显式锁基本用法</strong></h4><p>**<br>**</p><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> final Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock1</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;线程 1 获取了显式锁&quot;</span>);  <span class="hljs-keyword">try</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;线程 1 开始执行操作&quot;</span>);    ThreadUtils.sleep(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>);  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">lock</span>.unlock();    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;线程 1 释放了显式锁&quot;</span>);  &#125;&#125;</code></pre><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock2</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;线程 2 获取了显式锁&quot;</span>);  <span class="hljs-keyword">try</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;线程 2 开始执行操作&quot;</span>);  &#125; <span class="hljs-keyword">finally</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;线程 2 释放了显式锁&quot;</span>);    <span class="hljs-keyword">lock</span>.unlock();  &#125;&#125;</code></pre><p>当我们分别在两个线程中分别执行了上面的两个函数后，我们可以得到下面的输出。</p><pre><code class="hljs angelscript">线程 <span class="hljs-number">1</span> 获取了显式锁线程 <span class="hljs-number">1</span> 开始执行操作线程 <span class="hljs-number">1</span> 释放了显式锁线程 <span class="hljs-number">2</span> 获取了显式锁线程 <span class="hljs-number">2</span> 开始执行操作线程 <span class="hljs-number">2</span> 释放了显式锁</code></pre><h4 id="-29"><a href="#-29" class="headerlink" title=""></a></h4><h4 id="4-3-3-显示锁获取锁的四个方法"><a href="#4-3-3-显示锁获取锁的四个方法" class="headerlink" title="4.3.3 显示锁获取锁的四个方法"></a><strong>4.3.3 显示锁获取锁的四个方法</strong></h4><p>**<br>**</p><ul><li><p>lock()</p><p>获取锁，获取失败时线程会处于阻塞状态</p></li><li><p>tryLock()</p><p>获取锁，获取成功时返回 true，获取失败时会返回 false，不会处于阻塞状态</p></li><li><p>tryLock(long time, TimeUnit unit)</p><p>获取锁，获取到了会返回 true，如果在指定时间内未获取到，则返回 false。</p><p>在指定时间内处于阻塞状态，可中断。</p></li><li><p>lockInterruptibly()</p><p>获取锁，可中断。</p></li></ul><h3 id="-30"><a href="#-30" class="headerlink" title=""></a></h3><h3 id="4-4-内部锁与显式锁的区别"><a href="#4-4-内部锁与显式锁的区别" class="headerlink" title="4.4 内部锁与显式锁的区别"></a><strong>4.4 内部锁与显式锁的区别</strong></h3><p>**<br>**</p><p>看完了内部锁和显式锁的介绍，下面我们来看下内部锁和显式锁的五个区别。</p><ul><li><p>灵活性</p><p>内部锁是基于代码的锁，锁的申请和释放只能在一个方法内执行，缺乏灵活性。</p><p>显式锁是基于对象的锁，锁的申请和释放可以在不同的方法中执行，这样可以充分发挥面向对象编程的灵活性。</p></li><li><p>锁调度策略</p><p>内部锁只能是非公平锁。</p><p>显式锁可以自己选择锁调度策略。</p></li><li><p>便利性</p><p>内部锁简单易用，不会出现锁泄漏的情况。</p><p>显式锁需要自己手动获取/释放锁，使用不当的话会导致锁泄漏。</p></li><li><p>阻塞</p><p>如果持有内部锁锁的线程一直不释放这个锁，那其他申请这个锁的线程只能一直等待。</p><p>显式锁 Lock 接口有一个 tryLock() 方法，当其他线程持有锁时，这个方法会返回直接返回 false。</p><p>这样就不会导致线程处于阻塞状态，我们就可以在获取锁失败时做别的事情。</p></li><li><p>适用场景</p><p>在多个线程持有锁的平均时间不长的情况下我们可以使用内部锁</p><p>在多个线程持有锁的平均较长的情况下我们可以使用显式锁（公平锁）</p></li></ul><h3 id="-31"><a href="#-31" class="headerlink" title=""></a></h3><h3 id="4-5-读写锁"><a href="#4-5-读写锁" class="headerlink" title="4.5 读写锁"></a><strong>4.5 读写锁</strong></h3><p>**<br>**</p><h4 id="4-5-1-读写锁简介"><a href="#4-5-1-读写锁简介" class="headerlink" title="4.5.1 读写锁简介"></a><strong>4.5.1 读写锁简介</strong></h4><p>**<br>**</p><p>锁的排他性使得多个线程无法以线程安全的方式在同一时刻读取共享变量，这样不利于提高系统的并发性，这也是读写锁出现的原因。</p><p>读写锁 ReadWriteLock 接口的实现类是 ReentrantReadWriteLock。</p><p>只读取共享变量的线程叫读线程，只更新共享变量的线程叫写线程。</p><p>读写锁是一种改进的排他锁，也叫共享/排他（Shared/Exclusive）锁。</p><p>读写锁有下面六个特点。</p><ul><li><p>读锁共享</p><p>读写锁允许多个线程同时读取共享变量，读线程访问共享变量时，必须持有对应的读锁，读锁可以被多个线程持有。</p></li><li><p>写锁排他</p><p>读写锁一次只允许一个线程更新共享变量，写线程访问共享变量时，必须持有对应的写锁，写锁在任一时刻只能被一个线程持有。</p></li><li><p>可以降级</p><p>读写锁是一个支持降级的可重入锁，也就是一个线程在持有写锁的情况下，可以继续获取对应的读锁。</p><p>这样我们可以在修改变量后，在其他地方读取该变量，并执行其他操作。</p></li><li><p>不能升级</p><p>读写锁不支持升级，读线程只有释放了读锁才能申请写锁</p></li><li><p>三种保障</p><p>读写锁虽然允许多个线程读取共享变量，但是由于写锁的特性，它同样能保障原子性、可见性和有序性。</p></li><li><p>适用场景</p><p>读写锁会带来额外的开销，只有满足下面两个条件，读写锁才是合适的选择</p></li><li><ul><li>读操作比写操作频繁很多</li><li>读取共享变量的线程持有锁的时间较长</li></ul></li></ul><h4 id="-32"><a href="#-32" class="headerlink" title=""></a></h4><h4 id="4-5-2-读写锁基本用法"><a href="#4-5-2-读写锁基本用法" class="headerlink" title="4.5.2 读写锁基本用法"></a><strong>4.5.2 读写锁基本用法</strong></h4><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> final ReadWriteLock readWriteLock = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ReentrantReadWriteLock()</span>;<span class="hljs-keyword">private</span> final Lock readLock = readWriteLock.read<span class="hljs-constructor">Lock()</span>;<span class="hljs-keyword">private</span> final Lock writeLock = readWriteLock.write<span class="hljs-constructor">Lock()</span>;<span class="hljs-keyword">private</span> void write1<span class="hljs-literal">()</span> &#123;  writeLock.lock<span class="hljs-literal">()</span>;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;写线程1获取了写锁&quot;</span>);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;写线程1开始执行操作&quot;</span>);    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadUtils</span>.</span></span>sleep(<span class="hljs-number">3</span><span class="hljs-operator"> * </span><span class="hljs-number">1000</span>);  &#125; finally &#123;    writeLock.unlock<span class="hljs-literal">()</span>;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;写线程1释放了写锁&quot;</span>);  &#125;&#125;<span class="hljs-keyword">private</span> void write2<span class="hljs-literal">()</span> &#123;  writeLock.lock<span class="hljs-literal">()</span>;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;写线程2获取了写锁&quot;</span>);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;写线程2开始执行操作&quot;</span>);  &#125; finally &#123;    writeLock.unlock<span class="hljs-literal">()</span>;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;写线程2释放了写锁&quot;</span>);  &#125;&#125;</code></pre><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read1</span>(<span class="hljs-params"></span>)</span> &#123;  readLock.<span class="hljs-keyword">lock</span>();  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;读线程1获取了读锁&quot;</span>);  <span class="hljs-keyword">try</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;读线程1开始执行操作&quot;</span>);    ThreadUtils.sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000</span>);  &#125; <span class="hljs-keyword">finally</span> &#123;    readLock.unlock();    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;读线程1释放了读锁&quot;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read2</span>(<span class="hljs-params"></span>)</span> &#123;  readLock.<span class="hljs-keyword">lock</span>();  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;读线程2获取了读锁&quot;</span>);  <span class="hljs-keyword">try</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;读线程2开始执行操作&quot;</span>);    ThreadUtils.sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000</span>);  &#125; <span class="hljs-keyword">finally</span> &#123;    readLock.unlock();    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;读线程2释放了读锁&quot;</span>);  &#125;&#125;</code></pre><p>当在四个线程中分别执行上面的四个函数时，我们可以得到下面的输出。</p><pre><code class="hljs angelscript">写线程<span class="hljs-number">1</span>获取了写锁写线程<span class="hljs-number">1</span>开始执行操作写线程<span class="hljs-number">1</span>释放了写锁写线程<span class="hljs-number">2</span>获取了写锁写线程<span class="hljs-number">2</span>开始执行操作写线程<span class="hljs-number">2</span>释放了写锁读线程<span class="hljs-number">1</span>获取了读锁读线程<span class="hljs-number">1</span>开始执行操作读线程<span class="hljs-number">2</span>获取了读锁读线程<span class="hljs-number">2</span>开始执行操作读线程<span class="hljs-number">1</span>释放了读锁读线程<span class="hljs-number">2</span>释放了读锁</code></pre><h3 id="-33"><a href="#-33" class="headerlink" title=""></a></h3><h3 id="4-6-volatile-关键字"><a href="#4-6-volatile-关键字" class="headerlink" title="4.6 volatile 关键字"></a><strong>4.6 volatile 关键字</strong></h3><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>volatile 关键字可用于修饰共享变量，对应的变量就叫 volatile 变量，volatile 变量有下面几个特点。</p><ul><li><p>易变化</p><p>volatile 的字面意思是“不稳定的”，也就是 volatile 用于修饰容易发生变化的变量，不稳定指的是对这种变量的读写操作要从高速缓存或主内存中读取，而不会分配到寄存器中。</p></li><li><p>开销</p></li><li><ul><li><p>比锁低</p><p>volatile 的开销比锁低，volatile 变量的读写操作不会导致上下文切换，所以 volatile 关键字也叫轻量级锁 。</p></li><li><p>比普通变量高</p><p>volatile 变量读操作的开销比普通变量要高，这是因为 volatile 变量的值每次都要从高速缓存或主内存中读取，无法被暂存到寄存器中。</p></li></ul></li><li><p>释放/存储屏障</p><p>对于 volatile 变量的写操作，JVM 会在该操作前插入一个释放屏障，并在该操作后插入一个存储屏障。</p><p>存储屏障具有冲刷处理器缓存的作用，所以在 volatile 变量写操作后插入一个存储屏障，能让该存储屏障前的所有操作结果对其他处理器来说是同步的。</p></li><li><p>加载/获取屏障</p><p>对于 volatile 变量的读操作，JVM 会在该操作前插入一个加载屏障，并在操作后插入一个获取屏障。</p><p>加载屏障通过冲刷处理器缓存，使线程所在的处理器将其他处理器对该共享变量做的更新同步到该处理器的高速缓存中。</p></li><li><p>保证有序性</p><p>volatile 能禁止指令重排序，也就是使用 volatile 能保证操作的有序性。</p></li><li><p>保证可见性</p><p>读线程执行的加载屏障和写线程执行的存储屏障配合在一起，能让写线程对 volatile 变量的写操作对读线程可见，从而保证了可见性。</p></li><li><p>原子性</p><p>在原子性方面，对于 long/double 型变量，volatile 能保证读写操作的原子型。</p><p>对于非 long/double 型变量，volatile 只能保证写操作的原子性。</p><p>如果 volatile 变量写操作前涉及共享变量，竞态仍然可能发生，因为共享变量赋值给 volatile 变量时，其他线程可能已经更新了该共享变量的值。</p></li></ul><h3 id="-34"><a href="#-34" class="headerlink" title=""></a></h3><h3 id="4-7-原子类型"><a href="#4-7-原子类型" class="headerlink" title="4.7 原子类型"></a><strong>4.7 原子类型</strong></h3><h4 id="4-7-1-原子类型简介"><a href="#4-7-1-原子类型简介" class="headerlink" title="4.7.1 原子类型简介"></a><strong>4.7.1 原子类型简介</strong></h4><p>**<br>**</p><p>在 JUC 下有一个 atomic 包，这个包里面有一组原子类，使用原子类的方法，不需要加锁也能保证线程安全，而原子类是通过 Unsafe 类中的 CAS 指令从硬件层面来实现线程安全的。</p><p>这个包里面有如 AtomicInteger、AtomicBoolean、AtomicReference、AtomicReferenceFIeldUpdater 等。</p><p>我们先来看一个使用原子整型 AtomicInteger 自增的例子。</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 初始值为 1</span>AtomicInteger integer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AtomicInteger(1)</span>;<span class="hljs-comment">// 自增</span><span class="hljs-built_in">int</span> result = integer.increment<span class="hljs-constructor">AndGet()</span>;<span class="hljs-comment">// 结果为 2</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(result);</code></pre><p>AtomicReference 和 AtomicReferenceFIeldUpdater 可以让我们自己的类具有原子性，它们的原理都是通过 Unsafe 的 CAS 操作实现的。</p><p>我们下面看下它们的用法和区别。</p><h4 id="4-7-2-AtomicReference-基本用法"><a href="#4-7-2-AtomicReference-基本用法" class="headerlink" title="4.7.2 AtomicReference 基本用法"></a><strong>4.7.2 AtomicReference 基本用法</strong></h4><p>**<br>**</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceValueHolder</span> </span>&#123;  AtomicReference&lt;<span class="hljs-built_in">String</span>&gt; atomicValue = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;HelloAtomic&quot;</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">getAndUpdateFromReference</span>(<span class="hljs-params"></span>)</span> &#123;  AtomicReferenceValueHolder holder = <span class="hljs-keyword">new</span> AtomicReferenceValueHolder();  <span class="hljs-comment">// 对比并设值</span>  <span class="hljs-comment">// 如果值是 HelloAtomic，就把值换成 World</span>  holder.atomicValue.compareAndSet(<span class="hljs-string">&quot;HelloAtomic&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>);  <span class="hljs-comment">// World</span>  System.out.println(holder.atomicValue.get());  <span class="hljs-comment">// 修改并获取修改后的值</span>  <span class="hljs-built_in">String</span> value = holder.atomicValue.updateAndGet(<span class="hljs-keyword">new</span> UnaryOperator&lt;<span class="hljs-built_in">String</span>&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>;    &#125;  &#125;);  <span class="hljs-comment">// Hello World  </span>  System.out.println(value);&#125;</code></pre><h4 id="-35"><a href="#-35" class="headerlink" title=""></a></h4><h4 id="4-7-3-AtomicReferenceFieldUpdater-基本用法"><a href="#4-7-3-AtomicReferenceFieldUpdater-基本用法" class="headerlink" title="4.7.3 AtomicReferenceFieldUpdater 基本用法"></a><strong>4.7.3 AtomicReferenceFieldUpdater 基本用法</strong></h4><p>**<br>**</p><p>AtomicReferenceFieldUpdater 在用法上和 AtomicReference 有些不同，我们直接把 String 值暴露了出来，并且用 volatile 对这个值进行了修饰。</p><p>并且将当前类和值的类传到 newUpdater ()方法中获取 Updater，这种用法有点像反射，而且 AtomicReferenceFieldUpdater 通常是作为类的静态成员使用。</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleValueHolder</span> &#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AtomicReferenceFieldUpdater&lt;SimpleValueHolder, String&gt; valueUpdater    = AtomicReferenceFieldUpdater.newUpdater(      SimpleValueHolder.<span class="hljs-keyword">class</span>, String.<span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;value&quot;</span>);  <span class="hljs-keyword">volatile</span> String <span class="hljs-keyword">value</span> = <span class="hljs-string">&quot;HelloAtomic&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAndUpdateFromUpdater</span>(<span class="hljs-params"></span>)</span> &#123;  SimpleValueHolder holder = <span class="hljs-keyword">new</span> SimpleValueHolder();  holder.valueUpdater.compareAndSet(holder, <span class="hljs-string">&quot;HelloAtomic&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>);  <span class="hljs-comment">// World</span>  System.<span class="hljs-keyword">out</span>.println(holder.valueUpdater.<span class="hljs-keyword">get</span>(holder));  String <span class="hljs-keyword">value</span> = holder.valueUpdater.updateAndGet(holder, <span class="hljs-keyword">new</span> UnaryOperator&lt;String&gt;() &#123;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span>(<span class="hljs-params">String s</span>)</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>;    &#125;  &#125;);  <span class="hljs-comment">// HelloWorld</span>  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">value</span>);&#125;</code></pre><h4 id="-36"><a href="#-36" class="headerlink" title=""></a></h4><h4 id="4-7-4-AtomicReference-与-AtomicReferenceFieldUpdater-的区别"><a href="#4-7-4-AtomicReference-与-AtomicReferenceFieldUpdater-的区别" class="headerlink" title="4.7.4 AtomicReference 与 AtomicReferenceFieldUpdater 的区别"></a><strong>4.7.4 AtomicReference 与 AtomicReferenceFieldUpdater 的区别</strong></h4><p>**<br>**</p><p>AtomicReference 和 AtomicReferenceFieldUpdater 的作用是差不多的，在用法上 AtomicReference 比 AtomicReferenceFIeldUpdater 更简单。</p><p>但是在内部实现上，AtomicReference 内部一样是有一个 volatile 变量。</p><p>使用 AtomicReference 和使用 AtomicReferenceFIeldUpdater 比起来，要多创建一个对象。</p><p>对于 32 位的机器，这个对象的头占 12 个字节，它的成员占 4 个字节，也就是多出来 16 个字节。</p><p>对于 64 位的机器，如果启动了指针压缩，那这个对象占用的也是 16 个字节。</p><p>对于 64 位的机器，如果没启动指针压缩，那么这个对象就会占 24 个字节，其中对象头占 16 个字节，成员占 8 个字节。</p><p>当要使用 AtomicReference 创建成千上万个对象时，这个开销就会变得很大。</p><p>这也就是为什么 BufferedInputStream 、Kotlin 协程 和 Kotlin 的 lazy 的实现会选择 AtomicReferenceFieldUpdater 作为原子类型。</p><p>因为开销的原因，所以一般只有在原子类型创建的实例确定了较少的情况下，比如说是单例，才会选择 AtomicReference，否则都是用 AtomicReferenceFieldUpdater。</p><h3 id="4-8-锁的使用技巧"><a href="#4-8-锁的使用技巧" class="headerlink" title="4.8 锁的使用技巧"></a><strong>4.8 锁的使用技巧</strong></h3><p>**<br>**</p><p>使用锁会带来一定的开销，而掌握锁的使用技巧可以在一定程度上减少锁带来的开销和潜在的问题，下面就是一些锁的使用技巧。</p><ul><li><p>长锁不如短锁</p><p>尽量只对必要的部分加锁</p></li><li><p>大锁不如小锁</p><p>进可能对加锁的对象拆分</p></li><li><p>公锁不如私锁</p><p>进可能把锁的逻辑放到私有代码中，如果让外部调用者加锁，可能会导致锁不正当使用导致死锁</p></li><li><p>嵌套锁不如扁平锁</p><p>在写代码时要避免锁嵌套</p></li><li><p>分离读写锁</p><p>尽可能将读锁和写锁分离</p></li><li><p>粗化高频锁</p><p>合并处理频繁而且过短的锁，因为每一把锁都会带来一定的开销</p></li><li><p>消除无用锁</p><p>尽可能不加锁，或者用 volatile 代替</p></li></ul><h2 id="-37"><a href="#-37" class="headerlink" title=""></a></h2><p><em>5</em></p><p>线程之间怎么协作？</p><p>线程间的常见协作方式有两种：等待和中断。</p><p>当一个线程中的操作需要等待另一个线程中的操作结束时，就涉及到等待型线程协作方式。</p><p>常用的等待型线程协作方式有 join、wait/notify、await/signal、await/countDown 和 CyclicBarrier 五种，下面我们就来看看这五种线程协作方式的用法和区别。</p><h3 id="5-1-join"><a href="#5-1-join" class="headerlink" title="5.1 join"></a><strong>5.1 join</strong></h3><p>**<br>**</p><p>使用 Thread.join() 方法，我们可以让一个线程等待另一个线程执行结束后再继续执行。</p><p>join() 方法实现等待是通过 wait() 方法实现的，在 join() 方法中，会不断判断调用了 join() 方法的线程是否还存活，是的话则继续等待。</p><h3 id="5-2-wait-notify"><a href="#5-2-wait-notify" class="headerlink" title="5.2 wait/notify"></a><strong>5.2 wait/notify</strong></h3><p>**<br>**</p><h4 id="5-2-1-wait-notify-简介"><a href="#5-2-1-wait-notify-简介" class="headerlink" title="5.2.1 wait/notify 简介"></a><strong>5.2.1 wait/notify 简介</strong></h4><p>**<br>**</p><p>在 Java 中，使用 Object.wait()/Object.wait(long) 和 Object.notify()/Object.notifyAll() 可以用于实现等待和通知。</p><p>省略了基本用法。</p><h4 id="5-2-2-wait-notify-原理"><a href="#5-2-2-wait-notify-原理" class="headerlink" title="5.2.2 wait/notify 原理"></a><strong>5.2.2 wait/notify 原理</strong></h4><p>**<br>**</p><p>JVM 会给每个对象维护一个入口集（Entry Set）和等待集（Wait Set）。</p><p>入口集用于存储申请该对象内部锁的线程，等待集用于存储对象上的等待线程。</p><p>wait() 方法会将当前线程暂停，在释放内部锁时，会将当前线程存入该方法所属的对象等待集中。</p><p>调用对象的 notify() 方法，会让该对象的等待集中的任意一个线程唤醒，被唤醒的线程会继续留在对象的等待集中，直到该线程再次持有对应的内部锁时，wait() 方法就会把当前线程从对象的等待集中移除。</p><p>添加当前线程到等待集、暂停当前线程、释放锁以及把唤醒后的线程从对象的等待集中移除，都是在 wait() 方法中实现的。</p><p>在 wait() 方法的 native 代码中，会判断线程是否持有当前对象的内部锁，如果没有的话，就会报非法监视器状态异常，这也就是为什么要在同步代码块中执行 wait() 方法。</p><h3 id="5-3-await-signal"><a href="#5-3-await-signal" class="headerlink" title="5.3 await/signal"></a><strong>5.3 await/signal</strong></h3><p>**<br>**</p><h4 id="5-3-1-await-signal-简介"><a href="#5-3-1-await-signal-简介" class="headerlink" title="5.3.1 await/signal 简介"></a><strong>5.3.1 await/signal 简介</strong></h4><p>**<br>**</p><p>wait()/notify() 过于底层，而且还存在两个问题，一是过早唤醒、二是无法区分 Object.wait(ms) 返回是由于等待超时还是被通知线程唤醒。</p><p>使用 await/signal 协作方式有下面几个要点。</p><ul><li><p>Condition 接口</p><p>在 JDK 5 中引入了 Condition（条件变量） 接口，使用 Condition 也可以实现等待/通知，而且不存在上面提到的两个问题。</p><p>Condition 接口提供的 await()/signal()/signalAll() 相当于是 Object 提供的 wait()/notify()/notifyAll()。</p><p>通过 Lock.newCondition() 可以获得一个 Condition 实例。</p></li><li><p>持有锁</p><p>与 wait/notify 类似，wait/notify 需要线程持有所属对象的内部锁，而 await/signal 要求线程持有 Condition 实例的显式锁。</p></li><li><p>等待队列</p><p>Condition 实例也叫条件变量或条件队列，每个 Condition 实例内部都维护了一个用于存储等待线程的等待队列，相当于是 Object 中的等待集。</p></li><li><p>循环语句</p><p>对于保护条件的判断和 await() 方法的调用，要放在循环语句中</p></li><li><p>引导区内</p><p>循环语句和执行目标动作要放在同一个显式锁引导的临界区中，这么做是为了避免欺骗性唤醒和信号丢失的问题</p></li></ul><h4 id="-38"><a href="#-38" class="headerlink" title=""></a></h4><h4 id="5-3-2-await-signal-基本用法"><a href="#5-3-2-await-signal-基本用法" class="headerlink" title="5.3.2 await/signal 基本用法"></a><strong>5.3.2 await/signal 基本用法</strong></h4><p>**<br>**</p><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-keyword">private</span> Condition condition = <span class="hljs-keyword">lock</span>.newCondition();<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> boolean conditionSatisfied = <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startWait</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;等待线程获取了锁&quot;</span>);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;保护条件不成立，等待线程进入等待状态&quot;</span>);      condition.<span class="hljs-keyword">await</span>();    &#125;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;等待线程被唤醒，开始执行目标动作&quot;</span>);  &#125; catch (InterruptedException e) &#123;    e.printStackTrace();  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">lock</span>.unlock();    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;等待线程释放了锁&quot;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startNotify</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;通知线程获取了锁&quot;</span>);  <span class="hljs-keyword">try</span> &#123;    conditionSatisfied = <span class="hljs-literal">true</span>;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;通知线程即将唤醒等待线程&quot;</span>);    condition.signal();  &#125; <span class="hljs-keyword">finally</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;通知线程释放了锁&quot;</span>);    <span class="hljs-keyword">lock</span>.unlock();  &#125;&#125;</code></pre><p>当我们在两个线程中分别执行了上面的两个函数后，能得到下面的输出。</p><pre><code class="hljs plain">等待线程获取了锁保护条件不成立，等待线程进入等待状态通知线程获取了锁通知线程即将唤醒等待线程等待线程被唤醒，开始执行目标动作</code></pre><h3 id="5-4-await-countDown"><a href="#5-4-await-countDown" class="headerlink" title="5.4 await/countDown"></a><strong>5.4 await/countDown</strong></h3><p>**<br>**</p><h4 id="5-4-1-await-countDown-简介"><a href="#5-4-1-await-countDown-简介" class="headerlink" title="5.4.1 await/countDown 简介"></a><strong>5.4.1 await/countDown 简介</strong></h4><p>**<br>**</p><p>使用 join() 实现的是一个线程等待另一个线程执行结束，但是有的时候我们只是想要一个特定的操作执行结束，不需要等待整个线程执行结束，这时候就可以使用 CountDownLatch 来实现。</p><p>await/countDown 协作方式有下面几个特点。</p><ul><li><p>先决操作</p><p>CountDownLatch 可以实现一个或多个线程等待其他线程完成一组特定的操作后才继续运行，这组线程就叫先决操作。</p></li><li><p>先决操作数</p><p>CountDownLatch 内部维护了一个用于计算未完成先决操作数的 count 值，每当 CountDownLatch.countDown() 方法执行一次，这个值就会减 1。</p><p>未完成先决操作数 count 是在 CountDownLatch 的构造函数中设置的。</p><p>要注意的是，这个值不能小于 0，否则会报非法参数异常。</p></li><li><p>一次性</p><p>当计数器的值为 0 时，后续再调用 await() 方法不会再让执行线程进入等待状态，所以说 CountDownLatch 是一次性协作。</p></li><li><p>不用加锁</p><p>CountDownLatch 内部封装了对 count 值的等待和通知逻辑，所以在使用 CountDownLatch 实现等待/通知不需要加锁</p></li><li><p>await()</p><p>CountDownLatch.await() 可以让线程进入等待状态，当 CountDownLatch 中的 count 值为 0 时，表示需要等待的先决操作已经完成。</p></li><li><p>countDown()</p><p>调用 CountDownLatch.countDown() 方法后，count 值就会减 1，并且在 count 值为 0 时，会唤醒对应的等待线程。</p></li></ul><h4 id="-39"><a href="#-39" class="headerlink" title=""></a></h4><h4 id="5-4-2-await-countDown-基本用法"><a href="#5-4-2-await-countDown-基本用法" class="headerlink" title="5.4.2 await/countDown 基本用法"></a><strong>5.4.2 await/countDown 基本用法</strong></h4><p>**<br>**</p><pre><code class="hljs reasonml">public void <span class="hljs-keyword">try</span><span class="hljs-constructor">AwaitCountDown()</span> &#123;  start<span class="hljs-constructor">WaitThread()</span>;  start<span class="hljs-constructor">CountDownThread()</span>;  start<span class="hljs-constructor">CountDownThread()</span>;&#125;</code></pre><pre><code class="hljs reasonml">final <span class="hljs-built_in">int</span> prerequisiteOperationCount = <span class="hljs-number">2</span>;final CountDownLatch latch = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CountDownLatch(<span class="hljs-params">prerequisiteOperationCount</span>)</span>;<span class="hljs-keyword">private</span> void start<span class="hljs-constructor">Wait()</span> throws InterruptedException &#123;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;等待线程进入等待状态&quot;</span>);  latch.await<span class="hljs-literal">()</span>;  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;等待线程结束等待&quot;</span>);&#125;</code></pre><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startCountDown</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-keyword">try</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;执行先决操作&quot;</span>);  &#125; <span class="hljs-keyword">finally</span> &#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;计数值减 1&quot;</span>);    latch.countDown();  &#125;&#125;</code></pre><p>当我们在两个线程中分别执行 startWait() 和 startCountDown() 方法后，我们会得到下面的输出。</p><pre><code class="hljs angelscript">等待线程进入等待状态执行先决操作计数值减 <span class="hljs-number">1</span>执行先决操作计数值减 <span class="hljs-number">1</span>等待线程结束等待</code></pre><p>除此以外还有 CyclicBarrier 等…</p><h2 id="-40"><a href="#-40" class="headerlink" title=""></a></h2><p><em>6</em></p><p>怎么让一个线程停止？</p><h3 id="-41"><a href="#-41" class="headerlink" title=""></a></h3><h3 id="6-1-stop-方法"><a href="#6-1-stop-方法" class="headerlink" title="6.1 stop() 方法"></a><strong>6.1 stop() 方法</strong></h3><p>**<br>**</p><p>JDK 中的 stop() 方法很早就被弃用了，之所以会被弃用，我们可以来看下 stop() 方法可能导致的两种情况。</p><p>第一种情况，假如现在有线程 A 和 线程 B，线程 A 持有了线程 B 需要的锁，然后线程 A 被 stop() 强行结束了，导致这个锁没有被释放，那线程 B 就一直拿不到这个锁了，相当于是线程 B 中的任务永远无法执行了。</p><p>第二种情况，假如线程 A 正在修改一个变量，修改到一半，然后被 stop() 强行结束了，这时候线程 B 去读取这个变量，读取到的就是一个异常值，这就可能导致线程 B 出现异常。</p><p>因为上述两种资源清理的问题，所以现在很多语言都废弃了线程的 stop() 方法。</p><p>虽然线程不能被简单粗暴地终止，但是线程执行的任务是可以停止的，下面我们就来看看怎么停止任务。</p><h3 id="6-2-interrupt-方法"><a href="#6-2-interrupt-方法" class="headerlink" title="6.2 interrupt() 方法"></a><strong>6.2 interrupt() 方法</strong></h3><p>**<br>**</p><p>当我们调用 sleep() 方法时，编译器会要求我们捕获中断异常 InterruptedException，这是因为线程的休眠状态可能会被中断。</p><p>在线程休眠期间，如果其他地方调用了线程的 interrupt() 方法，那么这个休眠状态就会被中断，中断后就会接收到一个中断异常。</p><p>我们可以在捕获到中断异常后释放锁，比如关闭流或文件。</p><p>但是调用线程的 interrupt() 方法不是百分百能中断任务的，假如我们现在有一个线程，它的 run() 方法中有个 while 循环在执行某些操作，那么在其他地方调用该线程的 interrupt() 方法并不能中断这个任务。</p><p>在这种情况下，我们可以通过 interrupted() 或 isInterruped() 方法判断任务是否被中断。</p><p>interrupted() 与 isInterrupted() 方法都可以获取线程的中断状态，但它们有下面一些区别。</p><ul><li><p>静态</p><p>interrupted() 是静态方法，isInterrupted() 是非静态方法</p></li><li><p>重置</p><p>interrupted() 会重置中断状态，也就是不管这次获取到的中断状态是 true 还是 false，下次获取到的中断状态都是 false</p><p>isInterrupted() 不会重置中断状态，也就是调用了线程的 interrupt() 方法后，通过该方法获取到的中断状态会一直为 true</p></li></ul><p>不论是使用 interrupted() 还是 isInterrupted() 方法，本质上都是通过 Native 层的布尔标志位判断的。</p><h3 id="6-3-布尔标志位"><a href="#6-3-布尔标志位" class="headerlink" title="6.3 布尔标志位"></a><strong>6.3 布尔标志位</strong></h3><p>**<br>**</p><p>既然 interrupt() 只是对布尔值的一个修改，那我们可以在 Java 层自己设一个布尔标志位，让每个线程共享这个布尔值。</p><p>当我们想取消某个任务时，就在外部把这个标志位改为 true。</p><ul><li><p>注意事项</p><p>直接使用布尔标志位会有可见性问题，所以要用 volatile 关键字修饰这个值。</p></li><li><p>使用场景</p><p>当我们需要用到 sleep() 方法时，我们可以使用 interrupt() 来中断任务，其他时候可以使用布尔标志位。</p></li></ul><h2 id="-42"><a href="#-42" class="headerlink" title=""></a></h2><p><em>7</em></p><p>使用线程有哪些准则？</p><p>在使用线程执行异步任务的过程中，我们要准收一些使用准则，这样能在一定程度上避免使用线程的时候带来的问题。</p><p>常见的五个线程使用准则是：严谨直接创建线程、使用基础线程池、选择合适的异步方式、线程必须命名以及重视优先级设置。</p><ol><li><p>严禁直接创建线程</p><p>直接创建线程除了简单方便之外，没有其他优势，所以在实际项目开发过程中，一定要严禁直接创建线程执行异步任务。</p></li><li><p>提供基础线程池供各个业务线使用</p><p>这个准则是为了避免各个业务线各自维护一套线程池，导致线程数过多。</p><p>假如我们有 10 条业务线，如果每条业务线都维护一个线程池，假如这个线程池的核心数是 8，那么我们就有 80 条线程，这明显是不合理的。</p></li><li><p>选择合适的异步方式</p><p>HandlerThread、IntentService 和 RxJava 等方式都可以执行异步任务，但是要根据任务类型来选择合适的异步方式。</p><p>假如我们有一个可能会长时间执行，但是优先级较低的任务，我们就可以选择用 HandlerThread。</p><p>还有一种情况就是我们需要执行一个定时任务，这种情况下更适合使用线程池来操作。</p></li><li><p>线程必须命名</p><p>当我们开发组成员比较多的时候，不论是使用线程还是使用线程池，如果我们不对我们创建的线程命名，如果这个线程发生了异常，我们光靠默认线程名是不知道要找哪个开发人员的。</p><p>如果我们对每个线程都命名了，就可以快速地定位到线程的创建者，可以把问题交给他来解决。</p><p>我们可以在运行期通过 Thread.currentThread().setName(name) 修改线程的名字。</p><p>如果在一段时间内是我们业务线使用，我们可以把线程的名字改成我们业务线的标志，在任务完成后，再把名字改回来。</p></li><li><p>重视优先级设置</p><p>Java 采用的是抢占式调度模型，高优先级的任务能先占用 CPU，如果我们想让某个任务先完成，我们可以给它设置一个较高的优先级。</p><p>设置的方式就是通过 android.os.Process.setThreadPriority(priority)，这个 priority 的值越小，优先级就越高，它的取值范围在 -20~19。</p></li></ol><h2 id="-43"><a href="#-43" class="headerlink" title=""></a></h2><p><em>8</em></p><p>怎么在 Android 中执行异步任务？</p><p>在这一节，我们会介绍 Android 中常用的 7 种异步方式：Thread、HandlerThread、IntentService、AsyncTask、线程池、RxJava 和 Kotlin 协程。</p><p>这些感觉大家都熟悉呀，略。</p>]]></content>
    
    
    <categories>
      
      <category>异步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RxJava操作符合集</title>
    <link href="/Blog/2020/11/23/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%90%88%E9%9B%86/"/>
    <url>/Blog/2020/11/23/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="RxJava2-只看这一篇文章就够了"><a href="#RxJava2-只看这一篇文章就够了" class="headerlink" title="RxJava2 只看这一篇文章就够了"></a>RxJava2 只看这一篇文章就够了</h1><blockquote><p>本文由 <a href="http://renyugang.io/post/75">玉刚说写作平台</a> 提供写作赞助</p><p>原作者：<code>ZedeChan</code></p><p>版权声明：本文版权归微信公众号 <code>玉刚说</code> 所有，未经许可，不得以任何形式转载</p></blockquote><h1 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h1><p>RxJava 其实就是提供一套异步编程的 API，这套 API 是基于观察者模式的，而且是链式调用的，所以使用 RxJava 编写的代码的逻辑会非常简洁。</p><p>RxJava 有以下三个基本的元素：</p><ol><li>被观察者（Observable）</li><li>观察者（Observer）</li><li>订阅（subscribe）</li></ol><p>下面来说说以上三者是如何协作的：</p><p>首先在 gradle 文件中添加依赖：</p><pre><code class="hljs clean"><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;io.reactivex.rxjava2:rxjava:2.1.4&#x27;</span><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;io.reactivex.rxjava2:rxandroid:2.0.2&#x27;</span>复制代码</code></pre><ol><li>创建被观察者：</li></ol><pre><code class="hljs reasonml">Observable observable = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;<span class="hljs-literal">()</span> &#123;    @Override    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=========================currentThread name: &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);        e.on<span class="hljs-constructor">Next(1)</span>;        e.on<span class="hljs-constructor">Next(2)</span>;        e.on<span class="hljs-constructor">Next(3)</span>;        e.on<span class="hljs-constructor">Complete()</span>;    &#125;&#125;);复制代码</code></pre><ol><li>创建观察者：</li></ol><pre><code class="hljs lasso">Observer observer = <span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;;复制代码</code></pre><ol><li>订阅</li></ol><pre><code class="hljs abnf">observable.subscribe(observer)<span class="hljs-comment">;</span>复制代码</code></pre><p>这里其实也可以使用链式调用：</p><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=========================currentThread name: &quot;</span> + <span class="hljs-keyword">Thread</span>.currentThread().getName());        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>被观察者发送的事件有以下几种，总结如下表：</p><table><thead><tr><th>事件种类</th><th>作用</th></tr></thead><tbody><tr><td>onNext()</td><td>发送该事件时，观察者会回调 onNext() 方法</td></tr><tr><td>onError()</td><td>发送该事件时，观察者会回调 onError() 方法，当发送该事件之后，其他事件将不会继续发送</td></tr><tr><td>onComplete()</td><td>发送该事件时，观察者会回调 onComplete() 方法，当发送该事件之后，其他事件将不会继续发送</td></tr></tbody></table><p>其实可以把 RxJava 比喻成一个做果汁，家里有很多种水果（要发送的原始数据），你想榨点水果汁喝一下，这时候你就要想究竟要喝什么水果汁呢？如果你想喝牛油果雪梨柠檬汁，那你就要把这三种水果混在一起榨汁（使用各种操作符变换你想发送给观察者的数据），榨完后，你就可以喝上你想要的果汁了（把处理好的数据发送给观察者）。</p><p>总结如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/26/1639a8ee56b13c41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>下面就来讲解 RxJava 各种常见的操作符。</p><h1 id="1-创建操作符"><a href="#1-创建操作符" class="headerlink" title="1. 创建操作符"></a>1. 创建操作符</h1><p>以下就是讲解创建被观察者的各种操作符。</p><h2 id="1-1-create"><a href="#1-1-create" class="headerlink" title="1.1 create()"></a>1.1 create()</h2><h4 id="方法预览："><a href="#方法预览：" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs vim">public static <span class="hljs-symbol">&lt;T&gt;</span> Observable<span class="hljs-symbol">&lt;T&gt;</span> create(ObservableOnSubscribe<span class="hljs-symbol">&lt;T&gt;</span> <span class="hljs-keyword">source</span>)复制代码</code></pre><h4 id="有什么用："><a href="#有什么用：" class="headerlink" title="有什么用："></a>有什么用：</h4><p>创建一个被观察者</p><h4 id="怎么用："><a href="#怎么用：" class="headerlink" title="怎么用："></a>怎么用：</h4><pre><code class="hljs php">Observable&lt;<span class="hljs-keyword">String</span>&gt; observable = Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;<span class="hljs-keyword">String</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-keyword">String</span>&gt; e) throws <span class="hljs-built_in">Exception</span> &#123;        e.onNext(<span class="hljs-string">&quot;Hello Observer&quot;</span>);        e.onComplete();    &#125;&#125;);复制代码</code></pre><p>上面的代码非常简单，创建 ObservableOnSubscribe 并重写其 subscribe 方法，就可以通过 ObservableEmitter 发射器向观察者发送事件。</p><p>以下创建一个观察者，来验证这个被观察者是否成功创建。</p><pre><code class="hljs typescript">Observer&lt;<span class="hljs-built_in">String</span>&gt; observer = <span class="hljs-keyword">new</span> Observer&lt;<span class="hljs-built_in">String</span>&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.d(<span class="hljs-string">&quot;chan&quot;</span>,<span class="hljs-string">&quot;=============onNext &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(<span class="hljs-string">&quot;chan&quot;</span>,<span class="hljs-string">&quot;=============onComplete &quot;</span>);    &#125;&#125;;        observable.subscribe(observer);        复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">16</span>:<span class="hljs-number">16</span>:<span class="hljs-number">50.654</span> <span class="hljs-number">22935</span><span class="hljs-number">-22935</span>/com.example.louder.rxjavademo D/chan: =============onNext Hello Observer=============onComplete复制代码</code></pre><h2 id="1-2-just"><a href="#1-2-just" class="headerlink" title="1.2 just()"></a>1.2 just()</h2><h4 id="方法预览：-1"><a href="#方法预览：-1" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs excel">public static &lt;<span class="hljs-built_in">T</span>&gt; Observable&lt;<span class="hljs-built_in">T</span>&gt; just(<span class="hljs-built_in">T</span> item) ......public static &lt;<span class="hljs-built_in">T</span>&gt; Observable&lt;<span class="hljs-built_in">T</span>&gt; just(<span class="hljs-built_in">T</span> item1, <span class="hljs-built_in">T</span> item2, <span class="hljs-built_in">T</span> item3, <span class="hljs-built_in">T</span> item4, <span class="hljs-built_in">T</span> item5, <span class="hljs-built_in">T</span> item6, <span class="hljs-built_in">T</span> item7, <span class="hljs-built_in">T</span> item8, <span class="hljs-built_in">T</span> item9, <span class="hljs-built_in">T</span> item10)复制代码</code></pre><h4 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>创建一个被观察者，并发送事件，发送的事件不可以超过10个以上。</p><h4 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>上面的代码直接使用链式调用，代码也非常简单，这里就不细说了，看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">16</span>:<span class="hljs-number">27</span>:<span class="hljs-number">26.938</span> <span class="hljs-number">23281</span><span class="hljs-number">-23281</span>/? D/chan: =================onSubscribe=================onNext <span class="hljs-number">1</span>=================onNext <span class="hljs-number">2</span>=================onNext <span class="hljs-number">3</span>=================onComplete 复制代码</code></pre><h2 id="1-3-From-操作符"><a href="#1-3-From-操作符" class="headerlink" title="1.3 From 操作符"></a>1.3 From 操作符</h2><h2 id="1-3-1-fromArray"><a href="#1-3-1-fromArray" class="headerlink" title="1.3.1 fromArray()"></a>1.3.1 fromArray()</h2><h4 id="方法预览：-2"><a href="#方法预览：-2" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs pf">public static <span class="hljs-variable">&lt;T&gt;</span> Observable<span class="hljs-variable">&lt;T&gt;</span> <span class="hljs-keyword">from</span>Array(T... items)复制代码</code></pre><h4 id="有什么用？-1"><a href="#有什么用？-1" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量，并且可以传入一个数组。</p><h4 id="怎么用？-1"><a href="#怎么用？-1" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml">Integer <span class="hljs-built_in">array</span><span class="hljs-literal">[]</span> = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>from<span class="hljs-constructor">Array(<span class="hljs-params">array</span>)</span>.subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=================onSubscribe&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Next(Integer <span class="hljs-params">integer</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=================onNext &quot;</span> + integer);    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=================onError &quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>代码和 just() 基本上一样，直接看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">23.797</span> <span class="hljs-number">23574</span><span class="hljs-number">-23574</span>/com.example.louder.rxjavademo D/chan: =================onSubscribe=================onNext <span class="hljs-number">1</span>=================onNext <span class="hljs-number">2</span>=================onNext <span class="hljs-number">3</span>=================onNext <span class="hljs-number">4</span>=================onComplete 复制代码</code></pre><h2 id="1-3-2-fromCallable"><a href="#1-3-2-fromCallable" class="headerlink" title="1.3.2 fromCallable()"></a>1.3.2 fromCallable()</h2><h4 id="方法预览：-3"><a href="#方法预览：-3" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; fromCallable(<span class="hljs-keyword">Callable</span><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; supplier)复制代码</code></pre><h4 id="有什么用？-2"><a href="#有什么用？-2" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这里的 Callable 是 java.util.concurrent 中的 Callable，Callable 和 Runnable 的用法基本一致，只是它会返回一个结果值，这个结果值就是发给观察者的。</p><h4 id="怎么用？-2"><a href="#怎么用？-2" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.fromCallable(<span class="hljs-built_in">new</span> Callable &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">Integer</span> <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;================accept &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">13</span>:<span class="hljs-number">01</span>:<span class="hljs-number">43.009</span> <span class="hljs-number">6890</span><span class="hljs-number">-6890</span>/? D/chan: ================accept <span class="hljs-number">1</span>复制代码</code></pre><h2 id="1-3-3-fromFuture"><a href="#1-3-3-fromFuture" class="headerlink" title="1.3.3 fromFuture()"></a>1.3.3 fromFuture()</h2><h4 id="方法预览：-4"><a href="#方法预览：-4" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Observable&lt;T&gt; fromFuture(<span class="hljs-keyword">Future</span>&lt;? extends T&gt; <span class="hljs-keyword">future</span>)复制代码</code></pre><h4 id="有什么用？-3"><a href="#有什么用？-3" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>参数中的 Future 是 java.util.concurrent 中的 Future，Future 的作用是增加了 cancel() 等方法操作 Callable，它可以通过 get() 方法来获取 Callable 返回的值。</p><h4 id="怎么用？-3"><a href="#怎么用？-3" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs aspectj">FutureTask &lt; String &gt; futureTask = <span class="hljs-keyword">new</span> FutureTask &lt; &gt; (<span class="hljs-keyword">new</span> Callable &lt; String &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;CallableDemo is Running&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回结果&quot;</span>;    &#125;&#125;);Observable.fromFuture(futureTask)    .doOnSubscribe(<span class="hljs-keyword">new</span> Consumer &lt; Disposable &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Disposable disposable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        futureTask.run();    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Consumer &lt; String &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;================accept &quot;</span> + s);    &#125;&#125;);复制代码</code></pre><p>doOnSubscribe() 的作用就是只有订阅时才会发送事件，具体会在下面讲解。</p><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">13</span>:<span class="hljs-number">54</span>:<span class="hljs-number">00.470</span> <span class="hljs-number">14429</span><span class="hljs-number">-14429</span>/com.example.rxjavademo D/chan: CallableDemo <span class="hljs-keyword">is</span> Running================accept 返回结果复制代码</code></pre><h2 id="1-3-4-fromIterable"><a href="#1-3-4-fromIterable" class="headerlink" title="1.3.4 fromIterable()"></a>1.3.4 fromIterable()</h2><h4 id="方法预览：-5"><a href="#方法预览：-5" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; fromIterable(<span class="hljs-keyword">Iterable</span><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source)复制代码</code></pre><h4 id="有什么用？-4"><a href="#有什么用？-4" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>直接发送一个 List 集合数据给观察者</p><h4 id="怎么用？-4"><a href="#怎么用？-4" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();<span class="hljs-built_in">list</span>.add(<span class="hljs-number">0</span>);<span class="hljs-built_in">list</span>.add(<span class="hljs-number">1</span>);<span class="hljs-built_in">list</span>.add(<span class="hljs-number">2</span>);<span class="hljs-built_in">list</span>.add(<span class="hljs-number">3</span>);Observable.fromIterable(<span class="hljs-built_in">list</span>).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">16</span>:<span class="hljs-number">43</span>:<span class="hljs-number">28.874</span> <span class="hljs-number">23965</span><span class="hljs-number">-23965</span>/? D/chan: =================onSubscribe=================onNext <span class="hljs-number">0</span>=================onNext <span class="hljs-number">1</span>=================onNext <span class="hljs-number">2</span>=================onNext <span class="hljs-number">3</span>=================onComplete 复制代码</code></pre><h2 id="1-4-defer"><a href="#1-4-defer" class="headerlink" title="1.4 defer()"></a>1.4 defer()</h2><h4 id="方法预览：-6"><a href="#方法预览：-6" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; defer(<span class="hljs-keyword">Callable</span><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;&gt; supplier)复制代码</code></pre><h4 id="有什么用？-5"><a href="#有什么用？-5" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法的作用就是直到被观察者被订阅后才会创建被观察者。</p><h4 id="怎么用？-5"><a href="#怎么用？-5" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs php"><span class="hljs-comment">// i 要定义为成员变量</span><span class="hljs-keyword">Integer</span> i = <span class="hljs-number">100</span>;        Observable&lt;<span class="hljs-keyword">Integer</span>&gt; observable = Observable.defer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">Callable</span>&lt;ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">Integer</span>&gt;&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> <span class="hljs-keyword">Integer</span>&gt; call() throws <span class="hljs-built_in">Exception</span> &#123;        <span class="hljs-keyword">return</span> Observable.just(i);    &#125;&#125;);i = <span class="hljs-number">200</span>;Observer observer = <span class="hljs-keyword">new</span> Observer&lt;<span class="hljs-keyword">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onSubscribe(Disposable d) &#123;    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onNext(<span class="hljs-keyword">Integer</span> <span class="hljs-keyword">integer</span>) &#123;        Log.d(TAG, <span class="hljs-string">&quot;================onNext &quot;</span> + <span class="hljs-keyword">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onError(<span class="hljs-built_in">Throwable</span> e) &#123;    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onComplete() &#123;    &#125;&#125;;observable.subscribe(observer);i = <span class="hljs-number">300</span>;observable.subscribe(observer);复制代码</code></pre><p>打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">01.443</span> <span class="hljs-number">26622</span><span class="hljs-number">-26622</span>/? D/chan: ================onNext <span class="hljs-number">200</span>================onNext <span class="hljs-number">300</span>复制代码</code></pre><p>因为 defer() 只有观察者订阅的时候才会创建新的被观察者，所以每订阅一次就会打印一次，并且都是打印 i 最新的值。</p><h2 id="1-5-timer"><a href="#1-5-timer" class="headerlink" title="1.5 timer()"></a>1.5 timer()</h2><h4 id="方法预览：-7"><a href="#方法预览：-7" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">timer</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> delay, TimeUnit <span class="hljs-built_in">unit</span></span>) </span><span class="hljs-function">......</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-6"><a href="#有什么用？-6" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当到指定时间后就会发送一个 0L 的值给观察者。</p><h4 id="怎么用？-6"><a href="#怎么用？-6" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.timer</span>(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Long &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Long aLong) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===============onNext &quot;</span> + aLong);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">27</span>:<span class="hljs-number">48.004</span> <span class="hljs-number">27204</span><span class="hljs-number">-27259</span>/com.example.louder.rxjavademo D/chan: ===============onNext <span class="hljs-number">0</span>复制代码</code></pre><h2 id="1-6-interval"><a href="#1-6-interval" class="headerlink" title="1.6 interval()"></a>1.6 interval()</h2><h4 id="方法预览：-8"><a href="#方法预览：-8" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">interval</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> period, TimeUnit <span class="hljs-built_in">unit</span></span>)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">interval</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> initialDelay, <span class="hljs-built_in">long</span> period, TimeUnit <span class="hljs-built_in">unit</span></span>)</span><span class="hljs-function">......</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-7"><a href="#有什么用？-7" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。</p><h4 id="怎么用？-7"><a href="#怎么用？-7" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.interval</span>(<span class="hljs-number">4</span>, TimeUnit.SECONDS)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Long &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onSubscribe &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onNext</span>(Long aLong) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onNext &quot;</span> + aLong);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">10.321</span> <span class="hljs-number">28723</span><span class="hljs-number">-28723</span>/com.example.louder.rxjavademo D/chan: ==============onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">14.324</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">0</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">18.324</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">1</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">22.323</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">26.323</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">30.323</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">4</span><span class="hljs-number">05</span><span class="hljs-number">-20</span> <span class="hljs-number">20</span>:<span class="hljs-number">48</span>:<span class="hljs-number">34.323</span> <span class="hljs-number">28723</span><span class="hljs-number">-28746</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">5</span>复制代码</code></pre><p>从时间就可以看出每隔4秒就会发出一次数字递增1的事件。这里说下 interval() 第三个方法的 initialDelay 参数，这个参数的意思就是 onSubscribe 回调之后，再次回调 onNext 的间隔时间。</p><h2 id="1-7-intervalRange"><a href="#1-7-intervalRange" class="headerlink" title="1.7 intervalRange()"></a>1.7 intervalRange()</h2><h4 id="方法预览：-9"><a href="#方法预览：-9" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public static Observable&lt;Long&gt; interval<span class="hljs-constructor">Range(<span class="hljs-params">long</span> <span class="hljs-params">start</span>, <span class="hljs-params">long</span> <span class="hljs-params">count</span>, <span class="hljs-params">long</span> <span class="hljs-params">initialDelay</span>, <span class="hljs-params">long</span> <span class="hljs-params">period</span>, TimeUnit <span class="hljs-params">unit</span>)</span>public static Observable&lt;Long&gt; interval<span class="hljs-constructor">Range(<span class="hljs-params">long</span> <span class="hljs-params">start</span>, <span class="hljs-params">long</span> <span class="hljs-params">count</span>, <span class="hljs-params">long</span> <span class="hljs-params">initialDelay</span>, <span class="hljs-params">long</span> <span class="hljs-params">period</span>, TimeUnit <span class="hljs-params">unit</span>, Scheduler <span class="hljs-params">scheduler</span>)</span>复制代码</code></pre><h4 id="有什么用？-8"><a href="#有什么用？-8" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。</p><h4 id="怎么用？-8"><a href="#怎么用？-8" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.intervalRange</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Long &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onSubscribe &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onNext</span>(Long aLong) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onNext &quot;</span> + aLong);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">01.672</span> <span class="hljs-number">2504</span><span class="hljs-number">-2504</span>/com.example.louder.rxjavademo D/chan: ==============onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">03.674</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">04.674</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">05.674</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">4</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">06.673</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">5</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span>:<span class="hljs-number">07.674</span> <span class="hljs-number">2504</span><span class="hljs-number">-2537</span>/com.example.louder.rxjavademo D/chan: ==============onNext <span class="hljs-number">6</span>复制代码</code></pre><p>可以看出收到5次 onNext 事件，并且是从 2 开始的。</p><h2 id="1-8-range"><a href="#1-8-range" class="headerlink" title="1.8 range()"></a>1.8 range()</h2><h4 id="方法预览：-10"><a href="#方法预览：-10" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> static Observable&lt;<span class="hljs-keyword">Integer</span>&gt; <span class="hljs-built_in">range</span>(<span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> start, <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>)复制代码</code></pre><h4 id="有什么用？-9"><a href="#有什么用？-9" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>同时发送一定范围的事件序列。</p><h4 id="怎么用？-9"><a href="#怎么用？-9" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onSubscribe &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onNext</span>(Integer aLong) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==============onNext &quot;</span> + aLong);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">00</span>:<span class="hljs-number">09</span>:<span class="hljs-number">17.202</span> <span class="hljs-number">2921</span><span class="hljs-number">-2921</span>/? D/chan: ==============onSubscribe ==============onNext <span class="hljs-number">2</span>==============onNext <span class="hljs-number">3</span>==============onNext <span class="hljs-number">4</span>==============onNext <span class="hljs-number">5</span>==============onNext <span class="hljs-number">6</span>复制代码</code></pre><h2 id="1-9-rangeLong"><a href="#1-9-rangeLong" class="headerlink" title="1.9 rangeLong()"></a>1.9 rangeLong()</h2><h4 id="方法预览：-11"><a href="#方法预览：-11" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">rangeLong</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> start, <span class="hljs-built_in">long</span> count</span>)</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-10"><a href="#有什么用？-10" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>作用与 range() 一样，只是数据类型为 Long</p><h4 id="怎么用？-10"><a href="#怎么用？-10" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>用法与 range() 一样，这里就不再赘述了。</p><h2 id="1-10-empty-amp-never-amp-error"><a href="#1-10-empty-amp-never-amp-error" class="headerlink" title="1.10 empty() &amp; never() &amp; error()"></a>1.10 empty() &amp; never() &amp; error()</h2><h4 id="方法预览：-12"><a href="#方法预览：-12" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">empty</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Observable&lt;T&gt; <span class="hljs-title">never</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Observable&lt;T&gt; <span class="hljs-title">error</span>(<span class="hljs-params">final Throwable exception</span>)</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-11"><a href="#有什么用？-11" class="headerlink" title="有什么用？"></a>有什么用？</h4><ol><li>empty() ： 直接发送 onComplete() 事件</li><li>never()：不发送任何事件</li><li>error()：发送 onError() 事件</li></ol><h4 id="怎么用？-11"><a href="#怎么用？-11" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.empty().subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-built_in">Object</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span> + e);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">06</span>:<span class="hljs-number">11.881</span> <span class="hljs-number">15798</span><span class="hljs-number">-15798</span>/com.example.rxjavademo D/chan: ==================onSubscribe==================onComplete复制代码</code></pre><p>换成 never() 的打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">12</span>:<span class="hljs-number">17.554</span> <span class="hljs-number">16805</span><span class="hljs-number">-16805</span>/com.example.rxjavademo D/chan: ==================onSubscribe复制代码</code></pre><p>换成 error() 的打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">12</span>:<span class="hljs-number">58.483</span> <span class="hljs-number">17817</span><span class="hljs-number">-17817</span>/com.example.rxjavademo D/chan: ==================onSubscribe==================onError java.lang.NullPointerException复制代码</code></pre><h1 id="2-转换操作符"><a href="#2-转换操作符" class="headerlink" title="2. 转换操作符"></a>2. 转换操作符</h1><h2 id="2-1-map"><a href="#2-1-map" class="headerlink" title="2.1 map()"></a>2.1 map()</h2><h4 id="方法预览：-13"><a href="#方法预览：-13" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Observable&lt;R&gt; map(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> R&gt; mapper)复制代码</code></pre><h4 id="有什么用？-12"><a href="#有什么用？-12" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>map 可以将被观察者发送的数据类型转变成其他的类型</p><h4 id="怎么用？-12"><a href="#怎么用？-12" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>以下代码将 Integer 类型的数据转换成 String。</p><pre><code class="hljs typescript">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Integer, <span class="hljs-built_in">String</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Integer integer) throws Exception &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m &quot;</span> + integer;    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-built_in">String</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.e(TAG, <span class="hljs-string">&quot;===================onSubscribe&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.e(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs diff">05-21 09:16:03.490 5700-5700/com.example.rxjavademo E/chan: <span class="hljs-comment">===================onSubscribe</span><span class="hljs-comment">===================onNext I&#x27;m 1</span><span class="hljs-comment">===================onNext I&#x27;m 2</span><span class="hljs-comment">===================onNext I&#x27;m 3</span>复制代码</code></pre><h2 id="2-2-flatMap"><a href="#2-2-flatMap" class="headerlink" title="2.2 flatMap()"></a>2.2 flatMap()</h2><h4 id="方法预览：-14"><a href="#方法预览：-14" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Observable&lt;R&gt; flatMap(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> R&gt;&gt; mapper)<span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span>复制代码</code></pre><h4 id="有什么用？-13"><a href="#有什么用？-13" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。</p><h4 id="怎么用？-13"><a href="#怎么用？-13" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable。现在用一个例子来说明 flatMap() 的用法。</p><p>假设一个有一个 Person 类，这个类的定义如下：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;    <span class="hljs-keyword">private</span> List&lt;Plan&gt; planList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, List&lt;Plan&gt; planList</span>)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.planList = planList;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> List&lt;Plan&gt; <span class="hljs-function"><span class="hljs-title">getPlanList</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> planList;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setPlanList</span>(<span class="hljs-params">List&lt;Plan&gt; planList</span>)</span> &#123;        <span class="hljs-built_in">this</span>.planList = planList;    &#125;&#125;复制代码</code></pre><p>Person 类有一个 name 和 planList 两个变量，分别代表的是人名和计划清单。</p><p>Plan 类的定义如下：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> time;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> content;    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-built_in">String</span>&gt; actionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Plan</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> time, <span class="hljs-built_in">String</span> content</span>)</span> &#123;        <span class="hljs-built_in">this</span>.time = time;        <span class="hljs-built_in">this</span>.content = content;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getTime</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> time;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> time</span>)</span> &#123;        <span class="hljs-built_in">this</span>.time = time;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getContent</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> content;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setContent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>)</span> &#123;        <span class="hljs-built_in">this</span>.content = content;    &#125;    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">getActionList</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> actionList;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setActionList</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">String</span>&gt; actionList</span>)</span> &#123;        <span class="hljs-built_in">this</span>.actionList = actionList;    &#125;&#125;复制代码</code></pre><p>现在有一个需求就是要将 Person 集合中的每个元素中的 Plan 的 action 打印出来。 首先用 map() 来实现这个需求看看：</p><pre><code class="hljs typescript">Observable.fromIterable(personList).map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Person, List &lt; Plan &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> List &lt; Plan &gt; apply(Person person) throws Exception &#123;        <span class="hljs-keyword">return</span> person.getPlanList();    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; List &lt; Plan &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">List &lt; Plan &gt; plans</span>)</span> &#123;        <span class="hljs-keyword">for</span> (Plan plan: plans) &#123;            List &lt; <span class="hljs-built_in">String</span> &gt; planActionList = plan.getActionList();            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> action: planActionList) &#123;                Log.d(TAG, <span class="hljs-string">&quot;==================action &quot;</span> + action);            &#125;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;&#125;);复制代码</code></pre><p>可以看到 onNext() 用了嵌套 for 循环来实现，如果代码逻辑复杂起来的话，可能需要多重循环才可以实现。</p><p>现在看下使用 flatMap() 实现：</p><pre><code class="hljs typescript">Observable.fromIterable(personList).flatMap(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Person, ObservableSource &lt; Plan &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> ObservableSource &lt; Plan &gt; <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">Person person</span>)</span> &#123;        <span class="hljs-keyword">return</span> Observable.fromIterable(person.getPlanList());    &#125;&#125;).flatMap(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Plan, ObservableSource &lt; <span class="hljs-built_in">String</span> &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> ObservableSource &lt; <span class="hljs-built_in">String</span> &gt; apply(Plan plan) throws Exception &#123;        <span class="hljs-keyword">return</span> Observable.fromIterable(plan.getActionList());    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-built_in">String</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================action: &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;&#125;);复制代码</code></pre><p>从代码可以看出，只需要两个 flatMap() 就可以完成需求，并且代码逻辑非常清晰。</p><h2 id="2-3-concatMap"><a href="#2-3-concatMap" class="headerlink" title="2.3 concatMap()"></a>2.3 concatMap()</h2><h4 id="方法预览：-15"><a href="#方法预览：-15" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Observable&lt;R&gt; concatMap(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> R&gt;&gt; mapper)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; Observable&lt;R&gt; concatMap(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> R&gt;&gt; mapper, <span class="hljs-built_in">int</span> prefetch)复制代码</code></pre><h4 id="有什么用？-14"><a href="#有什么用？-14" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>concatMap() 和 flatMap() 基本上是一样的，只不过 concatMap() 转发出来的事件是有序的，而 flatMap() 是无序的。</p><h4 id="怎么用？-14"><a href="#怎么用？-14" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>还是使用上面 flatMap() 的例子来讲解，首先来试下 flatMap() 来验证发送的事件是否是无序的，代码如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.fromIterable</span>(personList)<span class="hljs-selector-class">.flatMap</span>(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () &#123;    <span class="hljs-variable">@Override</span>    public ObservableSource &lt; Plan &gt; apply(Person person) &#123;        <span class="hljs-selector-tag">if</span> (<span class="hljs-string">&quot;chan&quot;</span>.equals(person.getName())) &#123;            <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.fromIterable</span>(person.getPlanList())<span class="hljs-selector-class">.delay</span>(<span class="hljs-number">10</span>, TimeUnit.MILLISECONDS);        &#125;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.fromIterable</span>(person.getPlanList());    &#125;&#125;)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Plan &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Plan plan) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;==================plan &quot;</span> + plan.getContent());    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>为了更好的验证 flatMap 是无序的，使用了一个 delay() 方法来延迟，直接看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">13</span>:<span class="hljs-number">57</span>:<span class="hljs-number">14.031</span> <span class="hljs-number">21616</span><span class="hljs-number">-21616</span>/com.example.rxjavademo D/chan: ==================plan chan 上课==================plan chan 写作业==================plan chan 打篮球<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">13</span>:<span class="hljs-number">57</span>:<span class="hljs-number">14.041</span> <span class="hljs-number">21616</span><span class="hljs-number">-21641</span>/com.example.rxjavademo D/chan: ==================plan Zede 开会==================plan Zede 写代码==================plan Zede 写文章复制代码</code></pre><p>可以看到本来 Zede 的事件发送顺序是排在 chan 事件之前，但是经过延迟后， 这两个事件序列发送顺序互换了。</p><p>现在来验证下 concatMap() 是否是有序的，使用上面同样的代码，只是把 flatMap() 换成 concatMap()，打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">42.917</span> <span class="hljs-number">21799</span><span class="hljs-number">-21823</span>/com.example.rxjavademo D/chan: ==================plan Zede 开会==================plan Zede 写代码==================plan Zede 写文章==================plan chan 上课==================plan chan 写作业==================plan chan 打篮球复制代码</code></pre><p>这就代表 concatMap() 转换后发送的事件序列是有序的了。</p><h2 id="2-4-buffer"><a href="#2-4-buffer" class="headerlink" title="2.4 buffer()"></a>2.4 buffer()</h2><h4 id="方法预览：-16"><a href="#方法预览：-16" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;List&lt;T&gt;&gt; buffer(<span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>, <span class="hljs-built_in">int</span> skip)......复制代码</code></pre><h4 id="有什么用？-15"><a href="#有什么用？-15" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。</p><h4 id="怎么用？-15"><a href="#怎么用？-15" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>buffer 有两个参数，一个是 count，另一个 skip。count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素。这样说可能还是有点抽象，直接看代码：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.just</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-selector-class">.buffer</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; List &lt; Integer &gt;&gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(List &lt; Integer &gt; integers) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;================缓冲区大小： &quot;</span> + integers.size());        <span class="hljs-selector-tag">for</span> (Integer <span class="hljs-attribute">i</span>: integers) &#123;            <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;================元素： &quot;</span> + i);        &#125;    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">14</span>:<span class="hljs-number">09</span>:<span class="hljs-number">34.015</span> <span class="hljs-number">22421</span><span class="hljs-number">-22421</span>/com.example.rxjavademo D/chan: ================缓冲区大小： <span class="hljs-number">2</span>================元素： <span class="hljs-number">1</span>================元素： <span class="hljs-number">2</span>================缓冲区大小： <span class="hljs-number">2</span>================元素： <span class="hljs-number">2</span>================元素： <span class="hljs-number">3</span>================缓冲区大小： <span class="hljs-number">2</span>================元素： <span class="hljs-number">3</span>================元素： <span class="hljs-number">4</span>================缓冲区大小： <span class="hljs-number">2</span>================元素： <span class="hljs-number">4</span>================元素： <span class="hljs-number">5</span>================缓冲区大小： <span class="hljs-number">1</span>================元素： <span class="hljs-number">5</span>复制代码</code></pre><p>从结果可以看出，每次发送事件，指针都会往后移动一个元素再取值，直到指针移动到没有元素的时候就会停止取值。</p><h2 id="2-5-groupBy"><a href="#2-5-groupBy" class="headerlink" title="2.5 groupBy()"></a>2.5 groupBy()</h2><h4 id="方法预览：-17"><a href="#方法预览：-17" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super T, ? <span class="hljs-keyword">extends</span> K&gt; keySelector)复制代码</code></pre><h4 id="有什么用？-16"><a href="#有什么用？-16" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将发送的数据进行分组，每个分组都会返回一个被观察者。</p><h4 id="怎么用？-16"><a href="#怎么用？-16" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>).groupBy(<span class="hljs-literal">new</span> Function &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer</span> % <span class="hljs-number">3</span>;    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; GroupedObservable &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt;&gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(GroupedObservable &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt; integerIntegerGroupedObservable) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================onNext &quot;</span>);        integerIntegerGroupedObservable.subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;                <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================GroupedObservable onSubscribe &quot;</span>);            &#125;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;                <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================GroupedObservable onNext  groupName: &quot;</span> + integerIntegerGroupedObservable.getKey() + <span class="hljs-string">&quot; value: &quot;</span> + <span class="hljs-built_in">integer</span>);            &#125;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;                <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================GroupedObservable onError &quot;</span>);            &#125;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;                <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================GroupedObservable onComplete &quot;</span>);            &#125;        &#125;);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>在 groupBy() 方法返回的参数是分组的名字，每返回一个值，那就代表会创建一个组，以上的代码就是将1~10的数据分成3组，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">02.062</span> <span class="hljs-number">21451</span><span class="hljs-number">-21451</span>/com.example.rxjavademo D/chan: ====================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">02.063</span> <span class="hljs-number">21451</span><span class="hljs-number">-21451</span>/com.example.rxjavademo D/chan: ====================onNext ====================GroupedObservable onSubscribe     ====================GroupedObservable onNext  groupName: <span class="hljs-number">2</span> value: <span class="hljs-number">5</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">2</span> value: <span class="hljs-number">2</span>====================onNext ====================GroupedObservable onSubscribe ====================GroupedObservable onNext  groupName: <span class="hljs-number">0</span> value: <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">02.064</span> <span class="hljs-number">21451</span><span class="hljs-number">-21451</span>/com.example.rxjavademo D/chan: ====================onNext ====================GroupedObservable onSubscribe ====================GroupedObservable onNext  groupName: <span class="hljs-number">1</span> value: <span class="hljs-number">4</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">1</span> value: <span class="hljs-number">1</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">0</span> value: <span class="hljs-number">6</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">2</span> value: <span class="hljs-number">8</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">0</span> value: <span class="hljs-number">9</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">1</span> value: <span class="hljs-number">7</span>====================GroupedObservable onNext  groupName: <span class="hljs-number">1</span> value: <span class="hljs-number">10</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">38</span>:<span class="hljs-number">02.065</span> <span class="hljs-number">21451</span><span class="hljs-number">-21451</span>/com.example.rxjavademo D/chan: ====================GroupedObservable onComplete ====================GroupedObservable onComplete ====================GroupedObservable onComplete ====================onComplete 复制代码</code></pre><p>可以看到返回的结果中是有3个组的。</p><h2 id="2-6-scan"><a href="#2-6-scan" class="headerlink" title="2.6 scan()"></a>2.6 scan()</h2><h4 id="方法预览：-18"><a href="#方法预览：-18" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs excel">public final Observable&lt;<span class="hljs-built_in">T</span>&gt; scan(BiFunction&lt;<span class="hljs-built_in">T</span>, <span class="hljs-built_in">T</span>, <span class="hljs-built_in">T</span>&gt; accumulator)复制代码</code></pre><h4 id="有什么用？-17"><a href="#有什么用？-17" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将数据以一定的逻辑聚合起来。</p><h4 id="怎么用？-17"><a href="#怎么用？-17" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).scan(<span class="hljs-literal">new</span> BiFunction &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>, <span class="hljs-built_in">Integer</span> integer2) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================apply &quot;</span>);        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================integer &quot;</span> + <span class="hljs-built_in">integer</span>);        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================integer2 &quot;</span> + integer2);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer</span> + integer2;    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================accept &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">45</span>:<span class="hljs-number">27.784</span> <span class="hljs-number">22519</span><span class="hljs-number">-22519</span>/com.example.rxjavademo D/chan: ====================accept <span class="hljs-number">1</span>====================apply ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">1</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">2</span>====================accept <span class="hljs-number">3</span>====================apply <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">45</span>:<span class="hljs-number">27.785</span> <span class="hljs-number">22519</span><span class="hljs-number">-22519</span>/com.example.rxjavademo D/chan: ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">3</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">3</span>====================accept <span class="hljs-number">6</span>====================apply ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">6</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">4</span>====================accept <span class="hljs-number">10</span>====================apply ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">10</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">5</span>====================accept <span class="hljs-number">15</span>复制代码</code></pre><h2 id="2-7-window"><a href="#2-7-window" class="headerlink" title="2.7 window()"></a>2.7 window()</h2><h4 id="方法预览：-19"><a href="#方法预览：-19" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(<span class="hljs-built_in">long</span> <span class="hljs-keyword">count</span>)......复制代码</code></pre><h4 id="有什么用？-18"><a href="#有什么用？-18" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>发送指定数量的事件时，就将这些事件分为一组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。</p><h4 id="怎么用？-18"><a href="#怎么用？-18" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).window(<span class="hljs-number">2</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Observable &lt; Integer &gt;&gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=====================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Observable &lt; Integer &gt; integerObservable</span>)</span> &#123;        integerObservable.subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;                Log.d(TAG, <span class="hljs-string">&quot;=====================integerObservable onSubscribe &quot;</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;                Log.d(TAG, <span class="hljs-string">&quot;=====================integerObservable onNext &quot;</span> + integer);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;                Log.d(TAG, <span class="hljs-string">&quot;=====================integerObservable onError &quot;</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;                Log.d(TAG, <span class="hljs-string">&quot;=====================integerObservable onComplete &quot;</span>);            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=====================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=====================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">15</span>:<span class="hljs-number">02</span>:<span class="hljs-number">20.654</span> <span class="hljs-number">25838</span><span class="hljs-number">-25838</span>/com.example.rxjavademo D/chan: =====================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">15</span>:<span class="hljs-number">02</span>:<span class="hljs-number">20.655</span> <span class="hljs-number">25838</span><span class="hljs-number">-25838</span>/com.example.rxjavademo D/chan: =====================<span class="hljs-built_in">int</span>egerObservable onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">15</span>:<span class="hljs-number">02</span>:<span class="hljs-number">20.656</span> <span class="hljs-number">25838</span><span class="hljs-number">-25838</span>/com.example.rxjavademo D/chan: =====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">1</span>=====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">2</span>=====================<span class="hljs-built_in">int</span>egerObservable onComplete =====================<span class="hljs-built_in">int</span>egerObservable onSubscribe =====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">3</span>=====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">4</span>=====================<span class="hljs-built_in">int</span>egerObservable onComplete =====================<span class="hljs-built_in">int</span>egerObservable onSubscribe =====================<span class="hljs-built_in">int</span>egerObservable onNext <span class="hljs-number">5</span>=====================<span class="hljs-built_in">int</span>egerObservable onComplete =====================onComplete 复制代码</code></pre><p>从结果可以发现，window() 将 1~5 的事件分成了3组。</p><h1 id="3-组合操作符"><a href="#3-组合操作符" class="headerlink" title="3. 组合操作符"></a>3. 组合操作符</h1><h2 id="3-1-concat"><a href="#3-1-concat" class="headerlink" title="3.1 concat()"></a>3.1 concat()</h2><h4 id="方法预览：-20"><a href="#方法预览：-20" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source1, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source2, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source3, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source4)......复制代码</code></pre><h4 id="有什么用？-19"><a href="#有什么用？-19" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。</p><h4 id="怎么用？-19"><a href="#怎么用？-19" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.concat</span>(Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),Observable.just(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),Observable.just(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>),Observable.just(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>))<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Integer integer) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;================onNext &quot;</span> + integer);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">26.738</span> <span class="hljs-number">7477</span><span class="hljs-number">-7477</span>/com.example.rxjavademo D/chan: ================onNext <span class="hljs-number">1</span>================onNext <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">26.739</span> <span class="hljs-number">7477</span><span class="hljs-number">-7477</span>/com.example.rxjavademo D/chan: ================onNext <span class="hljs-number">3</span>================onNext <span class="hljs-number">4</span>================onNext <span class="hljs-number">5</span>================onNext <span class="hljs-number">6</span>================onNext <span class="hljs-number">7</span>================onNext <span class="hljs-number">8</span>复制代码</code></pre><h2 id="3-2-concatArray"><a href="#3-2-concatArray" class="headerlink" title="3.2 concatArray()"></a>3.2 concatArray()</h2><h4 id="方法预览：-21"><a href="#方法预览：-21" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; concatArray(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;... sources)复制代码</code></pre><h4 id="有什么用？-20"><a href="#有什么用？-20" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 concat() 作用一样，不过 concatArray() 可以发送多于 4 个被观察者。</p><h4 id="怎么用？-20"><a href="#怎么用？-20" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.concatArray</span>(Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),Observable.just(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),Observable.just(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>),Observable.just(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>),Observable.just(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>))<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Integer integer) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;================onNext &quot;</span> + integer);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">15</span>:<span class="hljs-number">47</span>:<span class="hljs-number">18.581</span> <span class="hljs-number">9129</span><span class="hljs-number">-9129</span>/com.example.rxjavademo D/chan: ================onNext <span class="hljs-number">1</span>================onNext <span class="hljs-number">2</span>================onNext <span class="hljs-number">3</span>================onNext <span class="hljs-number">4</span>================onNext <span class="hljs-number">5</span>================onNext <span class="hljs-number">6</span>================onNext <span class="hljs-number">7</span>================onNext <span class="hljs-number">8</span>================onNext <span class="hljs-number">9</span>================onNext <span class="hljs-number">10</span>复制代码</code></pre><h2 id="3-3-merge"><a href="#3-3-merge" class="headerlink" title="3.3 merge()"></a>3.3 merge()</h2><h4 id="方法预览：-22"><a href="#方法预览：-22" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"> <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; merge(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source1, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source2, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source3, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source4)......复制代码</code></pre><h4 id="有什么用？-21"><a href="#有什么用？-21" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法月 concat() 作用基本一样，知识 concat() 是串行发送事件，而 merge() 并行发送事件。</p><h4 id="怎么用？-21"><a href="#怎么用？-21" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>现在来演示 concat() 和 merge() 的区别。</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.merge</span>(Observable.interval(<span class="hljs-number">1</span>, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () &#123;    <span class="hljs-variable">@Override</span>    public String apply(Long aLong) throws Exception &#123;        return <span class="hljs-string">&quot;A&quot;</span> + aLong;    &#125;&#125;),Observable.interval(<span class="hljs-number">1</span>, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () &#123;    <span class="hljs-variable">@Override</span>    public String apply(Long aLong) throws Exception &#123;        return <span class="hljs-string">&quot;B&quot;</span> + aLong;    &#125;&#125;))    <span class="hljs-selector-class">.subscribe</span>(new Observer &lt; String &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(String s) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;=====================onNext &quot;</span> + s);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onComplete() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">31.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B0<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">31.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A0<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">32.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A1<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">32.126</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B1<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">33.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A2<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">33.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B2<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">34.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A3<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">34.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B3<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">35.124</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A4<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">35.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B4<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">36.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12849</span>/com.example.rxjavademo D/chan: =====================onNext A5<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">36.125</span> <span class="hljs-number">12801</span><span class="hljs-number">-12850</span>/com.example.rxjavademo D/chan: =====================onNext B5......复制代码</code></pre><p>从结果可以看出，A 和 B 的事件序列都可以发出，将以上的代码换成 concat() 看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">52.352</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A0<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">53.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A1<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">54.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A2<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">55.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A3<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">56.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A4<span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>:<span class="hljs-number">57.351</span> <span class="hljs-number">14597</span><span class="hljs-number">-14621</span>/com.example.rxjavademo D/chan: =====================onNext A5......复制代码</code></pre><p>从结果可以知道，只有等到第一个被观察者发送完事件之后，第二个被观察者才会发送事件。</p><p>mergeArray() 与 merge() 的作用是一样的，只是它可以发送4个以上的被观察者，这里就不再赘述了。</p><h2 id="3-4-concatArrayDelayError-amp-mergeArrayDelayError"><a href="#3-4-concatArrayDelayError-amp-mergeArrayDelayError" class="headerlink" title="3.4 concatArrayDelayError() &amp; mergeArrayDelayError()"></a>3.4 concatArrayDelayError() &amp; mergeArrayDelayError()</h2><h4 id="方法预览：-23"><a href="#方法预览：-23" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; concatArrayDelayError(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;... sources)<span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; mergeArrayDelayError(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;... sources)复制代码</code></pre><h4 id="有什么用？-22"><a href="#有什么用？-22" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在 concatArray() 和 mergeArray() 两个方法当中，如果其中有一个被观察者发送了一个 Error 事件，那么就会停止发送事件，如果你想 onError() 事件延迟到所有被观察者都发送完事件后再执行的话，就可以使用 concatArrayDelayError() 和 mergeArrayDelayError()</p><h4 id="怎么用？-22"><a href="#怎么用？-22" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>首先使用 concatArray() 来验证一下发送 onError() 事件是否会中断其他被观察者发送事件，代码如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.concatArray</span>(Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onError(new NumberFormatException());    &#125;&#125;), Observable.just(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))    <span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Integer integer) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + integer);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onComplete</span>() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">38</span>:<span class="hljs-number">59.725</span> <span class="hljs-number">17985</span><span class="hljs-number">-17985</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">1</span>===================onError 复制代码</code></pre><p>从结果可以知道，确实中断了，现在换用 concatArrayDelayError()，代码如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Observable</span><span class="hljs-selector-class">.concatArrayDelayError</span>(Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onError(new NumberFormatException());    &#125;&#125;), Observable.just(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<span class="hljs-selector-class">.subscribe</span>(new Observer &lt; Integer &gt; () &#123;    <span class="hljs-variable">@Override</span>    public void onSubscribe(Disposable d) &#123;    &#125;    <span class="hljs-variable">@Override</span>    public void onNext(Integer integer) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + integer);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onError</span>(Throwable e) &#123;        <span class="hljs-selector-tag">Log</span><span class="hljs-selector-class">.d</span>(TAG, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    @<span class="hljs-selector-tag">Override</span>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">onComplete</span>() &#123;    &#125;&#125;);复制代码</code></pre><p>打印结果如下：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-21</span> <span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">59.329</span> <span class="hljs-number">18199</span><span class="hljs-number">-18199</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">1</span>===================onNext <span class="hljs-number">2</span>===================onNext <span class="hljs-number">3</span>===================onNext <span class="hljs-number">4</span>===================onError 复制代码</code></pre><p>从结果可以看到，onError 事件是在所有被观察者发送完事件才发送的。mergeArrayDelayError() 也是有同样的作用，这里不再赘述。</p><h2 id="3-5-zip"><a href="#3-5-zip" class="headerlink" title="3.5 zip()"></a>3.5 zip()</h2><h4 id="方法预览：-24"><a href="#方法预览：-24" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs mipsasm">public static &lt;<span class="hljs-built_in">T1</span>, <span class="hljs-built_in">T2</span>, R&gt; Observable&lt;R&gt; zip(ObservableSource&lt;? <span class="hljs-keyword">extends </span><span class="hljs-built_in">T1</span>&gt; source1, ObservableSource&lt;? <span class="hljs-keyword">extends </span><span class="hljs-built_in">T2</span>&gt; source2, <span class="hljs-keyword">BiFunction&lt;? </span>super <span class="hljs-built_in">T1</span>, ? super <span class="hljs-built_in">T2</span>, ? <span class="hljs-keyword">extends </span>R&gt; zipper)......复制代码</code></pre><h4 id="有什么用？-23"><a href="#有什么用？-23" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。</p><h4 id="怎么用？-23"><a href="#怎么用？-23" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.zip(Observable.intervalRange(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS)    .map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>&lt;Long, <span class="hljs-built_in">String</span>&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Long aLong) throws Exception &#123;            <span class="hljs-built_in">String</span> s1 = <span class="hljs-string">&quot;A&quot;</span> + aLong;            Log.d(TAG, <span class="hljs-string">&quot;===================A 发送的事件 &quot;</span> + s1);            <span class="hljs-keyword">return</span> s1;        &#125;&#125;),        Observable.intervalRange(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS)            .map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>&lt;Long, <span class="hljs-built_in">String</span>&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Long aLong) throws Exception &#123;                <span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;B&quot;</span> + aLong;                Log.d(TAG, <span class="hljs-string">&quot;===================B 发送的事件 &quot;</span> + s2);                <span class="hljs-keyword">return</span> s2;            &#125;        &#125;),        <span class="hljs-keyword">new</span> BiFunction&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(<span class="hljs-built_in">String</span> s, <span class="hljs-built_in">String</span> s2) throws Exception &#123;                <span class="hljs-built_in">String</span> res = s + s2;                <span class="hljs-keyword">return</span> res;            &#125;        &#125;).subscribe(<span class="hljs-keyword">new</span> Observer&lt;<span class="hljs-built_in">String</span>&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>上面代码中有两个 Observable，第一个发送事件的数量为5个，第二个发送事件的数量为6个。现在来看下打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">39.952</span> <span class="hljs-number">5338</span><span class="hljs-number">-5338</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">40.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B1===================onNext A1B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">41.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">41.954</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B2===================onNext A2B2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">42.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================onNext A3B3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">43.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">43.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">43.954</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================onNext A4B4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">44.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5362</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A5<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">44.953</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B5<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">09</span>:<span class="hljs-number">10</span>:<span class="hljs-number">44.954</span> <span class="hljs-number">5338</span><span class="hljs-number">-5363</span>/com.example.rxjavademo D/chan: ===================onNext A5B5===================onComplete 复制代码</code></pre><p>可以发现最终接收到的事件数量是5，那么为什么第二个 Observable 没有发送第6个事件呢？因为在这之前第一个 Observable 已经发送了 onComplete 事件，所以第二个 Observable 不会再发送事件。</p><h2 id="3-6-combineLatest-amp-combineLatestDelayError"><a href="#3-6-combineLatest-amp-combineLatestDelayError" class="headerlink" title="3.6 combineLatest() &amp; combineLatestDelayError()"></a>3.6 combineLatest() &amp; combineLatestDelayError()</h2><h4 id="方法预览：-25"><a href="#方法预览：-25" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs mipsasm">public static &lt;<span class="hljs-built_in">T1</span>, <span class="hljs-built_in">T2</span>, R&gt; Observable&lt;R&gt; combineLatest(ObservableSource&lt;? <span class="hljs-keyword">extends </span><span class="hljs-built_in">T1</span>&gt; source1, ObservableSource&lt;? <span class="hljs-keyword">extends </span><span class="hljs-built_in">T2</span>&gt; source2, <span class="hljs-keyword">BiFunction&lt;? </span>super <span class="hljs-built_in">T1</span>, ? super <span class="hljs-built_in">T2</span>, ? <span class="hljs-keyword">extends </span>R&gt; combiner)....... 复制代码</code></pre><h4 id="有什么用？-24"><a href="#有什么用？-24" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>combineLatest() 的作用与 zip() 类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送，这样可能还是比较抽象，看看以下例子代码。</p><h4 id="怎么用？-24"><a href="#怎么用？-24" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.combineLatest(Observable.intervalRange(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS)    .map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Long, <span class="hljs-built_in">String</span> &gt; () &#123;<span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Long aLong) throws Exception &#123;        <span class="hljs-built_in">String</span> s1 = <span class="hljs-string">&quot;A&quot;</span> + aLong;        Log.d(TAG, <span class="hljs-string">&quot;===================A 发送的事件 &quot;</span> + s1);        <span class="hljs-keyword">return</span> s1;    &#125;&#125;),Observable.intervalRange(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS)    .map(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> &lt; Long, <span class="hljs-built_in">String</span> &gt; () &#123;<span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(Long aLong) throws Exception &#123;        <span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;B&quot;</span> + aLong;        Log.d(TAG, <span class="hljs-string">&quot;===================B 发送的事件 &quot;</span> + s2);        <span class="hljs-keyword">return</span> s2;    &#125;&#125;),<span class="hljs-keyword">new</span> BiFunction &lt; <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span> &gt; () &#123;<span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> apply(<span class="hljs-built_in">String</span> s, <span class="hljs-built_in">String</span> s2) throws Exception &#123;        <span class="hljs-built_in">String</span> res = s + s2;        <span class="hljs-keyword">return</span> res;    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-built_in">String</span> &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================最终接收到的事件 &quot;</span> + s);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>分析上面的代码，Observable A 会每隔1秒就发送一次事件，Observable B 会隔2秒发送一次事件。来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">20.859</span> <span class="hljs-number">15104</span><span class="hljs-number">-15104</span>/? D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">21.859</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">22.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">22.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">22.862</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A2B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">23.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A3===================最终接收到的事件 A3B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">24.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================A 发送的事件 A4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">24.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">24.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15128</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B1<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">24.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B2<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">26.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">26.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B3<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">28.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">28.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B4<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30.860</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================B 发送的事件 B5<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30.861</span> <span class="hljs-number">15104</span><span class="hljs-number">-15129</span>/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B5===================onComplete 复制代码</code></pre><p>分析上述结果可以知道，当发送 A1 事件之后，因为 B 并没有发送任何事件，所以根本不会发生结合。当 B 发送了 B1 事件之后，就会与 A 最近发送的事件 A2 结合成 A2B1，这样只有后面一有被观察者发送事件，这个事件就会与其他被观察者最近发送的事件结合起来了。</p><p>因为 combineLatestDelayError() 就是多了延迟发送 onError() 功能，这里就不再赘述了。</p><h2 id="3-7-reduce"><a href="#3-7-reduce" class="headerlink" title="3.7 reduce()"></a>3.7 reduce()</h2><h4 id="方法预览：-26"><a href="#方法预览：-26" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs excel">public final Maybe&lt;<span class="hljs-built_in">T</span>&gt; reduce(BiFunction&lt;<span class="hljs-built_in">T</span>, <span class="hljs-built_in">T</span>, <span class="hljs-built_in">T</span>&gt; reducer)复制代码</code></pre><h4 id="有什么用？-25"><a href="#有什么用？-25" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 scan() 操作符的作用也是将发送数据以一定逻辑聚合起来，这两个的区别在于 scan() 每处理一次数据就会将事件发送给观察者，而 reduce() 会将所有数据聚合在一起才会发送事件给观察者。</p><h4 id="怎么用？-25"><a href="#怎么用？-25" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reduce(<span class="hljs-literal">new</span> BiFunction &lt; <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>, <span class="hljs-built_in">Integer</span> integer2) throws Exception &#123;        int res = <span class="hljs-built_in">integer</span> + integer2;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================integer &quot;</span> + <span class="hljs-built_in">integer</span>);        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================integer2 &quot;</span> + integer2);        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================res &quot;</span> + res);        <span class="hljs-keyword">return</span> res;    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================accept &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">46.042</span> <span class="hljs-number">17775</span><span class="hljs-number">-17775</span>/? D/chan: ====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">0</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">1</span>====================res <span class="hljs-number">1</span>====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">1</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">2</span>====================res <span class="hljs-number">3</span>====================<span class="hljs-built_in">int</span>eger <span class="hljs-number">3</span>====================<span class="hljs-built_in">int</span>eger2 <span class="hljs-number">3</span>====================res <span class="hljs-number">6</span>==================accept <span class="hljs-number">6</span>复制代码</code></pre><p>从结果可以看到，其实就是前2个数据聚合之后，然后再与后1个数据进行聚合，一直到没有数据为止。</p><h2 id="3-8-collect"><a href="#3-8-collect" class="headerlink" title="3.8 collect()"></a>3.8 collect()</h2><h4 id="方法预览：-27"><a href="#方法预览：-27" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;U&gt; Single&lt;U&gt; <span class="hljs-keyword">collect</span>(Callable&lt;? <span class="hljs-keyword">extends</span> U&gt; initialValueSupplier, BiConsumer&lt;? <span class="hljs-keyword">super</span> U, ? <span class="hljs-keyword">super</span> T&gt; collector)复制代码</code></pre><h4 id="有什么用？-26"><a href="#有什么用？-26" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>将数据收集到数据结构当中。</p><h4 id="怎么用？-26"><a href="#怎么用？-26" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).collect(<span class="hljs-built_in">new</span> Callable &lt; ArrayList &lt; <span class="hljs-type">Integer</span> &gt;&gt; () &#123;    @Override    <span class="hljs-built_in">public</span> ArrayList &lt; <span class="hljs-type">Integer</span> &gt; <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> ArrayList &lt; &gt; ();    &#125;&#125;,<span class="hljs-built_in">new</span> BiConsumer &lt; ArrayList &lt; <span class="hljs-type">Integer</span> &gt; , <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(ArrayList &lt; <span class="hljs-type">Integer</span> &gt; integers, <span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        integers.<span class="hljs-keyword">add</span>(<span class="hljs-type">integer</span>);    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; ArrayList &lt; <span class="hljs-type">Integer</span> &gt;&gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(ArrayList &lt; <span class="hljs-type">Integer</span> &gt; integers) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===============accept &quot; + integers);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">16</span>:<span class="hljs-number">47</span>:<span class="hljs-number">18.257</span> <span class="hljs-number">31361</span><span class="hljs-number">-31361</span>/com.example.rxjavademo D/chan: ===============accept [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]复制代码</code></pre><h2 id="3-9-startWith-amp-startWithArray"><a href="#3-9-startWith-amp-startWithArray" class="headerlink" title="3.9 startWith() &amp; startWithArray()"></a>3.9 startWith() &amp; startWithArray()</h2><h4 id="方法预览：-28"><a href="#方法预览：-28" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; startWith(T item)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; startWithArray(T... items)复制代码</code></pre><h4 id="有什么用？-27"><a href="#有什么用？-27" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。</p><h4 id="怎么用？-27"><a href="#怎么用？-27" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs angelscript">Observable.just(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).startWithArray(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).startWith(<span class="hljs-number">1</span>).subscribe(new Consumer &lt; Integer &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> accept(Integer <span class="hljs-built_in">int</span>eger) throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;================accept &quot;</span> + <span class="hljs-built_in">int</span>eger);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">17</span>:<span class="hljs-number">08</span>:<span class="hljs-number">21.282</span> <span class="hljs-number">4505</span><span class="hljs-number">-4505</span>/com.example.rxjavademo D/chan: ================accept <span class="hljs-number">1</span>================accept <span class="hljs-number">2</span>================accept <span class="hljs-number">3</span>================accept <span class="hljs-number">4</span>================accept <span class="hljs-number">5</span>================accept <span class="hljs-number">6</span>================accept <span class="hljs-number">7</span>复制代码</code></pre><h2 id="3-10-count"><a href="#3-10-count" class="headerlink" title="3.10 count()"></a>3.10 count()</h2><h4 id="方法预览：-29"><a href="#方法预览：-29" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;<span class="hljs-keyword">Long</span>&gt; <span class="hljs-keyword">count</span>()复制代码</code></pre><h4 id="有什么用？-28"><a href="#有什么用？-28" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>返回被观察者发送事件的数量。</p><h4 id="怎么用？-28"><a href="#怎么用？-28" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs gradle">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-keyword">count</span>().subscribe(<span class="hljs-keyword">new</span> Consumer &lt; <span class="hljs-keyword">Long</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> accept(<span class="hljs-keyword">Long</span> aLong) <span class="hljs-keyword">throws</span> Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;=======================aLong &quot;</span> + aLong);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">20</span>:<span class="hljs-number">41</span>:<span class="hljs-number">25.025</span> <span class="hljs-number">14126</span><span class="hljs-number">-14126</span>/? D/chan: =======================aLong <span class="hljs-number">3</span>复制代码</code></pre><h1 id="4-功能操作符"><a href="#4-功能操作符" class="headerlink" title="4. 功能操作符"></a>4. 功能操作符</h1><h2 id="4-1-delay"><a href="#4-1-delay" class="headerlink" title="4.1 delay()"></a>4.1 delay()</h2><h4 id="方法预览：-30"><a href="#方法预览：-30" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> final Observable&lt;T&gt; <span class="hljs-title">delay</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> delay, TimeUnit <span class="hljs-built_in">unit</span></span>)</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-29"><a href="#有什么用？-29" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>延迟一段事件发送事件。</p><h4 id="怎么用？-29"><a href="#怎么用？-29" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).delay(<span class="hljs-number">2</span>, TimeUnit.SECONDS).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=======================onSubscribe&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=======================onNext &quot;</span> + integer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;=======================onSubscribe&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>这里延迟了两秒才发送事件，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">43.618</span> <span class="hljs-number">16880</span><span class="hljs-number">-16880</span>/com.example.rxjavademo D/chan: =======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">45.620</span> <span class="hljs-number">16880</span><span class="hljs-number">-16906</span>/com.example.rxjavademo D/chan: =======================onNext <span class="hljs-number">1</span><span class="hljs-number">05</span><span class="hljs-number">-22</span> <span class="hljs-number">20</span>:<span class="hljs-number">53</span>:<span class="hljs-number">45.621</span> <span class="hljs-number">16880</span><span class="hljs-number">-16906</span>/com.example.rxjavademo D/chan: =======================onNext <span class="hljs-number">2</span>=======================onNext <span class="hljs-number">3</span>=======================onSubscribe复制代码</code></pre><p>从打印结果可以看出 onSubscribe 回调2秒之后 onNext 才会回调。</p><h2 id="4-2-doOnEach"><a href="#4-2-doOnEach" class="headerlink" title="4.2 doOnEach()"></a>4.2 doOnEach()</h2><h4 id="方法预览：-31"><a href="#方法预览：-31" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">OnEach(<span class="hljs-params">final</span> Consumer&lt;? <span class="hljs-params">super</span> Notification&lt;T&gt;&gt; <span class="hljs-params">onNotification</span>)</span>复制代码</code></pre><h4 id="有什么用？-30"><a href="#有什么用？-30" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送一件事件之前都会先回调这个方法。</p><h4 id="怎么用？-30"><a href="#怎么用？-30" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        <span class="hljs-comment">//      e.onError(new NumberFormatException());</span>        e.onComplete();    &#125;&#125;).doOnEach(<span class="hljs-literal">new</span> Consumer &lt; Notification &lt; <span class="hljs-built_in">Integer</span> &gt;&gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(Notification &lt; <span class="hljs-built_in">Integer</span> &gt; integerNotification) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnEach &quot;</span> + integerNotification.getValue());    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">07</span>:<span class="hljs-number">05.547</span> <span class="hljs-number">19867</span><span class="hljs-number">-19867</span>/? D/chan: ==================onSubscribe ==================doOnEach <span class="hljs-number">1</span>==================onNext <span class="hljs-number">1</span>==================doOnEach <span class="hljs-number">2</span>==================onNext <span class="hljs-number">2</span>==================doOnEach <span class="hljs-number">3</span>==================onNext <span class="hljs-number">3</span>==================doOnEach <span class="hljs-literal">null</span>==================onComplete 复制代码</code></pre><p>从结果就可以看出每发送一个事件之前都会回调 doOnEach 方法，并且可以取出 onNext() 发送的值。</p><h2 id="4-3-doOnNext"><a href="#4-3-doOnNext" class="headerlink" title="4.3 doOnNext()"></a>4.3 doOnNext()</h2><h4 id="方法预览：-32"><a href="#方法预览：-32" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">OnNext(Consumer&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">onNext</span>)</span>复制代码</code></pre><h4 id="有什么用？-31"><a href="#有什么用？-31" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onNext() 之前都会先回调这个方法。</p><h4 id="怎么用？-31"><a href="#怎么用？-31" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnNext(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">09</span>:<span class="hljs-number">36.769</span> <span class="hljs-number">20020</span><span class="hljs-number">-20020</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================doOnNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">1</span>==================doOnNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">2</span>==================doOnNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><h2 id="4-4-doAfterNext"><a href="#4-4-doAfterNext" class="headerlink" title="4.4 doAfterNext()"></a>4.4 doAfterNext()</h2><h4 id="方法预览：-33"><a href="#方法预览：-33" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">AfterNext(Consumer&lt;? <span class="hljs-params">super</span> T&gt; <span class="hljs-params">onAfterNext</span>)</span>复制代码</code></pre><h4 id="有什么用？-32"><a href="#有什么用？-32" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onNext() 之后都会回调这个方法。</p><h4 id="怎么用？-32"><a href="#怎么用？-32" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doAfterNext(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doAfterNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">15</span>:<span class="hljs-number">49.215</span> <span class="hljs-number">20432</span><span class="hljs-number">-20432</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================doAfterNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================doAfterNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================doAfterNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><h2 id="4-5-doOnComplete"><a href="#4-5-doOnComplete" class="headerlink" title="4.5 doOnComplete()"></a>4.5 doOnComplete()</h2><h4 id="方法预览：-34"><a href="#方法预览：-34" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doOnComplete(<span class="hljs-keyword">Action</span> onComplete)复制代码</code></pre><h4 id="有什么用？-33"><a href="#有什么用？-33" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onComplete() 之前都会回调这个方法。</p><h4 id="怎么用？-33"><a href="#怎么用？-33" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnComplete(<span class="hljs-literal">new</span> Action() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> run() throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnComplete &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">32</span>:<span class="hljs-number">18.031</span> <span class="hljs-number">20751</span><span class="hljs-number">-20751</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================doOnComplete ==================onComplete 复制代码</code></pre><h2 id="4-6-doOnError"><a href="#4-6-doOnError" class="headerlink" title="4.6 doOnError()"></a>4.6 doOnError()</h2><h4 id="方法预览：-35"><a href="#方法预览：-35" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doOnError(Consumer<span class="hljs-meta">&lt;?</span> super <span class="hljs-built_in">Throwable</span>&gt; onError)复制代码</code></pre><h4 id="有什么用？-34"><a href="#有什么用？-34" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onError() 之前都会回调这个方法。</p><h4 id="怎么用？-34"><a href="#怎么用？-34" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-literal">new</span> NullPointerException());    &#125;&#125;).doOnError(<span class="hljs-literal">new</span> Consumer &lt; Throwable &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(Throwable throwable) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnError &quot;</span> + throwable);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">04.150</span> <span class="hljs-number">21051</span><span class="hljs-number">-21051</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================doOnError java.lang.NullPointerException==================onError 复制代码</code></pre><h2 id="4-7-doOnSubscribe"><a href="#4-7-doOnSubscribe" class="headerlink" title="4.7 doOnSubscribe()"></a>4.7 doOnSubscribe()</h2><h4 id="方法预览：-36"><a href="#方法预览：-36" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">OnSubscribe(Consumer&lt;? <span class="hljs-params">super</span> Disposable&gt; <span class="hljs-params">onSubscribe</span>)</span>复制代码</code></pre><h4 id="有什么用？-35"><a href="#有什么用？-35" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>Observable 每发送 onSubscribe() 之前都会回调这个方法。</p><h4 id="怎么用？-35"><a href="#怎么用？-35" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnSubscribe(<span class="hljs-literal">new</span> Consumer &lt; Disposable &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(Disposable disposable) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnSubscribe &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">39</span>:<span class="hljs-number">25.778</span> <span class="hljs-number">21245</span><span class="hljs-number">-21245</span>/? D/chan: ==================doOnSubscribe ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><h2 id="4-8-doOnDispose"><a href="#4-8-doOnDispose" class="headerlink" title="4.8 doOnDispose()"></a>4.8 doOnDispose()</h2><h4 id="方法预览：-37"><a href="#方法预览：-37" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doOnDispose(<span class="hljs-keyword">Action</span> onDispose)复制代码</code></pre><h4 id="有什么用？-36"><a href="#有什么用？-36" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当调用 Disposable 的 dispose() 之后回调该方法。</p><h4 id="怎么用？-36"><a href="#怎么用？-36" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnDispose(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Action</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doOnDispose &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;    <span class="hljs-keyword">private</span> Disposable d;        <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);        <span class="hljs-built_in">this</span>.d = d;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);        d.dispose();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">48.122</span> <span class="hljs-number">22023</span><span class="hljs-number">-22023</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================doOnDispose 复制代码</code></pre><h2 id="4-9-doOnLifecycle"><a href="#4-9-doOnLifecycle" class="headerlink" title="4.9 doOnLifecycle()"></a>4.9 doOnLifecycle()</h2><h4 id="方法预览：-38"><a href="#方法预览：-38" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs reasonml">public final Observable&lt;T&gt; <span class="hljs-keyword">do</span><span class="hljs-constructor">OnLifecycle(<span class="hljs-params">final</span> Consumer&lt;? <span class="hljs-params">super</span> Disposable&gt; <span class="hljs-params">onSubscribe</span>, <span class="hljs-params">final</span> Action <span class="hljs-params">onDispose</span>)</span>复制代码</code></pre><h4 id="有什么用？-37"><a href="#有什么用？-37" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅。</p><h4 id="怎么用？-37"><a href="#怎么用？-37" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>doOnLifecycle() 第二个参数的回调方法的作用与 doOnDispose() 是一样的，现在用下面的例子来讲解：</p><pre><code class="hljs aspectj">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doOnLifecycle(<span class="hljs-keyword">new</span> Consumer&lt;Disposable&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Disposable disposable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doOnLifecycle accept&quot;</span>);    &#125;&#125;, <span class="hljs-keyword">new</span> Action() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doOnLifecycle Action&quot;</span>);    &#125;&#125;).doOnDispose(    <span class="hljs-keyword">new</span> Action() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            Log.d(TAG, <span class="hljs-string">&quot;==================doOnDispose Action&quot;</span>);        &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer&lt;Integer&gt;() &#123;    <span class="hljs-keyword">private</span> Disposable d;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);        <span class="hljs-keyword">this</span>.d = d;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Integer integer)</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);        d.dispose();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;    &#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">20</span>:<span class="hljs-number">36.345</span> <span class="hljs-number">23922</span><span class="hljs-number">-23922</span>/? D/chan: ==================doOnLifecycle accept==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================doOnDispose Action==================doOnLifecycle Action复制代码</code></pre><p>可以看到当在 onNext() 方法进行取消订阅操作后，doOnDispose() 和 doOnLifecycle() 都会被回调。</p><p>如果使用 doOnLifecycle 进行取消订阅，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">20.014</span> <span class="hljs-number">24652</span><span class="hljs-number">-24652</span>/com.example.rxjavademo D/chan: ==================doOnLifecycle accept==================onSubscribe 复制代码</code></pre><p>可以发现 doOnDispose Action 和 doOnLifecycle Action 都没有被回调。</p><h2 id="4-10-doOnTerminate-amp-doAfterTerminate"><a href="#4-10-doOnTerminate-amp-doAfterTerminate" class="headerlink" title="4.10 doOnTerminate() &amp; doAfterTerminate()"></a>4.10 doOnTerminate() &amp; doAfterTerminate()</h2><h4 id="方法预览：-39"><a href="#方法预览：-39" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doOnTerminate(<span class="hljs-keyword">final</span> <span class="hljs-keyword">Action</span> onTerminate)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doAfterTerminate(<span class="hljs-keyword">Action</span> onFinally)复制代码</code></pre><h4 id="有什么用？-38"><a href="#有什么用？-38" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。</p><h4 id="怎么用？-38"><a href="#怎么用？-38" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-built_in">Integer</span>&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);<span class="hljs-comment">//      e.onError(new NullPointerException());</span>        e.onComplete();    &#125;&#125;).doOnTerminate(<span class="hljs-literal">new</span> Action() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> run() throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================doOnTerminate &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;    &#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">39.503</span> <span class="hljs-number">22398</span><span class="hljs-number">-22398</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">39.504</span> <span class="hljs-number">22398</span><span class="hljs-number">-22398</span>/com.example.rxjavademo D/chan: ==================onNext <span class="hljs-number">3</span>==================doOnTerminate ==================onComplete 复制代码</code></pre><p>doAfterTerminate 也是差不多，这里就不再赘述。</p><h2 id="4-11-doFinally"><a href="#4-11-doFinally" class="headerlink" title="4.11 doFinally()"></a>4.11 doFinally()</h2><h4 id="方法预览：-40"><a href="#方法预览：-40" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; doFinally(<span class="hljs-keyword">Action</span> onFinally)复制代码</code></pre><h4 id="有什么用？-39"><a href="#有什么用？-39" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>在所有事件发送完毕之后回调该方法。</p><h4 id="怎么用？-39"><a href="#怎么用？-39" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>这里可能你会有个问题，那就是 doFinally() 和 doAfterTerminate() 到底有什么区别？区别就是在于取消订阅，如果取消订阅之后 doAfterTerminate() 就不会被回调，而 doFinally() 无论怎么样都会被回调，且都会在事件序列的最后。</p><p>现在用以下例子说明下：</p><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).doFinally(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Action</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doFinally &quot;</span>);    &#125;&#125;).doOnDispose(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Action</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doOnDispose &quot;</span>);    &#125;&#125;).doAfterTerminate(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Action</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> run() throws Exception &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================doAfterTerminate &quot;</span>);    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer&lt;Integer&gt;() &#123;    <span class="hljs-keyword">private</span> Disposable d;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);        <span class="hljs-built_in">this</span>.d = d;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);        d.dispose();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">10</span>:<span class="hljs-number">10.469</span> <span class="hljs-number">23196</span><span class="hljs-number">-23196</span>/? D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">10</span>:<span class="hljs-number">10.470</span> <span class="hljs-number">23196</span><span class="hljs-number">-23196</span>/? D/chan: ==================onNext <span class="hljs-number">1</span>==================doOnDispose ==================doFinally 复制代码</code></pre><p>可以看到如果调用了 dispose() 方法，doAfterTerminate() 不会被回调。</p><p>现在试试把 dispose() 注释掉看看，看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">10</span>:<span class="hljs-number">13</span>:<span class="hljs-number">34.537</span> <span class="hljs-number">23439</span><span class="hljs-number">-23439</span>/com.example.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onComplete ==================doAfterTerminate ==================doFinally 复制代码</code></pre><p>doAfterTerminate() 已经成功回调，doFinally() 还是会在事件序列的最后。</p><h2 id="4-12-onErrorReturn"><a href="#4-12-onErrorReturn" class="headerlink" title="4.12 onErrorReturn()"></a>4.12 onErrorReturn()</h2><h4 id="方法预览：-41"><a href="#方法预览：-41" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; onErrorReturn(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super Throwable, ? <span class="hljs-keyword">extends</span> T&gt; valueSupplier)复制代码</code></pre><h4 id="有什么用？-40"><a href="#有什么用？-40" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。</p><h4 id="怎么用？-40"><a href="#怎么用？-40" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-built_in">Integer</span>&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-literal">new</span> NullPointerException());    &#125;&#125;).onErrorReturn(<span class="hljs-literal">new</span> Function&lt;Throwable, <span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Integer</span> apply(Throwable throwable) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onErrorReturn &quot;</span> + throwable);        <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>;    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">18</span>:<span class="hljs-number">35</span>:<span class="hljs-number">18.175</span> <span class="hljs-number">19239</span><span class="hljs-number">-19239</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onErrorReturn java.lang.NullPointerException==================onNext <span class="hljs-number">404</span>==================onComplete 复制代码</code></pre><h2 id="4-13-onErrorResumeNext"><a href="#4-13-onErrorResumeNext" class="headerlink" title="4.13 onErrorResumeNext()"></a>4.13 onErrorResumeNext()</h2><h4 id="方法预览：-42"><a href="#方法预览：-42" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; onErrorResumeNext(<span class="hljs-function"><span class="hljs-keyword">Function</span></span>&lt;? super Throwable, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> T&gt;&gt; resumeFunction)复制代码</code></pre><h4 id="有什么用？-41"><a href="#有什么用？-41" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。</p><h4 id="怎么用？-41"><a href="#怎么用？-41" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-built_in">Integer</span>&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-literal">new</span> NullPointerException());    &#125;&#125;).onErrorResumeNext(<span class="hljs-literal">new</span> Function&lt;Throwable, ObservableSource&lt;? extends <span class="hljs-built_in">Integer</span>&gt;&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> ObservableSource&lt;? extends <span class="hljs-built_in">Integer</span>&gt; apply(Throwable throwable) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onErrorResumeNext &quot;</span> + throwable);        <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);    &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">10.910</span> <span class="hljs-number">26469</span><span class="hljs-number">-26469</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onErrorResumeNext java.lang.NullPointerException==================onNext <span class="hljs-number">4</span>==================onNext <span class="hljs-number">5</span>==================onNext <span class="hljs-number">6</span>==================onComplete 复制代码</code></pre><h2 id="4-14-onExceptionResumeNext"><a href="#4-14-onExceptionResumeNext" class="headerlink" title="4.14 onExceptionResumeNext()"></a>4.14 onExceptionResumeNext()</h2><h4 id="方法预览：-43"><a href="#方法预览：-43" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; onExceptionResumeNext(<span class="hljs-keyword">final</span> ObservableSource&lt;? <span class="hljs-keyword">extends</span> T&gt; <span class="hljs-keyword">next</span>)复制代码</code></pre><h4 id="有什么用？-42"><a href="#有什么用？-42" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。</p><h4 id="怎么用？-42"><a href="#怎么用？-42" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>先来试试 onExceptionResumeNext() 是否能捕捉 Error。</p><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;404&quot;</span>));    &#125;&#125;).onExceptionResumeNext(<span class="hljs-keyword">new</span> Observable&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">subscribeActual</span>(<span class="hljs-params">Observer&lt;? <span class="hljs-built_in">super</span> Integer&gt; observer</span>)</span> &#123;        observer.onNext(<span class="hljs-number">333</span>);        observer.onComplete();    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer&lt;Integer&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">23</span>:<span class="hljs-number">08.873</span> <span class="hljs-number">1062</span><span class="hljs-number">-1062</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">23</span>:<span class="hljs-number">08.874</span> <span class="hljs-number">1062</span><span class="hljs-number">-1062</span>/com.example.louder.rxjavademo D/chan: ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onError 复制代码</code></pre><p>从打印结果可以知道，观察者收到 onError() 事件，证明 onErrorResumeNext() 不能捕捉 Error 事件。</p><p>将被观察者的 e.onError(new Error(“404”)) 改为 e.onError(new Exception(“404”))，现在看看是否能捕捉 Exception 事件：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">14.563</span> <span class="hljs-number">10487</span><span class="hljs-number">-10487</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">333</span>==================onComplete 复制代码</code></pre><p>从打印结果可以知道，这个方法成功捕获 Exception 事件。</p><h2 id="4-15-retry"><a href="#4-15-retry" class="headerlink" title="4.15 retry()"></a>4.15 retry()</h2><h4 id="方法预览：-44"><a href="#方法预览：-44" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-keyword">retry</span>(<span class="hljs-built_in">long</span> times)......复制代码</code></pre><h4 id="有什么用？-43"><a href="#有什么用？-43" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。</p><h4 id="怎么用？-43"><a href="#怎么用？-43" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter&lt;<span class="hljs-built_in">Integer</span>&gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-literal">new</span> Exception(<span class="hljs-string">&quot;404&quot;</span>));    &#125;&#125;).retry(<span class="hljs-number">2</span>).subscribe(<span class="hljs-literal">new</span> Observer&lt;<span class="hljs-built_in">Integer</span>&gt;() &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18.537</span> <span class="hljs-number">22239</span><span class="hljs-number">-22239</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18.538</span> <span class="hljs-number">22239</span><span class="hljs-number">-22239</span>/com.example.louder.rxjavademo D/chan: ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onError 复制代码</code></pre><h2 id="4-16-retryUntil"><a href="#4-16-retryUntil" class="headerlink" title="4.16 retryUntil()"></a>4.16 retryUntil()</h2><h4 id="方法预览：-45"><a href="#方法预览：-45" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; retryUntil(<span class="hljs-keyword">final</span> BooleanSupplier <span class="hljs-keyword">stop</span>)复制代码</code></pre><h4 id="有什么用？-44"><a href="#有什么用？-44" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>出现错误事件之后，可以通过此方法判断是否继续发送事件。</p><h4 id="怎么用？-44"><a href="#怎么用？-44" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onError(<span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;404&quot;</span>));    &#125;&#125;).retryUntil(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">BooleanSupplier</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> getAsBoolean() throws Exception &#123;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">6</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        i += integer;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + integer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">57</span>:<span class="hljs-number">32.905</span> <span class="hljs-number">23063</span><span class="hljs-number">-23063</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-23</span> <span class="hljs-number">22</span>:<span class="hljs-number">57</span>:<span class="hljs-number">32.906</span> <span class="hljs-number">23063</span><span class="hljs-number">-23063</span>/com.example.louder.rxjavademo D/chan: ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onError 复制代码</code></pre><h2 id="4-17-retryWhen"><a href="#4-17-retryWhen" class="headerlink" title="4.17 retryWhen()"></a>4.17 retryWhen()</h2><h4 id="方法预览：-46"><a href="#方法预览：-46" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> safeSubscribe(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; s)复制代码</code></pre><h4 id="有什么用？-45"><a href="#有什么用？-45" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件。</p><h4 id="怎么用？-45"><a href="#怎么用？-45" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs php">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; <span class="hljs-keyword">String</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-keyword">String</span> &gt; e) throws <span class="hljs-built_in">Exception</span> &#123;        e.onNext(<span class="hljs-string">&quot;chan&quot;</span>);        e.onNext(<span class="hljs-string">&quot;ze&quot;</span>);        e.onNext(<span class="hljs-string">&quot;de&quot;</span>);        e.onError(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&quot;404&quot;</span>));        e.onNext(<span class="hljs-string">&quot;haha&quot;</span>);    &#125;&#125;).retryWhen(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span> &lt; <span class="hljs-title">Observable</span> &lt; <span class="hljs-title">Throwable</span> &gt; , <span class="hljs-title">ObservableSource</span> &lt;? &gt;&gt; (<span class="hljs-params"></span>) </span>&#123;    @Override    <span class="hljs-keyword">public</span> ObservableSource <span class="hljs-meta">&lt;?</span> &gt; apply(Observable &lt; <span class="hljs-built_in">Throwable</span> &gt; throwableObservable) throws <span class="hljs-built_in">Exception</span> &#123;        <span class="hljs-keyword">return</span> throwableObservable.flatMap(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span> &lt; <span class="hljs-title">Throwable</span>, <span class="hljs-title">ObservableSource</span> &lt;? &gt;&gt; (<span class="hljs-params"></span>) </span>&#123;            @Override            <span class="hljs-keyword">public</span> ObservableSource <span class="hljs-meta">&lt;?</span> &gt; apply(<span class="hljs-built_in">Throwable</span> <span class="hljs-built_in">throwable</span>) throws <span class="hljs-built_in">Exception</span> &#123;                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">throwable</span>.toString().equals(<span class="hljs-string">&quot;java.lang.Exception: 404&quot;</span>)) &#123;                    <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-string">&quot;可以忽略的异常&quot;</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span> Observable.<span class="hljs-built_in">error</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Throwable</span>(<span class="hljs-string">&quot;终止啦&quot;</span>));                &#125;            &#125;        &#125;);    &#125;&#125;).subscribe(<span class="hljs-keyword">new</span> Observer &lt; <span class="hljs-keyword">String</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onSubscribe(Disposable d) &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onNext(<span class="hljs-keyword">String</span> s) &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onNext &quot;</span> + s);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onError(<span class="hljs-built_in">Throwable</span> e) &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onError &quot;</span> + e.toString());    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onComplete() &#123;        Log.d(TAG, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">09</span>:<span class="hljs-number">13</span>:<span class="hljs-number">25.622</span> <span class="hljs-number">28372</span><span class="hljs-number">-28372</span>/com.example.rxjavademo D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">09</span>:<span class="hljs-number">13</span>:<span class="hljs-number">25.623</span> <span class="hljs-number">28372</span><span class="hljs-number">-28372</span>/com.example.rxjavademo D/chan: ==================onNext chan==================onNext ze==================onNext de<span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">09</span>:<span class="hljs-number">13</span>:<span class="hljs-number">25.624</span> <span class="hljs-number">28372</span><span class="hljs-number">-28372</span>/com.example.rxjavademo D/chan: ==================onError java.lang.Throwable: 终止啦复制代码</code></pre><p>将 onError(new Exception(“404”)) 改为 onError(new Exception(“303”)) 看看打印结果：</p><pre><code class="hljs diff"><span class="hljs-comment">==================onNext chan</span>05-24 09:54:08.653 29694-29694/? D/chan: <span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span><span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span><span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span><span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span><span class="hljs-comment">==================onNext ze</span><span class="hljs-comment">==================onNext de</span><span class="hljs-comment">==================onNext chan</span>......复制代码</code></pre><p>从结果可以看出，会不断重复发送消息。</p><h2 id="4-18-repeat"><a href="#4-18-repeat" class="headerlink" title="4.18 repeat()"></a>4.18 repeat()</h2><h4 id="方法预览：-47"><a href="#方法预览：-47" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; repeat(<span class="hljs-keyword">long</span> <span class="hljs-keyword">times</span>)......复制代码</code></pre><h4 id="有什么用？-46"><a href="#有什么用？-46" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>重复发送被观察者的事件，times 为发送次数。</p><h4 id="怎么用？-46"><a href="#怎么用？-46" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs typescript">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).repeat(<span class="hljs-number">2</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; () &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onSubscribe</span>(<span class="hljs-params">Disposable d</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onSubscribe &quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onNext</span>(<span class="hljs-params">Integer integer</span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onNext &quot;</span> + integer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">Throwable e</span>)</span> &#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">onComplete</span>(<span class="hljs-params"></span>)</span> &#123;        Log.d(TAG, <span class="hljs-string">&quot;===================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">29.565</span> <span class="hljs-number">8544</span><span class="hljs-number">-8544</span>/com.example.rxjavademo D/chan: ===================onSubscribe ===================onNext <span class="hljs-number">1</span>===================onNext <span class="hljs-number">2</span>===================onNext <span class="hljs-number">3</span>===================onNext <span class="hljs-number">1</span>===================onNext <span class="hljs-number">2</span>===================onNext <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">29.565</span> <span class="hljs-number">8544</span><span class="hljs-number">-8544</span>/com.example.rxjavademo D/chan: ===================onComplete 复制代码</code></pre><p>从结果可以看出，该事件发送了两次。</p><h2 id="4-19-repeatWhen"><a href="#4-19-repeatWhen" class="headerlink" title="4.19 repeatWhen()"></a>4.19 repeatWhen()</h2><h4 id="方法预览：-48"><a href="#方法预览：-48" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; repeatWhen(<span class="hljs-keyword">final</span> Function&lt;? <span class="hljs-keyword">super</span> Observable&lt;Object&gt;, ? <span class="hljs-keyword">extends</span> ObservableSource&lt;?&gt;&gt; <span class="hljs-keyword">handler</span>)复制代码</code></pre><h4 id="有什么用？-47"><a href="#有什么用？-47" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件。</p><h4 id="怎么用？-47"><a href="#怎么用？-47" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>这里分三种情况，如果新的被观察者返回 onComplete 或者 onError 事件，则旧的被观察者不会继续发送事件。如果被观察者返回其他事件，则会重复发送事件。</p><p>现在试验发送 onComplete 事件，代码如下：</p><pre><code class="hljs pgsql">Observable.<span class="hljs-keyword">create</span>(<span class="hljs-built_in">new</span> ObservableOnSubscribe &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-type">Integer</span> &gt; e) throws <span class="hljs-keyword">Exception</span> &#123;        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;).repeatWhen(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Function</span> &lt; Observable &lt; <span class="hljs-keyword">Object</span> &gt; , ObservableSource &lt;? &gt;&gt; () &#123;    @Override    <span class="hljs-built_in">public</span> ObservableSource &lt;? &gt; apply(Observable &lt; <span class="hljs-keyword">Object</span> &gt; objectObservable) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> Observable.empty();    //  <span class="hljs-keyword">return</span> Observable.error(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Exception</span>(&quot;404&quot;));    //  <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-number">4</span>); <span class="hljs-keyword">null</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Observer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===================onSubscribe &quot;);    &#125;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onNext(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===================onNext &quot; + <span class="hljs-type">integer</span>);    &#125;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===================onError &quot;);    &#125;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;===================onComplete &quot;);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">44</span>:<span class="hljs-number">33.486</span> <span class="hljs-number">9379</span><span class="hljs-number">-9379</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">44</span>:<span class="hljs-number">33.487</span> <span class="hljs-number">9379</span><span class="hljs-number">-9379</span>/com.example.rxjavademo D/chan: ===================onComplete 复制代码</code></pre><p>下面直接看看发送 onError 事件和其他事件的打印结果。</p><p>发送 onError 打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">46</span>:<span class="hljs-number">29.507</span> <span class="hljs-number">9561</span><span class="hljs-number">-9561</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">46</span>:<span class="hljs-number">29.508</span> <span class="hljs-number">9561</span><span class="hljs-number">-9561</span>/com.example.rxjavademo D/chan: ===================onError 复制代码</code></pre><p>发送其他事件的打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">35.844</span> <span class="hljs-number">9752</span><span class="hljs-number">-9752</span>/com.example.rxjavademo D/chan: ===================onSubscribe ===================onNext <span class="hljs-number">1</span>===================onNext <span class="hljs-number">2</span>===================onNext <span class="hljs-number">3</span>===================onComplete 复制代码</code></pre><h2 id="4-20-subscribeOn"><a href="#4-20-subscribeOn" class="headerlink" title="4.20 subscribeOn()"></a>4.20 subscribeOn()</h2><h4 id="方法预览：-49"><a href="#方法预览：-49" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; subscribeOn(Scheduler scheduler)复制代码</code></pre><h4 id="有什么用？-48"><a href="#有什么用？-48" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效。</p><h4 id="怎么用？-48"><a href="#怎么用？-48" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;=========================currentThread name: &quot;</span> + <span class="hljs-keyword">Thread</span>.currentThread().getName());        e.onNext(<span class="hljs-number">1</span>);        e.onNext(<span class="hljs-number">2</span>);        e.onNext(<span class="hljs-number">3</span>);        e.onComplete();    &#125;&#125;)<span class="hljs-comment">//.subscribeOn(Schedulers.newThread())</span>.subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>现在不调用 subscribeOn() 方法，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">42.246</span> <span class="hljs-number">21466</span><span class="hljs-number">-21466</span>/? D/chan: ======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">42.247</span> <span class="hljs-number">21466</span><span class="hljs-number">-21466</span>/? D/chan: =========================currentThread name: main======================onNext <span class="hljs-number">1</span>======================onNext <span class="hljs-number">2</span>======================onNext <span class="hljs-number">3</span>======================onComplete复制代码</code></pre><p>可以看到打印被观察者的线程名字是主线程。</p><p>接着调用 subscribeOn(Schedulers.newThread()) 来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">43</span>:<span class="hljs-number">26.964</span> <span class="hljs-number">22530</span><span class="hljs-number">-22530</span>/com.example.rxjavademo D/chan: ======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">43</span>:<span class="hljs-number">26.966</span> <span class="hljs-number">22530</span><span class="hljs-number">-22569</span>/com.example.rxjavademo D/chan: =========================currentThread name: RxNewThreadScheduler<span class="hljs-number">-1</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">43</span>:<span class="hljs-number">26.967</span> <span class="hljs-number">22530</span><span class="hljs-number">-22569</span>/com.example.rxjavademo D/chan: ======================onNext <span class="hljs-number">1</span>======================onNext <span class="hljs-number">2</span>======================onNext <span class="hljs-number">3</span>======================onComplete复制代码</code></pre><p>可以看到打印结果被观察者是在一条新的线程。</p><p>现在看看多次调用会不会有效，代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>create(<span class="hljs-keyword">new</span> ObservableOnSubscribe &lt; Integer &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;=========================currentThread name: &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);        e.on<span class="hljs-constructor">Next(1)</span>;        e.on<span class="hljs-constructor">Next(2)</span>;        e.on<span class="hljs-constructor">Next(3)</span>;        e.on<span class="hljs-constructor">Complete()</span>;    &#125;&#125;).subscribe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">computation</span>()</span>).subscribe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">newThread</span>()</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Integer &gt; <span class="hljs-literal">()</span> &#123;@Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Next(Integer <span class="hljs-params">integer</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onNext &quot;</span> + integer);    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">20.925</span> <span class="hljs-number">23590</span><span class="hljs-number">-23590</span>/com.example.rxjavademo D/chan: ======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">47</span>:<span class="hljs-number">20.930</span> <span class="hljs-number">23590</span><span class="hljs-number">-23629</span>/com.example.rxjavademo D/chan: =========================currentThread name: RxComputationThreadPool<span class="hljs-number">-1</span>======================onNext <span class="hljs-number">1</span>======================onNext <span class="hljs-number">2</span>======================onNext <span class="hljs-number">3</span>======================onComplete复制代码</code></pre><p>可以看到第二次调动的 subscribeOn(Schedulers.newThread()) 并没有效果。</p><h2 id="4-21-observeOn"><a href="#4-21-observeOn" class="headerlink" title="4.21 observeOn()"></a>4.21 observeOn()</h2><h4 id="方法预览：-50"><a href="#方法预览：-50" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; observeOn(Scheduler scheduler)复制代码</code></pre><h4 id="有什么用？-49"><a href="#有什么用？-49" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>指定观察者的线程，每指定一次就会生效一次。</p><h4 id="怎么用？-49"><a href="#怎么用？-49" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).observe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">newThread</span>()</span>).flat<span class="hljs-constructor">Map(<span class="hljs-params">new</span> Function &lt; Integer, ObservableSource &lt; String &gt;&gt; ()</span> &#123;    @Override    public ObservableSource &lt; String &gt; apply(Integer integer) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================flatMap Thread name &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-string">&quot;chan&quot;</span> + integer);    &#125;&#125;).observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; String &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onSubscribe&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Next(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onNext Thread name &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>);        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onNext &quot;</span> + s);    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onError&quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;======================onComplete&quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.593</span> <span class="hljs-number">25717</span><span class="hljs-number">-25717</span>/com.example.rxjavademo D/chan: ======================onSubscribe<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.594</span> <span class="hljs-number">25717</span><span class="hljs-number">-25753</span>/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler<span class="hljs-number">-1</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.595</span> <span class="hljs-number">25717</span><span class="hljs-number">-25753</span>/com.example.rxjavademo D/chan: ======================flatMap Thread name RxNewThreadScheduler<span class="hljs-number">-1</span>======================flatMap Thread name RxNewThreadScheduler<span class="hljs-number">-1</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.617</span> <span class="hljs-number">25717</span><span class="hljs-number">-25717</span>/com.example.rxjavademo D/chan: ======================onNext Thread name main======================onNext chan1======================onNext Thread name main======================onNext chan2======================onNext Thread name main======================onNext chan3<span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">58</span>:<span class="hljs-number">04.618</span> <span class="hljs-number">25717</span><span class="hljs-number">-25717</span>/com.example.rxjavademo D/chan: ======================onComplete复制代码</code></pre><p>从打印结果可以知道，observeOn 成功切换了线程。</p><p>下表总结了 RxJava 中的调度器：</p><table><thead><tr><th>调度器</th><th>作用</th></tr></thead><tbody><tr><td>Schedulers.computation( )</td><td>用于使用计算任务，如事件循环和回调处理</td></tr><tr><td>Schedulers.immediate( )</td><td>当前线程</td></tr><tr><td>Schedulers.io( )</td><td>用于 IO 密集型任务，如果异步阻塞 IO 操作。</td></tr><tr><td>Schedulers.newThread( )</td><td>创建一个新的线程</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>Android 的 UI 线程，用于操作 UI。</td></tr></tbody></table><h1 id="5-过滤操作符"><a href="#5-过滤操作符" class="headerlink" title="5. 过滤操作符"></a>5. 过滤操作符</h1><h2 id="5-1-filter"><a href="#5-1-filter" class="headerlink" title="5.1 filter()"></a>5.1 filter()</h2><h4 id="方法预览：-51"><a href="#方法预览：-51" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-built_in">filter</span>(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)复制代码</code></pre><h4 id="有什么用？-50"><a href="#有什么用？-50" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送。</p><h4 id="怎么用？-50"><a href="#怎么用？-50" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso"> Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)    .filter(<span class="hljs-literal">new</span> Predicate &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;        @Override        <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> test(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">integer</span> &lt; <span class="hljs-number">2</span>;        &#125;&#125;).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>以上代码只有小于2的事件才会发送，来看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">22</span>:<span class="hljs-number">57</span>:<span class="hljs-number">32.562</span> <span class="hljs-number">12776</span><span class="hljs-number">-12776</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onComplete 复制代码</code></pre><h2 id="5-2-ofType"><a href="#5-2-ofType" class="headerlink" title="5.2 ofType()"></a>5.2 ofType()</h2><h4 id="方法预览：-52"><a href="#方法预览：-52" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs monkey"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;U&gt; Observable&lt;U&gt; ofType(<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">Class</span>&lt;<span class="hljs-title">U</span>&gt; <span class="hljs-title">clazz</span>)</span>复制代码</code></pre><h4 id="有什么用？-51"><a href="#有什么用？-51" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以过滤不符合该类型事件</p><h4 id="怎么用？-51"><a href="#怎么用？-51" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;chan&quot;</span>, <span class="hljs-string">&quot;zhide&quot;</span>).ofType(<span class="hljs-built_in">Integer</span>.class).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">24.752</span> <span class="hljs-number">13229</span><span class="hljs-number">-13229</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">24.753</span> <span class="hljs-number">13229</span><span class="hljs-number">-13229</span>/? D/chan: ==================onComplete 复制代码</code></pre><h2 id="5-3-skip"><a href="#5-3-skip" class="headerlink" title="5.3 skip()"></a>5.3 skip()</h2><h4 id="方法预览：-53"><a href="#方法预览：-53" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; skip(<span class="hljs-built_in">long</span> <span class="hljs-keyword">count</span>).......复制代码</code></pre><h4 id="有什么用？-52"><a href="#有什么用？-52" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>跳过正序某些事件，count 代表跳过事件的数量</p><h4 id="怎么用？-52"><a href="#怎么用？-52" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<span class="hljs-keyword">skip</span>(<span class="hljs-number">2</span>).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50.448</span> <span class="hljs-number">13831</span><span class="hljs-number">-13831</span>/? D/chan: ==================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50.449</span> <span class="hljs-number">13831</span><span class="hljs-number">-13831</span>/? D/chan: ==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><p>skipLast() 作用也是跳过某些事件，不过它是用来跳过正序的后面的事件，这里就不再讲解了。</p><h2 id="5-4-distinct"><a href="#5-4-distinct" class="headerlink" title="5.4 distinct()"></a>5.4 distinct()</h2><h4 id="方法预览：-54"><a href="#方法预览：-54" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-keyword">distinct</span>() 复制代码</code></pre><h4 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用?"></a>有什么用?</h4><p>过滤事件序列中的重复事件。</p><h4 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>).distinct().subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果:</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">19</span>:<span class="hljs-number">44.334</span> <span class="hljs-number">14206</span><span class="hljs-number">-14206</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><h2 id="5-5-distinctUntilChanged"><a href="#5-5-distinctUntilChanged" class="headerlink" title="5.5 distinctUntilChanged()"></a>5.5 distinctUntilChanged()</h2><h4 id="方法预览：-55"><a href="#方法预览：-55" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; distinctUntilChanged()复制代码</code></pre><h4 id="有什么用？-53"><a href="#有什么用？-53" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>过滤掉连续重复的事件</p><h4 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>).distinctUntilChanged().subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果:</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">22</span>:<span class="hljs-number">35.985</span> <span class="hljs-number">14424</span><span class="hljs-number">-14424</span>/com.example.louder.rxjavademo D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">1</span>==================onComplete 复制代码</code></pre><p>因为事件序列中连续出现两次3，所以第二次3并不会发出。</p><h2 id="5-6-take"><a href="#5-6-take" class="headerlink" title="5.6 take()"></a>5.6 take()</h2><h4 id="方法预览：-56"><a href="#方法预览：-56" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; take(<span class="hljs-built_in">long</span> <span class="hljs-keyword">count</span>)......复制代码</code></pre><h4 id="有什么用-1"><a href="#有什么用-1" class="headerlink" title="有什么用?"></a>有什么用?</h4><p>控制观察者接收的事件的数量。</p><h4 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用?"></a>怎么用?</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).<span class="hljs-keyword">take</span>(<span class="hljs-number">3</span>).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        i += <span class="hljs-built_in">integer</span>;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;==================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-24</span> <span class="hljs-number">23</span>:<span class="hljs-number">28</span>:<span class="hljs-number">32.899</span> <span class="hljs-number">14704</span><span class="hljs-number">-14704</span>/? D/chan: ==================onSubscribe ==================onNext <span class="hljs-number">1</span>==================onNext <span class="hljs-number">2</span>==================onNext <span class="hljs-number">3</span>==================onComplete 复制代码</code></pre><p>takeLast() 的作用就是控制观察者只能接受事件序列的后面几件事情，这里就不再讲解了，大家可以自己试试。</p><h2 id="5-7-debounce"><a href="#5-7-debounce" class="headerlink" title="5.7 debounce()"></a>5.7 debounce()</h2><h4 id="方法预览：-57"><a href="#方法预览：-57" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> final Observable&lt;T&gt; <span class="hljs-title">debounce</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> timeout, TimeUnit <span class="hljs-built_in">unit</span></span>)</span><span class="hljs-function">......</span><span class="hljs-function">复制代码</span></code></pre><h4 id="有什么用？-54"><a href="#有什么用？-54" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。</p><h4 id="怎么用？-53"><a href="#怎么用？-53" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.create(<span class="hljs-literal">new</span> ObservableOnSubscribe &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-built_in">Integer</span> &gt; e) throws Exception &#123;        e.onNext(<span class="hljs-number">1</span>);        <span class="hljs-keyword">Thread</span>.sleep(<span class="hljs-number">900</span>);        e.onNext(<span class="hljs-number">2</span>);    &#125;&#125;).debounce(<span class="hljs-number">1</span>, TimeUnit.SECONDS).subscribe(<span class="hljs-literal">new</span> Observer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onSubscribe(Disposable d) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;===================onSubscribe &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onNext(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;===================onNext &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onError(Throwable e) &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;===================onError &quot;</span>);    &#125;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onComplete() &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;===================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">39</span>:<span class="hljs-number">10.512</span> <span class="hljs-number">17441</span><span class="hljs-number">-17441</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">39</span>:<span class="hljs-number">12.413</span> <span class="hljs-number">17441</span><span class="hljs-number">-17478</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">2</span>复制代码</code></pre><p>可以看到事件1并没有发送出去，现在将间隔时间改为1000，看看打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">10.874</span> <span class="hljs-number">18196</span><span class="hljs-number">-18196</span>/com.example.rxjavademo D/chan: ===================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">11.875</span> <span class="hljs-number">18196</span><span class="hljs-number">-18245</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">1</span><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">42</span>:<span class="hljs-number">12.875</span> <span class="hljs-number">18196</span><span class="hljs-number">-18245</span>/com.example.rxjavademo D/chan: ===================onNext <span class="hljs-number">2</span>复制代码</code></pre><p>throttleWithTimeout() 与此方法的作用一样，这里就不再赘述了。</p><h2 id="5-8-firstElement-amp-amp-lastElement"><a href="#5-8-firstElement-amp-amp-lastElement" class="headerlink" title="5.8 firstElement() &amp;&amp; lastElement()"></a>5.8 firstElement() &amp;&amp; lastElement()</h2><h5 id="方法预览：-58"><a href="#方法预览：-58" class="headerlink" title="方法预览："></a>方法预览：</h5><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Maybe&lt;T&gt; firstElement()<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Maybe&lt;T&gt; lastElement()复制代码</code></pre><h4 id="有什么用？-55"><a href="#有什么用？-55" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素。</p><h4 id="怎么用？-54"><a href="#怎么用？-54" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).firstElement().subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================firstElement &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).lastElement().subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================lastElement &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">47</span>:<span class="hljs-number">22.189</span> <span class="hljs-number">19909</span><span class="hljs-number">-19909</span>/? D/chan: ====================firstElement <span class="hljs-number">1</span>====================lastElement <span class="hljs-number">4</span>复制代码</code></pre><h2 id="5-9-elementAt-amp-elementAtOrError"><a href="#5-9-elementAt-amp-elementAtOrError" class="headerlink" title="5.9 elementAt() &amp; elementAtOrError()"></a>5.9 elementAt() &amp; elementAtOrError()</h2><h4 id="方法预览：-59"><a href="#方法预览：-59" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Maybe&lt;T&gt; elementAt(<span class="hljs-built_in">long</span> <span class="hljs-keyword">index</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;T&gt; elementAtOrError(<span class="hljs-built_in">long</span> <span class="hljs-keyword">index</span>)复制代码</code></pre><h4 id="有什么用？-56"><a href="#有什么用？-56" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 。</p><h4 id="怎么用？-55"><a href="#怎么用？-55" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).elementAt(<span class="hljs-number">0</span>).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================accept &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-25</span> <span class="hljs-number">20</span>:<span class="hljs-number">56</span>:<span class="hljs-number">22.266</span> <span class="hljs-number">23346</span><span class="hljs-number">-23346</span>/com.example.rxjavademo D/chan: ====================accept <span class="hljs-number">1</span>复制代码</code></pre><p>将 elementAt() 的值改为5，这时是没有打印结果的，因为没有满足条件的元素。</p><p>替换 elementAt() 为 elementAtOrError()，代码如下：</p><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).elementAtOrError(<span class="hljs-number">5</span>).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Integer</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Integer</span> <span class="hljs-built_in">integer</span>) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;====================accept &quot;</span> + <span class="hljs-built_in">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs stylus">io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.exceptions</span>.OnErrorNotImplementedExceptionat io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.functions</span>.Functions<span class="hljs-variable">$OnErrorMissingConsumer</span>.accept(Functions<span class="hljs-selector-class">.java</span>: <span class="hljs-number">704</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.functions</span>.Functions<span class="hljs-variable">$OnErrorMissingConsumer</span>.accept(Functions<span class="hljs-selector-class">.java</span>: <span class="hljs-number">701</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.observers</span><span class="hljs-selector-class">.ConsumerSingleObserver</span>.onError(ConsumerSingleObserver<span class="hljs-selector-class">.java</span>: <span class="hljs-number">47</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span>.ObservableElementAtSingle<span class="hljs-variable">$ElementAtObserver</span>.onComplete(ObservableElementAtSingle<span class="hljs-selector-class">.java</span>: <span class="hljs-number">117</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span>.ObservableFromArray<span class="hljs-variable">$FromArrayDisposable</span>.run(ObservableFromArray<span class="hljs-selector-class">.java</span>: <span class="hljs-number">110</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span><span class="hljs-selector-class">.ObservableFromArray</span>.subscribeActual(ObservableFromArray<span class="hljs-selector-class">.java</span>: <span class="hljs-number">36</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Observable</span>.subscribe(Observable<span class="hljs-selector-class">.java</span>: <span class="hljs-number">10903</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span><span class="hljs-selector-class">.ObservableElementAtSingle</span>.subscribeActual(ObservableElementAtSingle<span class="hljs-selector-class">.java</span>: <span class="hljs-number">37</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2707</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2693</span>)at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2664</span>)at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.rxjavademo</span><span class="hljs-selector-class">.MainActivity</span>.onCreate(MainActivity<span class="hljs-selector-class">.java</span>: <span class="hljs-number">103</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Activity</span>.performCreate(Activity<span class="hljs-selector-class">.java</span>: <span class="hljs-number">6942</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Instrumentation</span>.callActivityOnCreate(Instrumentation<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1126</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.performLaunchActivity(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2880</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.handleLaunchActivity(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2988</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>. - wrap14(ActivityThread.java)at android<span class="hljs-selector-class">.app</span>.ActivityThread<span class="hljs-variable">$H</span>.handleMessage(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1631</span>)at android<span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Handler</span>.dispatchMessage(Handler<span class="hljs-selector-class">.java</span>: <span class="hljs-number">102</span>)at android<span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Looper</span>.loop(Looper<span class="hljs-selector-class">.java</span>: <span class="hljs-number">154</span>)at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.main(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">6682</span>)at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span>.invoke(Native Method)at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.os</span>.ZygoteInit<span class="hljs-variable">$MethodAndArgsCaller</span>.run(ZygoteInit<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1520</span>)at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.ZygoteInit</span>.main(ZygoteInit<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1410</span>)Caused by: java<span class="hljs-selector-class">.util</span>.NoSuchElementExceptionat io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span>.ObservableElementAtSingle<span class="hljs-variable">$ElementAtObserver</span>.onComplete(ObservableElementAtSingle<span class="hljs-selector-class">.java</span>: <span class="hljs-number">117</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span>.ObservableFromArray<span class="hljs-variable">$FromArrayDisposable</span>.run(ObservableFromArray<span class="hljs-selector-class">.java</span>: <span class="hljs-number">110</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span><span class="hljs-selector-class">.ObservableFromArray</span>.subscribeActual(ObservableFromArray<span class="hljs-selector-class">.java</span>: <span class="hljs-number">36</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Observable</span>.subscribe(Observable<span class="hljs-selector-class">.java</span>: <span class="hljs-number">10903</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.operators</span><span class="hljs-selector-class">.observable</span><span class="hljs-selector-class">.ObservableElementAtSingle</span>.subscribeActual(ObservableElementAtSingle<span class="hljs-selector-class">.java</span>: <span class="hljs-number">37</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2707</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2693</span>) at io<span class="hljs-selector-class">.reactivex</span><span class="hljs-selector-class">.Single</span>.subscribe(Single<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2664</span>) at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.rxjavademo</span><span class="hljs-selector-class">.MainActivity</span>.onCreate(MainActivity<span class="hljs-selector-class">.java</span>: <span class="hljs-number">103</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Activity</span>.performCreate(Activity<span class="hljs-selector-class">.java</span>: <span class="hljs-number">6942</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.Instrumentation</span>.callActivityOnCreate(Instrumentation<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1126</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.performLaunchActivity(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2880</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.handleLaunchActivity(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">2988</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>. - wrap14(ActivityThread.java) at android<span class="hljs-selector-class">.app</span>.ActivityThread<span class="hljs-variable">$H</span>.handleMessage(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1631</span>) at android<span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Handler</span>.dispatchMessage(Handler<span class="hljs-selector-class">.java</span>: <span class="hljs-number">102</span>) at android<span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Looper</span>.loop(Looper<span class="hljs-selector-class">.java</span>: <span class="hljs-number">154</span>) at android<span class="hljs-selector-class">.app</span><span class="hljs-selector-class">.ActivityThread</span>.main(ActivityThread<span class="hljs-selector-class">.java</span>: <span class="hljs-number">6682</span>) at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span>.invoke(Native Method) at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.os</span>.ZygoteInit<span class="hljs-variable">$MethodAndArgsCaller</span>.run(ZygoteInit<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1520</span>) at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.ZygoteInit</span>.main(ZygoteInit<span class="hljs-selector-class">.java</span>: <span class="hljs-number">1410</span>) 复制代码</code></pre><p>这时候会抛出 NoSuchElementException 异常。</p><h1 id="6-条件操作符"><a href="#6-条件操作符" class="headerlink" title="6. 条件操作符"></a>6. 条件操作符</h1><h2 id="6-1-all"><a href="#6-1-all" class="headerlink" title="6.1 all()"></a>6.1 all()</h2><h4 id="方法预览：-60"><a href="#方法预览：-60" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; ambWith(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; other)复制代码</code></pre><h4 id="有什么用？-57"><a href="#有什么用？-57" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。</p><h4 id="怎么用？-56"><a href="#怎么用？-56" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).<span class="hljs-keyword">all</span>(<span class="hljs-built_in">new</span> Predicate &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> test(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> &lt; <span class="hljs-number">5</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Boolean</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Boolean</span> aBoolean) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;==================aBoolean &quot; + aBoolean);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">39</span>:<span class="hljs-number">51.644</span> <span class="hljs-number">1482</span><span class="hljs-number">-1482</span>/com.example.rxjavademo D/chan: ==================aBoolean <span class="hljs-literal">true</span>复制代码</code></pre><h2 id="6-2-takeWhile"><a href="#6-2-takeWhile" class="headerlink" title="6.2 takeWhile()"></a>6.2 takeWhile()</h2><h4 id="方法预览：-61"><a href="#方法预览：-61" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; takeWhile(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)复制代码</code></pre><h4 id="有什么用？-58"><a href="#有什么用？-58" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送。</p><h4 id="怎么用？-57"><a href="#怎么用？-57" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).takeWhile(<span class="hljs-built_in">new</span> Predicate &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> test(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> &lt; <span class="hljs-number">3</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================integer &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">43</span>:<span class="hljs-number">14.634</span> <span class="hljs-number">3648</span><span class="hljs-number">-3648</span>/com.example.rxjavademo D/chan: ========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">1</span>========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">2</span>复制代码</code></pre><h2 id="6-3-skipWhile"><a href="#6-3-skipWhile" class="headerlink" title="6.3 skipWhile()"></a>6.3 skipWhile()</h2><h4 id="方法预览：-62"><a href="#方法预览：-62" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; skipWhile(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)复制代码</code></pre><h4 id="有什么用？-59"><a href="#有什么用？-59" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当某个数据满足条件时不发送该数据，反之则发送。</p><h4 id="怎么用？-58"><a href="#怎么用？-58" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).skipWhile(<span class="hljs-built_in">new</span> Predicate &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> test(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> &lt; <span class="hljs-number">3</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================integer &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">47</span>:<span class="hljs-number">32.653</span> <span class="hljs-number">4861</span><span class="hljs-number">-4861</span>/com.example.rxjavademo D/chan: ========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">3</span>========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">4</span>复制代码</code></pre><h2 id="6-4-takeUntil"><a href="#6-4-takeUntil" class="headerlink" title="6.4 takeUntil()"></a>6.4 takeUntil()</h2><h4 id="方法预览：-63"><a href="#方法预览：-63" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs actionscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; takeUntil(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; stopPredicate复制代码</code></pre><h4 id="有什么用？-60"><a href="#有什么用？-60" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了。</p><h4 id="怎么用？-59"><a href="#怎么用？-59" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>).takeUntil(<span class="hljs-built_in">new</span> Predicate &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> test(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">integer</span> &gt; <span class="hljs-number">3</span>;    &#125;&#125;).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================integer &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">12.918</span> <span class="hljs-number">7933</span><span class="hljs-number">-7933</span>/com.example.rxjavademo D/chan: ========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">1</span>========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">2</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">12.919</span> <span class="hljs-number">7933</span><span class="hljs-number">-7933</span>/com.example.rxjavademo D/chan: ========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">3</span>========================<span class="hljs-built_in">int</span>eger <span class="hljs-number">4</span>复制代码</code></pre><h2 id="6-5-skipUntil"><a href="#6-5-skipUntil" class="headerlink" title="6.5 skipUntil()"></a>6.5 skipUntil()</h2><h4 id="方法预览：-64"><a href="#方法预览：-64" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs pf">public final <span class="hljs-variable">&lt;U&gt;</span> Observable<span class="hljs-variable">&lt;T&gt;</span> <span class="hljs-keyword">skip</span>Until(ObservableSource<span class="hljs-variable">&lt;U&gt;</span> other)复制代码</code></pre><h4 id="有什么用？-61"><a href="#有什么用？-61" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>当 skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者。</p><h4 id="怎么用？-60"><a href="#怎么用？-60" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>interval<span class="hljs-constructor">Range(1, 5, 0, 1, TimeUnit.SECONDS)</span>.skip<span class="hljs-constructor">Until(Observable.<span class="hljs-params">intervalRange</span>(6, 5, 3, 1, TimeUnit.SECONDS)</span>).subscribe(<span class="hljs-keyword">new</span> Observer &lt; Long &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onSubscribe &quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Next(Long <span class="hljs-params">along</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onNext &quot;</span> + along);    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onError &quot;</span>);    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onComplete &quot;</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50.574</span> <span class="hljs-number">13023</span><span class="hljs-number">-13023</span>/com.example.rxjavademo D/chan: ========================onSubscribe <span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">08</span>:<span class="hljs-number">53.576</span> <span class="hljs-number">13023</span><span class="hljs-number">-13054</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-number">4</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">08</span>:<span class="hljs-number">54.576</span> <span class="hljs-number">13023</span><span class="hljs-number">-13054</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-number">5</span>========================onComplete 复制代码</code></pre><p>从结果可以看出，skipUntil() 里的 Observable 并不会发送事件给观察者。</p><h2 id="6-6-sequenceEqual"><a href="#6-6-sequenceEqual" class="headerlink" title="6.6 sequenceEqual()"></a>6.6 sequenceEqual()</h2><h4 id="方法预览：-65"><a href="#方法预览：-65" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Single&lt;<span class="hljs-keyword">Boolean</span>&gt; sequenceEqual(ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source1, ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt; source2)......复制代码</code></pre><h4 id="有什么用？-62"><a href="#有什么用？-62" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断两个 Observable 发送的事件是否相同。</p><h4 id="怎么用？-61"><a href="#怎么用？-61" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>sequence<span class="hljs-constructor">Equal(Observable.<span class="hljs-params">just</span>(1, 2, 3)</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).subscribe(<span class="hljs-keyword">new</span> Consumer &lt; Boolean &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void accept(Boolean aBoolean) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================onNext &quot;</span> + aBoolean);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">11</span>:<span class="hljs-number">45.975</span> <span class="hljs-number">14157</span><span class="hljs-number">-14157</span>/? D/chan: ========================onNext <span class="hljs-literal">true</span>复制代码</code></pre><h2 id="6-7-contains"><a href="#6-7-contains" class="headerlink" title="6.7 contains()"></a>6.7 contains()</h2><h4 id="方法预览：-66"><a href="#方法预览：-66" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;<span class="hljs-keyword">Boolean</span>&gt; contains(<span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span> element)复制代码</code></pre><h4 id="有什么用？-63"><a href="#有什么用？-63" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。</p><h4 id="怎么用？-62"><a href="#怎么用？-62" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs lasso">Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).contains(<span class="hljs-number">3</span>).subscribe(<span class="hljs-literal">new</span> Consumer &lt; <span class="hljs-built_in">Boolean</span> &gt; () &#123;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> accept(<span class="hljs-built_in">Boolean</span> aBoolean) throws Exception &#123;        <span class="hljs-keyword">Log</span>.d(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">&quot;========================onNext &quot;</span> + aBoolean);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">14</span>:<span class="hljs-number">23.522</span> <span class="hljs-number">15085</span><span class="hljs-number">-15085</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-literal">true</span>复制代码</code></pre><h2 id="6-8-isEmpty"><a href="#6-8-isEmpty" class="headerlink" title="6.8 isEmpty()"></a>6.8 isEmpty()</h2><h4 id="方法预览：-67"><a href="#方法预览：-67" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;<span class="hljs-keyword">Boolean</span>&gt; isEmpty()复制代码</code></pre><h4 id="有什么用？-64"><a href="#有什么用？-64" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>判断事件序列是否为空。</p><h4 id="怎么用？-63"><a href="#怎么用？-63" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.<span class="hljs-keyword">create</span>(<span class="hljs-built_in">new</span> ObservableOnSubscribe &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-type">Integer</span> &gt; e) throws <span class="hljs-keyword">Exception</span> &#123;        e.onComplete();    &#125;&#125;).isEmpty().subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Boolean</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Boolean</span> aBoolean) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================onNext &quot; + aBoolean);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">16.725</span> <span class="hljs-number">16109</span><span class="hljs-number">-16109</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-literal">true</span>复制代码</code></pre><h2 id="6-9-amb"><a href="#6-9-amb" class="headerlink" title="6.9 amb()"></a>6.9 amb()</h2><h4 id="方法预览：-68"><a href="#方法预览：-68" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T&gt; Observable&lt;T&gt; amb(<span class="hljs-keyword">Iterable</span><span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> ObservableSource<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> T&gt;&gt; sources)复制代码</code></pre><h4 id="有什么用？-65"><a href="#有什么用？-65" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>amb() 要传入一个 Observable 集合，但是只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃。</p><h4 id="怎么用？-64"><a href="#怎么用？-64" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs reasonml">ArrayList &lt; Observable &lt; Long &gt;&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList &lt; &gt; <span class="hljs-literal">()</span>;<span class="hljs-built_in">list</span>.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>interval<span class="hljs-constructor">Range(1, 5, 2, 1, TimeUnit.SECONDS)</span>);<span class="hljs-built_in">list</span>.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>interval<span class="hljs-constructor">Range(6, 5, 0, 1, TimeUnit.SECONDS)</span>);<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>amb(<span class="hljs-built_in">list</span>).subscribe(<span class="hljs-keyword">new</span> Consumer &lt; Long &gt; <span class="hljs-literal">()</span> &#123;    @Override    public void accept(Long aLong) throws Exception &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;========================aLong &quot;</span> + aLong);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">29.580</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">6</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">30.580</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">7</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">31.579</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">8</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">32.579</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">9</span><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">21</span>:<span class="hljs-number">33.579</span> <span class="hljs-number">17185</span><span class="hljs-number">-17219</span>/com.example.rxjavademo D/chan: ========================aLong <span class="hljs-number">10</span>复制代码</code></pre><h2 id="6-10-defaultIfEmpty"><a href="#6-10-defaultIfEmpty" class="headerlink" title="6.10 defaultIfEmpty()"></a>6.10 defaultIfEmpty()</h2><h4 id="方法预览：-69"><a href="#方法预览：-69" class="headerlink" title="方法预览："></a>方法预览：</h4><pre><code class="hljs pf">public final Observable<span class="hljs-variable">&lt;T&gt;</span> <span class="hljs-keyword">default</span>IfEmpty(T <span class="hljs-keyword">default</span>Item)复制代码</code></pre><h4 id="有什么用？-66"><a href="#有什么用？-66" class="headerlink" title="有什么用？"></a>有什么用？</h4><p>如果观察者只发送一个 onComplete() 事件，则可以利用这个方法发送一个值。</p><h4 id="怎么用？-65"><a href="#怎么用？-65" class="headerlink" title="怎么用？"></a>怎么用？</h4><pre><code class="hljs pgsql">Observable.<span class="hljs-keyword">create</span>(<span class="hljs-built_in">new</span> ObservableOnSubscribe &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> subscribe(ObservableEmitter &lt; <span class="hljs-type">Integer</span> &gt; e) throws <span class="hljs-keyword">Exception</span> &#123;        e.onComplete();    &#125;&#125;).defaultIfEmpty(<span class="hljs-number">666</span>).subscribe(<span class="hljs-built_in">new</span> Consumer &lt; <span class="hljs-type">Integer</span> &gt; () &#123;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span>) throws <span class="hljs-keyword">Exception</span> &#123;        <span class="hljs-keyword">Log</span>.d(TAG, &quot;========================onNext &quot; + <span class="hljs-type">integer</span>);    &#125;&#125;);复制代码</code></pre><p>打印结果：</p><pre><code class="hljs angelscript"><span class="hljs-number">05</span><span class="hljs-number">-26</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">56.376</span> <span class="hljs-number">19249</span><span class="hljs-number">-19249</span>/com.example.rxjavademo D/chan: ========================onNext <span class="hljs-number">666</span>复制代码</code></pre><p>转自 <a href="">掘金：RxJava2 只看这一篇文章就够了-玉刚说</a></p>]]></content>
    
    
    <categories>
      
      <category>RxJava</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activity的初级，中级，高级问法</title>
    <link href="/Blog/2020/11/20/Activity%E7%9A%84%E5%88%9D%E7%BA%A7%EF%BC%8C%E4%B8%AD%E7%BA%A7%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%97%AE%E6%B3%95/"/>
    <url>/Blog/2020/11/20/Activity%E7%9A%84%E5%88%9D%E7%BA%A7%EF%BC%8C%E4%B8%AD%E7%BA%A7%EF%BC%8C%E9%AB%98%E7%BA%A7%E9%97%AE%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity的初级，中级，高级问法"><a href="#Activity的初级，中级，高级问法" class="headerlink" title="Activity的初级，中级，高级问法"></a>Activity的初级，中级，高级问法</h1><p>Activity是我们常用App开发中最重要的组件，主要用于展示界面和用户交互。本文分为三个部分：</p><p>Activity源码和常见的问题</p><ol><li>Activity的生命周期，正常情况和异常情况？</li><li>Activity的四种启动模式，启动页设置singleTask/singleInstance可能造成什么后果？</li><li>任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？</li><li>startActivityForResult导致的一系列问题？</li><li>清除返回栈（Clearing the back stack）的一些概念</li><li>allowTaskReparenting的使用</li><li>Activity的隐式启动</li><li>Activity启动流程</li></ol><p>Activity深层次问题</p><ol><li>Activity生命周期的变化对进程的优先级有什么影响？</li><li>如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？</li><li>一个Activity A启动另一个Activity B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？</li><li>为什么要这么设计Activity生命周期？</li></ol><p>第三方App中一些Activity的设置</p><ol><li>今日头条极速版-新闻界面打开的一些限制和首页</li></ol><h4 id="Activity源码和常见的问题"><a href="#Activity源码和常见的问题" class="headerlink" title="Activity源码和常见的问题"></a>Activity源码和常见的问题</h4><h5 id="1-Activity的生命周期，正常情况和异常情况？"><a href="#1-Activity的生命周期，正常情况和异常情况？" class="headerlink" title="1.Activity的生命周期，正常情况和异常情况？"></a>1.Activity的生命周期，正常情况和异常情况？</h5><p>首先来看看官网上Activity的生命周期，如下图所示</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38e47625f72949e4b2d035c27ed4c321~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>生命周期在开发中会常常被我们用到，比如在界面的恢复和销毁等回调具体的方法，我们在这些方法做一些数据的处理等。当然这里面还少了方法<code>onSaveInstance和onRestoreInstance</code>方法用于状态的保存和恢复，还有一个方法<code>onConfigurationChanged()</code>用于配置变更后的回调。</p><p>下面是一些<strong>常用的生命周期回调流程</strong>：</p><ul><li>启动Activity：<code>onCreate()-&gt;onStart()-&gt;onResume()</code></li><li>点击返回键：<code>onPause()-&gt;onStop()-&gt;onDestroy()</code></li><li>点击Home键：<code>onPause()-&gt;onSaveInstanceState()-&gt;onStop()</code>，<strong>注意在API28之后<code>onSaveInstanceState()</code>方法的执行放在了<code>onStop()</code>之后</strong>。</li><li>用户再次回到原Activity：<code>onRestart()-&gt;onStart()-&gt;onResume()</code></li><li>A Activity启动B Activity：<code>A#onPause()-&gt;B#onCreate()-&gt;B#onStart()-&gt;B#onResume()-&gt;A#onStop()</code></li></ul><p>再来看一下<strong>异常情况下的生命周期分析</strong>：</p><ol><li><p>系统配置发配置变化时生命周期的回调(API28+)</p><p><code>onPause()-&gt;onStop()-&gt;onSaveInstanceState()-&gt;onDestroy()</code>，然后当Activity被重新创建后执行<code>onCreate()-&gt;onStart()-&gt;onRestoreInstanceState()-&gt;onResume()</code></p><p>这里的配置发生变化可以指屏幕发生旋转或者切换到多窗口模式等等。</p><p><strong>系统配置发生改变时，如果不想重新创建Activity，可以通过在AndroidManifest.xml中配置<a href="https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn#config"><code>android:configChanges</code></a>属性，如果想做一些额外的操作可以在onConfigurationChanged回调中处理</strong>。</p></li><li><p>资源内存不足导致低优先级进程被回收，当系统资源不足时，会杀死低优先级进程，此时会调用<code>onSaveInstanceState()和onRestoreInstanceState()</code>进行数据的存储和恢复。</p></li></ol><h5 id="2-Activity的四种启动模式，启动页设置SingleTask-SingleInstance可能造成什么后果？"><a href="#2-Activity的四种启动模式，启动页设置SingleTask-SingleInstance可能造成什么后果？" class="headerlink" title="2.Activity的四种启动模式，启动页设置SingleTask/SingleInstance可能造成什么后果？"></a>2.Activity的四种启动模式，启动页设置SingleTask/SingleInstance可能造成什么后果？</h5><p>在清单文件中声明 Activity 时，可以使用 <a href="https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn"><code>Activity</code></a> 元素的 <a href="https://developer.android.com/guide/topics/manifest/activity-element?hl=zh-cn#lmode"><code>launchMode</code></a> 属性指定 Activity 应该如何与任务关联。</p><ul><li><p>stardard：默认模式，系统在启动该 Activity 的任务中创建 Activity 的新实例，并将 intent 传送给该实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。注意在该模式下配合FLAG_ACTIVITY_NEW_TASK 与 FLAG_ACTIVITY_CLEAR_TOP，单独/一起配合，<strong>都会重新创建实例</strong>。</p></li><li><p>singleTop：<strong>栈顶复用</strong>模式，如果当前任务的顶部已存在 Activity 的实例，则系统会通过调用其 <code>onNewIntent()</code> 方法来将 intent 转送给该实例，而不是创建 Activity 的新实例。在该模式下配合FLAG_ACTIVITY_CLEAR_TOP是用哪个，不会重新创建实例，会有类似SingleTask的效果，但是如果再加上FLAG_ACTIVITY_NEW_TASK，还是会创建新实例。</p></li><li><p>singleTask：<strong>栈内复用</strong>模式，系统会创建新任务，并实例化新任务的根 Activity。但是，如果另外的任务中已存在该 Activity 的实例，则系统会通过调用其 <code>onNewIntent()</code> 方法将 intent 转送到该现有实例，而不是创建新实例。Activity 一次只能有一个实例存在。该模式默认具有clearTop的效果。</p></li><li><p>singleInstance：<strong>单实例</strong>模式，与 <code>&quot;singleTask&quot;</code> 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。</p><p><strong>关于singleInstance有个特殊的情况</strong>，如果一个A Activity（standard）启动B Activity（singleInstance），这个时候用户点击了手机最近访问列表，然后在再点击该App所在的界面（卡片），然后这个时候点击返回键竟然就直接退出了App，而不是我们预期的退到A Activity界面。其实最近访问列表也是一个Activity（假设为C Activity），当我们从这个C Activity点击App卡片显示我们的singleInstance所在的界面B，这个时候就相当于C启动了B，所以我们点击返回键，就直接回到了桌面（有兴趣可以自己看看源码）。</p><p>还有一个特殊的情况（来自扔物线大佬的文章），就是在<strong>最近任务里看见的 Task 未必还活着，最近任务里看不见的 Task，也未必就死了，比如 singleInstance</strong>。当我们查看最近任务的时候，不同的 Task 会并列展示出来，但有一个前提：它们的 taskAffinity 需要不一样。<strong>在 Android 里，同一个 taskAffinity 可以被创建出多个 Task，但它们最多只能有一个显示在最近任务列表</strong>。这也就是为什么刚才例子里 singleInstance 的那个 Activity 会从最近任务里消失了：因为它被另一个相同 taskAffinity 的 Task 抢了排面。</p><p>同理，你在一个App从首页Activity新建一个Activity(singletask/singleInstance)，如果没有指定taskAffinity，这个Activity的taskAffinity和其他界面一样，所以在最近的范围列表，你也只能看到一个App的卡片，但是如果你taskAffinity设置的不一样，就可以看到在最近列表中看到两个了。</p></li></ul><p>上面讲到的任务对应的是TaskRecord(<strong>栈结构</strong>)，其内部维护了一个<code>ArrayList&lt;ActivityRecord&gt;</code>用来保存和管理ActivityRecord，<strong>ActivityRecord包含了一个Activity的所有信息</strong>。</p><p>通常我们的App都会设置启动页(SplashActivity通常是一张图片)，然后进入我们的主界面（MainActivity），在主界面中通常有很多逻辑会导致该界面异常庞大，占据的内存很大，所以很多时候我们都会给该界面设置为SingleTask栈内复用模式。</p><p>场景一：如果为了达到快速启动的效果，将我们的App的闪屏页(SplashActivity显示固定图片)移除掉，换成MainActivity（SingleTask/SingleInstance）的背景（windowBackground），最后再替换成App的主题，给用户快速响应的体验；</p><p>场景二：如果给启动页SplashActivity设置为SingleTask/SingleInstance模式，同时你的启动页没有及时的关闭。</p><p>以上两种场景会导致你的App无论冷启动还是热启动，每次点击图标都是从启动页开始启动的，具体的原理可以看我这篇文章的分析和解决方案。<a href="https://juejin.im/post/6888990959233662990">切记，不要在你的App启动界面设置SingleTask/SingleInstance</a>。</p><h5 id="3-任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？"><a href="#3-任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？" class="headerlink" title="3.任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？"></a>3.任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？</h5><p>首先来看官网的说明<a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn">Understand Tasks and Back Stack</a>，(A task is a collection of activities that users interact with when performing a certain job. The activities are arranged in a stack—the <em>back stack</em>)—in the order in which each activity is opened. )任务是用户在执行某项工作时与之互动的一系列 Activity 的集合。这些 Activity 按照每个 Activity 打开的顺序排列在一个返回堆栈中。前面说过任务对应的是TaskRecord(<strong>栈结构</strong>)，其内部维护了一个<code>ArrayList&lt;ActivityRecord&gt;</code>用来保存和管理ActivityRecord，ActivityRecord包含了一个Activity的所有信息。所以其实<strong>任务就是任务栈（TaskRecord是栈结构</strong>)。</p><p>那么返回栈是什么，首先展示一张Gityuan博客的<a href="http://gityuan.com/2017/06/11/activity_record/">图片</a>。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b681e32886a74f1c8012a762be7ccec6~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><ul><li>一般地，对于没有分屏功能以及虚拟屏的情况下，ActivityStackSupervisor与ActivityDisplay都是系统唯一；</li><li>ActivityDisplay主要有Home Stack和App Stack这两个栈；</li><li>每个ActivityStack中可以有若干个TaskRecord对象，<strong>当前只会有一个获得了焦点的ActivityStack</strong>；</li><li>每个TaskRecord包含如果若干个ActivityRecord对象；</li><li>每个ActivityRecord记录一个Activity信息。</li></ul><p><strong>一个返回栈可能只包含一个任务，但在特殊情况下，可能引入多个任务</strong>。这个概念非常重要，这里引用官方的图</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8031cba5772b40d089f2a6097ed69e82~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>这里先说一下操作流程，依次启动ActivityX，ActivityY，Activity1，Activity2；ActivityY，ActivityX（这两个都是SingleTask）在后台任务中，Activity2，Activity1在前台任务中，这两个任务的taskAffinity不同，当从Activity2中启动ActivityY的时候，返回栈如第二列所示，然后点击返回键可以一个个退出。</p><p>再普及一个概念在 Android 里，每个 Activity 都有一个 taskAffinity，它就相当于是对每个 Activity 预先进行的分组。它的值默认取自它所在的 Application 的 taskAffinity，而 Application 的 taskAffinity 默认是 App 的包名。当然也可以手动指定taskAffinity。</p><p><strong>但是图中并没有指明Activity2，Activity1是什么启动模式，实际上我如果我们指定为standard标准模式根本模拟不出这个场景，这一点有点坑</strong>，因为这四个Activity分别按2，1，X，Y排列，也即是说启动是从Y，X，1，2一个个启动的，如果Activity1为standard，就算你指定了Activity1的taskAffinity和ActivityY的不同也没有用，Activity1还是会和ActivityY在同一个任务(TaskRecord)中，也就是说**standard 和 singleTop 的 Activity 在哪个 TaskRecord 启动，全凭启动它的 Activity 在哪个 TaskRecord，taskAffinity在同时指定为singleTask模式下才有意义(只有一种例外，standard 和 singleTop在 allowTaskReparenting 为 true，且被其他应用以 DeepLink 的方式唤起时，才会在指定的任务中)**。</p><p>所以我们将Activity2，Activity1也设置为singleTask，同时taskAffinity也相同，才会模拟出上面的场景，点击Activity2启动ActivityY，才会将后台任务栈ActivityY，ActivityX都带到前台任务栈中，也就是都带到返回栈中。</p><p><strong>小结</strong></p><p>任务就是任务栈（<strong>TaskRecord是栈结构</strong>)，TaskRecord内部维护了一个<code>ArrayList&lt;ActivityRecord&gt;</code>用来保存和管理ActivityRecord，ActivityRecord包含了一个Activity的所有信息。</p><p>一个返回栈可能只包含一个任务，但特殊情况下，可能引入多个任务。<strong>返回栈，前台任务栈，后台任务栈其实在源码中并没有明确的定义，而是在我们操作任务栈过程中提出的一些“概念”，为了便于描述和区分</strong>。</p><p>前台栈比如现在<strong>下图A</strong>中的Activity2，Activity1所在的任务，后台任务栈是ActivityY，ActivityX所在的任务。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1be237dc6554e2fb67c20d2f5e0118c~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>但是问题来了，当Activity2启动ActivityY的时候，返回栈中的内容如<strong>下图B</strong>所示，这个时候前台任务栈是什么呢？</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f7ce0688724b05be5ac26d087b307d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>这个时候后台的任务栈（ActivityY，ActivityX）已经返回到前台，四个Activity都在前台，<strong>此时返回堆栈中包含了转到前台任务中的所有Activity（这句话来自<a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack?hl=zh-cn">官网</a>对这一场景的说明）</strong>。</p><p>问题又来了，比如我们前面说的后台任务栈是在后台等待恢复(比如ActivityX，ActivityY所在的栈)，依次启动ActivityX，ActivityY，Activity1，Activity2，如果你这个时候什么都不做，不断点击返回键，这四个Activity会一个个退出，这个时候你会不会觉得返回栈包含前台任务栈和后台任务栈。但是一开始图A中返回栈（Back Stack）只标明了Activity1，Activity2，这就出现矛盾了，<strong>但我的感觉返回栈就是字面上的含义，点击返回键，能退出多少个Activity，那么这些Activity就都在返回栈中，返回栈就是一个概念，当然你也可以理解它的大小动态变化的（点击返回键的过程中可能大小可能新增）</strong>。</p><h5 id="4-startActivityForResult导致的一系列问题？"><a href="#4-startActivityForResult导致的一系列问题？" class="headerlink" title="4.startActivityForResult导致的一系列问题？"></a>4.startActivityForResult导致的一系列问题？</h5><p>在使用Activity的startActivityForResult启动新界面时，在Api20以下调整时会直接返回<code>Activity.RESULT_CANCELED</code>，官方觉得不应该在两个任务之间setResult。在Api20及以上，对于非startActivity跳转，也就是reqeusetCode&gt;=0，singleTask和SingleInstance模式启动的Activity都不会新建一个任务，还是在原来的栈中。同时官方也建议：</p><p>虽然所有 API 级别的 <code>Activity</code> 类均提供底层 <a href="%5Bdeveloper.android.com/reference/a%E2%80%A6%5D(https://developer.android.com/reference/android/app/Activity#startActivityForResult(android.content.Intent"><code>startActivityForResult()</code></a>, int)) 和 <a href="%5Bdeveloper.android.com/reference/a%E2%80%A6%5D(https://developer.android.com/reference/android/app/Activity#onActivityResult(int"><code>onActivityResult()</code></a>, int, android.content.Intent)) API，但我们强烈建议您使用 AndroidX <a href="https://developer.android.com/jetpack/androidx/releases/activity#1.2.0-alpha02">Activity <code>1.2.0-alpha02</code></a> 和 <a href="https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha02">Fragment <code>1.3.0-alpha02</code></a> 中引入的 Activity Result API。</p><h5 id="5-清除返回栈（Clearing-the-back-stack）的一些概念"><a href="#5-清除返回栈（Clearing-the-back-stack）的一些概念" class="headerlink" title="5.清除返回栈（Clearing the back stack）的一些概念"></a>5.清除返回栈（Clearing the back stack）的一些概念</h5><p>如果用户离开任务较长时间，系统会清除任务中除根 Activity 以外的所有 Activity。当用户再次返回到该任务时，只有根 Activity 会恢复。系统之所以采取这种行为方式是因为，经过一段时间后，用户可能已经放弃了之前执行的操作，现在返回任务是为了开始某项新的操作。</p><p>您可以使用一些 Activity 属性来修改此行为：</p><ul><li><p><code>alwaysRetainTaskState</code></p><p>如果在任务的根 Activity 中将该属性设为 <code>&quot;true&quot;</code>，则不会发生上述默认行为。即使经过很长一段时间后，任务仍会在其堆栈中保留所有 Activity。</p></li><li><p><code>clearTaskOnLaunch</code></p><p>如果在任务的根 Activity 中将该属性设为 <code>&quot;true&quot;</code>，那么只要用户离开任务再返回，堆栈就会被清除到只剩根 Activity。也就是说，它与 <a href="https://developer.android.com/guide/topics/manifest/activity-element#always"><code>alwaysRetainTaskState</code></a> 正好相反。用户始终会返回到任务的初始状态，即便只是短暂离开任务也是如此。</p></li><li><p><code>finishOnTaskLaunch</code></p><p>该属性与 <a href="https://developer.android.com/guide/topics/manifest/activity-element#clear"><code>clearTaskOnLaunch</code></a> 类似，但它只会作用于单个 Activity 而非整个任务。它还可导致任何 Activity 消失，包括根 Activity。如果将该属性设为 <code>&quot;true&quot;</code>，则 Activity 仅在当前会话中归属于任务。如果用户离开任务再返回，则该任务将不再存在。</p></li></ul><h5 id="6-allowTaskReparenting的使用"><a href="#6-allowTaskReparenting的使用" class="headerlink" title="6.allowTaskReparenting的使用"></a>6.allowTaskReparenting的使用</h5><p>Activity 默认情况下只会归属于一个 Task，不会在多个 Task 之间跳来跳去，但你可以通过设置来改变这个逻辑。把它的 allowTaskReparenting 属性设置为 true。如果未设置该属性，则由 <code>&lt;Activity&gt;</code> 元素的相应 <code>allowTaskReparenting</code> 属性所设置的值。默认值为“<code>false</code>”。</p><p>正常情况下，Activity 启动时会与启动它的任务关联，并在其整个生命周期中一直留在该任务处。当不再显示现有任务时，您可以使用该属性强制 Activity 将其父项更改为与其有相似性的任务。该属性通常用于将应用的 Activity 转移至与该应用关联的主任务。</p><p>例如，如果电子邮件消息包含网页链接，则点击该链接会调出可显示该网页的 Activity。该 Activity 由浏览器应用定义，但作为电子邮件任务的一部分启动。<strong>如果将该 Activity 的父项更改为浏览器任务，则它会在浏览器下一次转至前台时显示，在电子邮件任务再次转至前台时消失</strong>。</p><h5 id="7-Activity的隐式启动"><a href="#7-Activity的隐式启动" class="headerlink" title="7.Activity的隐式启动"></a>7.Activity的隐式启动</h5><p>Activity分为显示启动和隐式启动，显示启动就是我们平时调用的一些<code>startActivityXXX()</code>方法，隐式启动可以通过action来启动，启动时调用如下，同时要记得添加category为<code>&quot;android.intent.category.DEFAULT&quot;</code>。</p><pre><code class="hljs java">Intent implicitIntent = <span class="hljs-keyword">new</span> Intent();implicitIntent.setAction(<span class="hljs-string">&quot;com.test.image&quot;</span>);implicitIntent.addCategory(<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span>);MainActivity.<span class="hljs-keyword">this</span>.startActivity(implicitIntent);复制代码</code></pre><p>具体界面的配置如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ImageActivity&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.test.image&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>复制代码</code></pre><p>注意如果是其他App的Activity，需要添加android:exported=”true”才能被调用。</p><h5 id="8-Activity的启动流程（中级问题）"><a href="#8-Activity的启动流程（中级问题）" class="headerlink" title="8.Activity的启动流程（中级问题）"></a>8.Activity的启动流程（中级问题）</h5><p>对很多开发者来说，这可能都是个很沉重的问题，原因很简单，因为回答不好，毕竟里面涉及到的东西很多，需要你拥有很大知识存储量。下面来尝试回答这个问题（基于源码9.0）</p><p>首先先普及一些常见的概念</p><h6 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h6><p>Android Instrumentation是Android系统中的一套控制方法或者“钩子”，这些钩子可以在正常的生命周期（正常是由操作系统控制的）之外控制Android控件的运行，其实指的就是<strong>Instrumentation类提供的各种流程控制方法</strong>。</p><p><code>app-&gt;instrumentation-&gt;ams-&gt;app</code>，自动化测试可以通过Instrumentation来操作Activity等，这个<strong>Instrumentation相当于设计了一个统一的入口</strong>。</p><h6 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h6><p>ActivityThread不是线程类（Thread），只不过它会跑在<code>ActivityThread.main()</code>方法中，安卓程序的入口就是该方法，同时在该方法中一个Looper不断循环的在消息队列中处理消息。管理应用程序进程中主线程的执行，根据Activity管理者的请求调度和执行activities、broadcasts及其相关的操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 看源码很重要的一个能力就是‘眼中只有你’，认不到的都忽略，看认得到的</span>    ···    <span class="hljs-comment">// 创建主线程的Looper对象，发现和工作线程创建Looper对象调用的方法不一样，这里先记下，以后在详解。</span>    <span class="hljs-comment">// 主线程原来也有Looper对象啊</span>    Looper.prepareMainLooper();    <span class="hljs-comment">//创建ActivityThread</span>    ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();    thread.attach(<span class="hljs-keyword">false</span>);    <span class="hljs-comment">// 如果主线程的Handler为空（可以看出，一个好的命名可读性是多么高），那就为主线程创建一个Handler。</span>    <span class="hljs-comment">// 然后我们还可以在主线程创建Handler，说明一个线程对应多个Handler。多读源码，很多问题都得到了解决啊。</span>    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;        sMainThreadHandler = thread.getHandler();    &#125;    Looper.loop()；        <span class="hljs-comment">// 这里抛了个异常，主线程loop异常退出。说明主线程loop不能退出，这里和前面建立Looper对象的调用方法有关</span>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);&#125;复制代码</code></pre><h6 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h6><p>Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作。</p><h6 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h6><p>该类提供与Activity、Service和Process相关的信息以及交互方法， 可以被看作是ActivityManagerService的辅助类。</p><h6 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h6><p>负责所有Activity栈的管理。内部管理了mHomeStack、mFocusedStack和mLastFocusedStack三个Activity栈。其中，mHomeStack管理的是Launcher相关的Activity栈；mFocusedStack管理的是当前显示在前台Activity的Activity栈；mLastFocusedStack管理的是上一次显示在前台Activity的Activity栈。下面是大致的关系图，对于没有分屏功能以及虚拟屏的情况下，ActivityStackSupervisor与ActivityDisplay都是系统唯一。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><h6 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h6><p>ActivityStack负责“Activity栈”的状态和管理，ActivityStack内部包含了多个任务栈（TaskRecord），TaskRecord内部维护了一个<code>ArrayList&lt;ActivityRecord&gt;</code>用来保存和管理ActivityRecord，ActivityRecord包含了一个Activity的所有信息</p><p>如果我们从桌面点击启动app，桌面就是一个Activity，点击app（按钮）启动我们的启动页Activity，从这里分析Activity的启动流程更加全面，而不是在app中去启动一个普通的Activity。可以分为如下几个流程</p><ol><li><p>Launcher通知AMS启动App的启动页Activity，AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。</p><p>Launcher进入pause状态后，通知AMS已经paused了，可以启动App了</p></li><li><p>如果App未开启过，AMS发送创建进程请求，Zogyte进程接受AMS请求并孵化应用进程，应用进程调用ActivityThread并调用mian()方法，并且main()方法中创建ActivityThread对象，<code>activityThread.attach()</code>方法中进行绑定（应用进程绑定到AMS），传入applicationThread以便通讯。</p></li><li><p>AMS通知App绑定Application（bindApplication）并启动Activity，并且创建和关联Context,最后调用onCreate等方法。</p></li></ol><h6 id="灵魂拷问：AMS，Zogyte，App进程，Launcher如何通信？"><a href="#灵魂拷问：AMS，Zogyte，App进程，Launcher如何通信？" class="headerlink" title="灵魂拷问：AMS，Zogyte，App进程，Launcher如何通信？"></a>灵魂拷问：AMS，Zogyte，App进程，Launcher如何通信？</h6><p>这个问题一旦问出来，能干翻一大堆开发人员，下面来仔细讲讲：</p><p>App进程和AMS是如何通信的？</p><p>Zogyte去fork一个App进程，后面就是应用进程和AMS两者的事情了，我们知道Android的跨进程通信是通过Binder服务的，AMS所在的进程和应用进程在通过Binder互相通信时，实际上都是通过两者的代理类进行通信的。</p><p>ActivityManagerService(AMS)在手机开机后时就已经启动了，应用进程去调用AMS的方法，比如startActivity，很容易调用，因为AMS是一个有名称的Binder服务，在任意地方都可以通过在ServiceManger（SM）里面查询拿到代理类，调用代理类的对应方法，然后再去调用AMS的真正方法。</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>因为Binder通信是通过代理类来通信的，如果拿不到代理类，其他进程就不知道如何和我们的App通信，系统服务中的AMS也就不知道如何和我们App通信了，所以当App进程创建完成后，会进行设置代理，代理的设置过程如图</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>就是在<code>ActivityThread.attach(false)</code>方法中，AMS绑定ApplicationThread对象，即应用进程绑定到AMS，<strong>通过调用AMS的attachApplication来将ActivityThread的内部类ApplicationThread对象绑定至AMS，这样AMS就可以通过这个代理对象来控制应用进程</strong>。</p><p>AMS和Launcher是怎么通信的？</p><p>其实Launcher也是一个App，调用startActivity方法，然后调用的是Instrumentation的execStartActivity方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span><span class="hljs-function"><span class="hljs-params">        Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123;    ...    <span class="hljs-keyword">try</span> &#123;   ...    <span class="hljs-comment">//获取AMS的代理对象</span>        <span class="hljs-keyword">int</span> result = ActivityManager.getService()            .startActivity(whoThread, who.getBasePackageName(), intent,                    intent.resolveTypeIfNeeded(who.getContentResolver()),                    token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,                    requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);        checkStartActivityResult(result, intent);    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Failure from system&quot;</span>, e);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;复制代码</code></pre><p>在这个方法会调用ActivityManager的getService方法来得到AMS的代理对象，然后调用这个代理对象的startActivity方法</p><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> IActivityManagerSingleton.get();&#125;<span class="hljs-meta">@UnsupportedAppUsage</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =        <span class="hljs-keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">//得到activity的service引用，即IBinder类型的AMS引用</span>                <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);        <span class="hljs-comment">//转换成IActivityManager对象</span>                <span class="hljs-keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);                <span class="hljs-keyword">return</span> am;            &#125;        &#125;;复制代码</code></pre><p>可以发现在Singleton中的create方法中由于b是AMS引用作为服务端处于SystemServer进程中，与当前Launcher进程作为客户端与服务端不在同一个进程，所以am返回的是IActivityManager.Stub的代理对象，此时如果要实现客户端与服务端进程间的通信，只需要在AMS继承了IActivityManager.Stub类并实现了相应的方法，而通过下面的代码可以发现AMS刚好是继承了IActivityManager.Stub类的，这样Launcher进程作为客户端就拥有了服务端AMS的代理对象，然后就可以调用AMS的方法来实现具体功能了，就这样Launcher的工作就交给AMS实现了。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IActivityManager</span>.<span class="hljs-title">Stub</span></span><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Watchdog</span>.<span class="hljs-title">Monitor</span>, <span class="hljs-title">BatteryStatsImpl</span>.<span class="hljs-title">BatteryCallback</span> </span>&#123;&#125;复制代码</code></pre><p>Zygote和AMS是如何通信的？</p><p>AMS和Zygote建立Socket连接，然后发送创建应用进程的请求。具体可以参考<a href="http://liuwangshu.cn/framework/booting/2-zygote.html">这里</a>。</p><p>最后我们再来看看流程图，看下方的App进程启动过程和<code>Activity.startActivity</code>这两个流程</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>这里还要提到一点，<strong>Hook Activity的启动流程是一个很重要的运用场景</strong>，我们需要欺骗AMS，然后启动真正的TargetActivity，Hook有起始点和终点。这里需要寻找两个地方的hook点，一个是对Intent中Activity的替换（hookIActivityTaskManager方法），一个是对Intent中Activity的还原（hookHandler）。</p><p>在回答Activity的启动流程时，具体的方法如何调用并不重要，所以我才会在最后放出整个流程，各个进程之间如何建立通信，如何通信很重要，同时一些Activity相关概念也很重要，熟悉这些，你就很容易把整个流程串起来了。</p><h4 id="Activity深层次问题"><a href="#Activity深层次问题" class="headerlink" title="Activity深层次问题"></a>Activity深层次问题</h4><h5 id="1-Activity生命周期的变化对进程的优先级有什么影响？"><a href="#1-Activity生命周期的变化对进程的优先级有什么影响？" class="headerlink" title="1.Activity生命周期的变化对进程的优先级有什么影响？"></a>1.Activity生命周期的变化对进程的优先级有什么影响？</h5><p>这里先看一下官网上<a href="https://developer.android.com/guide/components/activities/process-lifecycle">Activity生命周期</a>上对onStart的一段描述，onStart时候Activity就对用户可见了</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>同时你也可以在《Android开发艺术探索》上看到类似的描述</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>但是了解Activity启动流程源码的朋友都知道，ActivityThread的handleResumeActivity方法中，<strong>首先调用Activity的onResume方法，接着会调用Activity.makeVisible()在该方法中，DecorView真正完成了添加和显示这两个过程，到这里Activity的视图才能被看到</strong>。DecoreView和Window进行关联。有兴趣可以看看我这篇文章的<a href="https://juejin.im/post/6886629660814868488#heading-7">分析</a>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeVisible</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mWindowAdded) &#123;            ViewManager wm = getWindowManager();          <span class="hljs-comment">//DecoreView和WindowManager进行关联。</span>            wm.addView(mDecor, getWindow().getAttributes());            mWindowAdded = <span class="hljs-keyword">true</span>;        &#125;  <span class="hljs-comment">//设置DecorView可见</span>        mDecor.setVisibility(View.VISIBLE);    &#125;复制代码</code></pre><p>也就是说在onResume方法执行之后再调用Activity.makeVisible()方法，我们才能真正用<strong>肉眼</strong>看到我们的DecoreView，看到这里你这里不禁会产生一个疑问，那上面官网上的说法（**<code>onStart()</code> 调用使 Activity 对用户可见**）难道是错误的吗？</p><p>带着疑问我们继续在官网上找答案，在<a href="https://developer.android.com/guide/components/activities/process-lifecycle">进程和生命周期</a>这一章节上可以看到：</p><p>为了确定在内存不足时应该终止哪些进程，Android 会根据每个进程中运行的组件以及这些组件的状态，将它们放入“重要性层次结构”。这些进程类型包括（<strong>按重要性排序</strong>）：</p><ol><li><strong>前台进程</strong>是用户目前执行操作所需的进程。在不同的情况下，进程可能会因为其所包含的各种应用组件而被视为前台进程。如果以下任一条件成立，则进程会被认为位于前台：</li></ol><ul><li>它正在用户的互动屏幕上运行一个 <code>Activity</code>（其 <code>onResume()</code> 方法已被调用）。</li><li>它有一个 <code>BroadcastReceiver</code> 目前正在运行（其 <code>BroadcastReceiver.onReceive()</code> 方法正在执行）。</li><li>它有一个 <code>Service</code> 目前正在执行其某个回调（<code>Service.onCreate()</code>、<code>Service.onStart()</code> 或 <code>Service.onDestroy()</code>）中的代码。</li></ul><ol><li><p>系统中只有少数此类进程，而且除非内存过低，导致连这些进程都无法继续运行，才会在最后一步终止这些进程。通常，此时设备已达到内存分页状态，因此必须执行此操作才能使用户界面保持响应。</p></li><li><p><strong>可见进程</strong>正在进行用户当前知晓的任务，因此终止该进程会对用户体验造成明显的负面影响。在以下条件下，进程将被视为可见：</p><ul><li>它正在运行的 <code>Activity</code> 在屏幕上对用户可见，但不在前台（其 <code>onPause()</code> 方法已被调用）。举例来说，如果前台 Activity 显示为一个对话框，而这个对话框允许在其后面看到上一个 Activity，则可能会出现这种情况。</li><li>它有一个 <code>Service</code> 正在通过 <code>Service.startForeground()</code>（要求系统将该服务视为用户知晓或基本上对用户可见的服务）作为前台服务运行。</li><li>系统正在使用其托管的服务实现用户知晓的特定功能，例如动态壁纸、输入法服务等。</li></ul><p>相比前台进程，系统中运行的这些进程数量较不受限制，但仍相对受控。这些进程被认为非常重要，除非系统为了使所有前台进程保持运行而需要终止它们，否则不会这么做。</p></li><li><p><strong>服务进程</strong>包含一个已使用 <code>startService()</code> 方法启动的 <code>Service</code> 。虽然用户无法直接看到这些进程，但它们通常正在执行用户关心的任务（例如后台网络数据上传或下载），因此系统会始终使此类进程保持运行，除非没有足够的内存来保留所有前台和可见进程。</p><p>已经运行了很长时间（例如 30 分钟或更长时间）的服务的重要性可能会降位，以使其进程降至下文所述的缓存 LRU 列表。这有助于避免超长时间运行的服务因内存泄露或其他问题占用大量内存，进而妨碍系统有效利用缓存进程。</p></li><li><p><strong>缓存进程</strong>是目前不需要的进程，因此，如果其他地方需要内存，系统可以根据需要自由地终止该进程。在正常运行的系统中，这些是内存管理中涉及的唯一进程：运行良好的系统将始终有多个缓存进程可用（为了更高效地切换应用），并根据需要定期终止最早的进程。只有在非常危急（且具有不良影响）的情况下，系统中的所有缓存进程才会被终止，此时系统必须开始终止服务进程。</p><p>这些进程通常包含用户当前不可见的一个或多个 <code>Activity</code> 实例（<code>onStop()</code> 方法已被调用并返回）。只要它们正确实现其 Activity 生命周期（详情请见 <code>Activity</code>），那么当系统终止此类流程时，就不会影响用户返回该应用时的体验，因为当关联的 Activity 在新的进程中重新创建时，它可以恢复之前保存的状态。</p><p>这些进程保存在伪 LRU 列表中，列表中的最后一个进程是为了回收内存而终止的第一个进程。此列表的确切排序政策是平台的实现细节，但它通常会先尝试保留更多有用的进程（比如托管用户的主屏幕应用、用户最后看到的 Activity 的进程等），再保留其他类型的进程。还可以针对终止进程应用其他政策：比如对允许的进程数量的硬限制，对进程可持续保持缓存状态的时间长短的限制等。</p></li></ol><p>可以看到在屏幕上运行时一个Activity的onResume的方法已被调用，此时处于前台进程；可见进程的一个符合条件：<strong>它正在运行的 <code>Activity</code> 在屏幕上对用户可见，但不在前台</strong>，然后再对比上面对onStart的描述（<code>onStart()</code> 调用使 Activity 对用户可见，因为应用会<strong>为 Activity 进入前台并支持互动做准备</strong>），这下子你就豁然开朗了，这里的<strong>onStart的可见指的是可见进程的可见，而不是真正意义上的肉眼可见</strong>。</p><p>“onPause此方法表示 Activity 不再位于前台（尽管在用户处于多窗口模式时 Activity 仍然可见）”，“如果您的 Activity 不再对用户可见，说明其已进入“已停止”状态，因此系统将调用 <code>onStop()</code> 回调”，以上都是官方的描述，我们可以打印一下手机中的这些进程，使用<code>adb shell dumpsys meminfo</code>命令，设备是android 10华为手机。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cebd5b982f694241866dc10e27b59b9d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>可以看到分别对应我们的前台进程，可见进程，服务进程和缓存进程，其中服务进程还分为A Services和B Services。其实远远不止这么多的进程级别区分，我自己的App打开后，然后点击home键退到后台，此时属于<strong>Previous进程</strong>（后台进程）级别（com.jackie.testdialog），如果我打开App后，点击返回键退出，这个时候我的App进程就变成了<strong>Cached进程</strong>级别了。</p><p>讲了这么多，你可能觉得一直没有一个量化的数字，进程的级别（oom_adj）的取值范围是多少，在Android7.0之后，ADJ采用100，200，300等数字。下面是基于android9的区分：</p><table><thead><tr><th>ADJ级别</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>NATIVE_ADJ</td><td>-1000</td><td>native进程</td></tr><tr><td>SYSTEM_ADJ</td><td>-900</td><td>仅指system_server进程</td></tr><tr><td>PERSISTENT_PROC_ADJ</td><td>-800</td><td>系统persistent进程</td></tr><tr><td>PERSISTENT_SERVICE_ADJ</td><td>-700</td><td>关联着系统或persistent进程</td></tr><tr><td><code>FOREGROUND_APP_ADJ</code></td><td>0</td><td>前台进程</td></tr><tr><td><code>VISIBLE_APP_ADJ</code></td><td>100</td><td>可见进程</td></tr><tr><td><code>PERCEPTIBLE_APP_ADJ</code></td><td>200</td><td>可感知进程，比如后台音乐播放</td></tr><tr><td>BACKUP_APP_ADJ</td><td>300</td><td>备份进程</td></tr><tr><td>HEAVY_WEIGHT_APP_ADJ</td><td>400</td><td>重量级进程</td></tr><tr><td><code>SERVICE_ADJ</code></td><td>500</td><td>服务进程</td></tr><tr><td>HOME_APP_ADJ</td><td>600</td><td>Home进程</td></tr><tr><td>PREVIOUS_APP_ADJ</td><td>700</td><td>上一个进程</td></tr><tr><td><code>SERVICE_B_ADJ</code></td><td>800</td><td>B List中的Service</td></tr><tr><td><code>CACHED_APP_MIN_ADJ</code></td><td>900</td><td>不可见进程的adj最小值</td></tr><tr><td>CACHED_APP_MAX_ADJ</td><td>906</td><td>不可见进程的adj最大值</td></tr></tbody></table><p>开发者应该减少在保活上花心思，更应该在优化内存上下功夫，因为在相同ADJ级别的情况下，系统会选择优先杀内存占用的进程。当然你也可以手动去测试App的进程级别，不过过程可能有点麻烦，可以参考这篇<a href="https://juejin.im/post/6891911483379482637#heading-23">文章</a>。</p><p><strong>小结</strong></p><p>当界面只有一个Activity时，它进入onStart和onPause时是可见进程，进入onResume时是前台进程，打开后点击Home键退到后台这个时候是Previous进程（后台进程），如果直接点击返回键退出Activity，这个时候是缓存进程；如果有多个Activity（注意这个时候只有app从后台任务进入前台，或者点击Home键退到后台这两种场景；因为app在前台运行时都是前台进程），栈顶的的Activity进入onStart和onPause时是可见进程，进入onResume后是前台进程，点击Home键退到后台时是Previous进程（大家常说的后台进程）。</p><h5 id="2-如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？"><a href="#2-如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？" class="headerlink" title="2.如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？"></a>2.如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？</h5><p>如果你点击主界面MainActivity，点击返回键后系统执行MainActivity的onDestory方法，这个时候<strong>App进程为缓存进程，下次启动App你会发现Application的onCreate方法并不会执行</strong>，当然MainActivity的生命周期都会正常执行，这是因为从缓存进程启动App，系统已经缓存了很多信息，很多数据并不会被销毁，onCreate中初始化的那些内容还在，方便用户下次快速启动。利用这一特性，我们的App首次启动速度一般为500<del>600ms，退出App后存在缓存进程的情况下，每次启动的速度一般为200</del>300ms，算是某种程度上提升了App的启动时间。</p><p>需要注意的是，很多App在退出主界面的时候，会手动调用如下代码去退出App</p><pre><code class="hljs java">System.exit(<span class="hljs-number">0</span>);复制代码</code></pre><p>一旦调用了如下代码，就会彻底的退出并不会利用缓存进程的优势，也失去了系统提供给我们的优化了。</p><h5 id="3-一个Activity-A启动另一个Activity-B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？"><a href="#3-一个Activity-A启动另一个Activity-B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？" class="headerlink" title="3.一个Activity A启动另一个Activity B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？"></a>3.一个Activity A启动另一个Activity B，为何会先走A的onPause方法，等到B执行完onResume方法后，才会走A的onStop方法呢？</h5><p>如果你看过前面两个问题，这个问题你可能已经有答案了。手机之所以进行进程的管理，用不同的优先级对进程进行区分，首先肯定是为了保证用户的流畅体验，对于优先级低且占用内存高的进程及时清理，保证前台进程有足够的运行空间。前面我们讲到处于前台的（获取焦点）界面只有一个，onPause时当前进程离开了前台，当然可能也要进行一些数据的保存，所以肯定需要先执行当前界面的某个方法，然后再执行B界面的onCreate，onStart，onResume是为了新的界面能够被快速呈现（获取焦点），然后再走旧界面A的onStop方法。</p><p>这里也需要注意，onPause方法中尽量不要去做耗时的操作，如果过于耗时，新界面会很久才能显示出来，尽量放在onStop方法中去做。当然onStop中也不能做过于耗时的操作中，前面我们也试过，点击Home键会执行onStop方法，此时App进程处于后台进程，此时进程的优先级的很低的，当内存不足时，onStop中保存数据的操作可能就未完成，然后App进程就被系统回收了。</p><p>关于状态保存和恢复，在API28之前，onSaveInstanceState执行在onStop之前，但不限于在onPause之前或之后；在API28之后，onSaveInstanceState 执行时机已确定为在 <code>onStop</code> 之后。而onRestoreInstanceState确定执行在onStart之后。</p><h5 id="4-为什么要这么设计Activity生命周期"><a href="#4-为什么要这么设计Activity生命周期" class="headerlink" title="4.为什么要这么设计Activity生命周期"></a>4.为什么要这么设计Activity生命周期</h5><p>假如你自己设计界面的生命周期：</p><ul><li>界面启动时候用需要设计一个方法</li><li>界面完全渲染完毕显示需要一个方法</li><li>界面被部分遮盖时/跳到其他界面/退到后台需要一个方法</li><li>界面完全退出销毁时需要一个方法</li></ul><p>这么看来，我们好像只需要onCreate，onResume，onPause，onDestroy这四个方法，但是这只是一个很粗糙的界面创建~退出流程的回调，但是你看看IOS的UIViewController的生命周期，看起来就是个精致的猪猪女孩</p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>这样一对比，连Android的生命周期显得有点粗糙了，其实不全是，Activity还有一系列的<code>onPostXXX</code>方法以及onContentChanged等，但还是没有IOS细腻。其实我觉得，这些生命周期的回调是基于一些场景设计的，从视图的显示到销毁，考虑到不同的需求，我们需要不同程度级别的设计，<strong>如果Android是一个非常简单的系统，也不会实现那么多的特殊需求，可能只需要前面我说的那四个方法就够了，我感觉在生命周期的设计方面，IOS做的更好一些，对开发者更加友好</strong>。</p><p>也有一些人在回答生命周期为什么要这么设计时，可能会这么回答，因为界面需要有个创建/销毁过程，onCreate/onDestroy肯定需要，onStart时进程为可见进程，提升进程的优先级，或者做一些特殊场景的操作，onResume在界面启动完成或者恢复时需要，界面在被透明Activity的覆盖时会执行onPause()，需要有个方法在这个时候做状态保存或特殊操作等，onStop时可以进行状态保存。<strong>这样想问题完全是一种结果倒推的想法，经不起仔细的推敲，一定不要从具体的方法去推场景，而是应该从需求场景开始推导，切记，这一切都是需求或可能的需求引起的</strong>！</p><h4 id="第三方App中一些Activity的设置"><a href="#第三方App中一些Activity的设置" class="headerlink" title="第三方App中一些Activity的设置"></a>第三方App中一些Activity的设置</h4><h5 id="今日头条极速版-新闻界面打开的一些限制"><a href="#今日头条极速版-新闻界面打开的一些限制" class="headerlink" title="今日头条极速版-新闻界面打开的一些限制"></a>今日头条极速版-新闻界面打开的一些限制</h5><p>NewDetailActivity就是我们看到的普通新闻界面，最多只能打开四个，超过四个就会将之前最早的NewDetailActivity关闭，原因很简单，如果无限制的话Activity会越建越多，整个应用越来越卡，影响用户体验。</p><pre><code class="hljs roboconf">TaskRecord&#123;8636<span class="hljs-attribute">d7b #6564 A=com.ss.android.article.lite U=0 StackId=282 sz=5&#125;</span><span class="hljs-attribute">        Run #4</span>: ActivityRecord&#123;8794744 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.base</span><span class="hljs-variable">.feature</span><span class="hljs-variable">.detail</span>2<span class="hljs-variable">.view</span><span class="hljs-variable">.NewDetailActivity</span> t6564&#125;        Run #3: ActivityRecord&#123;8be5248 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.base</span><span class="hljs-variable">.feature</span><span class="hljs-variable">.detail</span>2<span class="hljs-variable">.view</span><span class="hljs-variable">.NewDetailActivity</span> t6564&#125;        Run #2: ActivityRecord&#123;8bd6a09 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.base</span><span class="hljs-variable">.feature</span><span class="hljs-variable">.detail</span>2<span class="hljs-variable">.view</span><span class="hljs-variable">.NewDetailActivity</span> t6564&#125;        Run #1: ActivityRecord&#123;87cc383 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.base</span><span class="hljs-variable">.feature</span><span class="hljs-variable">.detail</span>2<span class="hljs-variable">.view</span><span class="hljs-variable">.NewDetailActivity</span> t6564&#125;        Run #0: ActivityRecord&#123;8bd6b44 u0 com<span class="hljs-variable">.ss</span><span class="hljs-variable">.android</span><span class="hljs-variable">.article</span><span class="hljs-variable">.lite</span>/<span class="hljs-variable">.activity</span><span class="hljs-variable">.SplashActivity</span> t6564&#125;复制代码</code></pre><p>而且还可以发现这个**今日头条极速版的主页叫SplashActivity，真他么牛逼~**，估计是原来有个SplashActivity界面和MainActivity界面，为了优化快速启动，给用户一个秒开的感觉，移除原来的SplashActivity，直接把MainActivity改名为SplashActivity，然后做主题的替换。</p><p>然后我们看看它的启动模式，启动模式是standard。</p><pre><code class="hljs java">~ » adb shell dumpsys activity | grep SplashActivity                                                             jackie<span class="hljs-meta">@JackieLindeMacBook</span>-Pro    baseIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity &#125;    baseIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.sina.weibo/.SplashActivit &#125;    baseIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=cmccwm.mobilemusic/.ui.base.SplashActivity &#125;    baseIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.daimajia.gold/im.juejin.android.ui.SplashActivity &#125;      Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity bnds=[<span class="hljs-number">544</span>,<span class="hljs-number">149</span>][<span class="hljs-number">796</span>,<span class="hljs-number">458</span>] &#125;      mActivityComponent=com.ss.android.article.lite/.activity.SplashActivity    mIntent=Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity bnds=[<span class="hljs-number">544</span>,<span class="hljs-number">149</span>][<span class="hljs-number">796</span>,<span class="hljs-number">458</span>] &#125;     #0 ActivityRecord&#123;8e43505 u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125; type=standard mode=fullscreen override-mode=undefined  //启动模式是standard      intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity&#125;      mActivityComponent=com.ss.android.article.lite/.activity.SplashActivity      Activities=[ActivityRecord&#123;<span class="hljs-number">8e43505</span> u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;]        Hist #0: ActivityRecord&#123;8e43505 u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;          Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.ss.android.article.lite/.activity.SplashActivity bnds=[<span class="hljs-number">544</span>,<span class="hljs-number">149</span>][<span class="hljs-number">796</span>,<span class="hljs-number">458</span>] &#125;        Run #0: ActivityRecord&#123;8e43505 u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;    mResumedActivity: ActivityRecord&#123;<span class="hljs-number">8e43505</span> u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;      intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=com.sina.weibo/.SplashActivity&#125;      mActivityComponent=com.sina.weibo/.SplashActivity      intent=&#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=<span class="hljs-number">0x10200000</span> cmp=cmccwm.mobilemusic/.ui.base.SplashActivity&#125;      mActivityComponent=cmccwm.mobilemusic/.ui.base.SplashActivity ResumedActivity:ActivityRecord&#123;<span class="hljs-number">8e43505</span> u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;  ResumedActivity: ActivityRecord&#123;<span class="hljs-number">8e43505</span> u0 com.ss.android.article.lite/.activity.SplashActivity t6684&#125;复制代码</code></pre><p>再来看今日头条的首页的启动模式，它的首页叫MainActivity，用的也是standard。</p><pre><code class="hljs java">adb shell dumpsys activity | grep MainActivity                                                                                                          jackie<span class="hljs-meta">@JackieLindeMacBook</span>-      Intent &#123; flg=<span class="hljs-number">0x24008000</span> cmp=com.ss.android.article.news/.activity.MainActivity (has extras) &#125;      mActivityComponent=com.ss.android.article.news/.activity.MainActivity    mIntent=Intent &#123; flg=<span class="hljs-number">0x24008000</span> cmp=com.ss.android.article.news/.activity.MainActivity (has extras) &#125;     #0 ActivityRecord&#123;8fadec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125; type=standard mode=fullscreen override-mode=undefined  //standard启动模式     #0 ActivityRecord&#123;9130583 u0 cmccwm.mobilemusic/.ui.base.MainActivity t6681&#125; type=standard mode=fullscreen override-mode=undefined      Activities=[ActivityRecord&#123;<span class="hljs-number">8f</span>adec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;]        Hist #0: ActivityRecord&#123;8fadec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;          Intent &#123; flg=<span class="hljs-number">0x24008000</span> cmp=com.ss.android.article.news/.activity.MainActivity (has extras) &#125;        Run #0: ActivityRecord&#123;8fadec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;    mResumedActivity: ActivityRecord&#123;<span class="hljs-number">8f</span>adec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;      Activities=[ActivityRecord&#123;<span class="hljs-number">9130583</span> u0 cmccwm.mobilemusic/.ui.base.MainActivity t6681&#125;, ActivityRecord&#123;<span class="hljs-number">9822</span>b05 u0 cmccwm.mobilemusic/com.migu.music.ui.local.LocalSongsActivity t6681&#125;]        Hist #0: ActivityRecord&#123;9130583 u0 cmccwm.mobilemusic/.ui.base.MainActivity t6681&#125;          Intent &#123; flg=<span class="hljs-number">0x10000000</span> cmp=cmccwm.mobilemusic/.ui.base.MainActivity (has extras) &#125;        Run #0: ActivityRecord&#123;9130583 u0 cmccwm.mobilemusic/.ui.base.MainActivity t6681&#125; ResumedActivity:ActivityRecord&#123;<span class="hljs-number">8f</span>adec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;  ResumedActivity: ActivityRecord&#123;<span class="hljs-number">8f</span>adec6 u0 com.ss.android.article.news/.activity.MainActivity t6685&#125;复制代码</code></pre><p>我在今日头条和今日头条极速版的app中寻找从某个界面点击某个按钮返回到主页的场景，没有发现有这样的场景，或者说很少（可能是我没有发现），前面也说过使用standard标准模式只要是每次被启动都会创建一个新的实例，如果其他界面回到主页的场景多的话，我觉得可能会用singleTop（当要实现类似SingleTask的效果时可以配合flag实现）。场景极少或者没有是它使用standard的原因吧。</p><p>到此，我们对Activity的介绍和分析已经完毕了，喜欢的点个赞和关注吧。</p>]]></content>
    
    
    <categories>
      
      <category>Android面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android View 从测量布局到触摸反馈</title>
    <link href="/Blog/2020/11/19/Android-View-%E4%BB%8E%E6%B5%8B%E9%87%8F%E5%B8%83%E5%B1%80%E5%88%B0%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88/"/>
    <url>/Blog/2020/11/19/Android-View-%E4%BB%8E%E6%B5%8B%E9%87%8F%E5%B8%83%E5%B1%80%E5%88%B0%E8%A7%A6%E6%91%B8%E5%8F%8D%E9%A6%88/</url>
    
    <content type="html"><![CDATA[<p>#自定义View</p><blockquote><p>在Android开发中，自定义 View 最关键的有三个点：绘制、布局和触摸反馈(绘制内容多而简单，查看手册即用即学，这里不记录了)</p></blockquote><p>#布局</p><blockquote><ul><li>测量阶段 ：从上到下<code>递归</code>地调用每个 <code>View</code> 或者 <code>ViewGroup</code> 的 <code>measure() </code>方法，测量他们的尺寸并计算它们的位置</li><li>布局阶段：从上到下<code>递归</code>地调用a每个 <code>View</code> 或者 <code>ViewGroup</code> 的 <code>layout() </code>方法，把测得的它们的尺寸和位置赋值给它们<br>#####测量阶段</li></ul></blockquote><ul><li><code>measure()</code> 方法被父<code>View</code>调用，在 <code>measure() </code>中做一些准备和优化工作后，调用 <code>onMeasure() </code>来进行实际的自我测量</li></ul><blockquote><ul><li>View：<code>View</code> 在 <code>onMeasure()</code> 中会计算出自己的尺寸然后保存</li><li>ViewGroup：<code>ViewGroup</code> 在 <code>onMeasure() </code>中会调用所有<code>子 View </code>的 <code>measure() </code>让它们进行自我测量，并根据<code>子 View</code> 计算出的期望尺寸来计算出它们的实际尺寸和位置然后保存。同时，它也会根据<code>子 View </code>的<code>尺寸</code>和<code>位置</code>来计算出自己的尺寸然后保存<br>注：保存会调用<code>setMeasuredDimension(int,int)</code>，可通过<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>获取保存的值<br>#####布局阶段</li></ul></blockquote><ul><li><code>layout() </code>方法被父 <code>View</code> 调用，在<code>layout()</code> 中它会保存父 <code>View</code> 传进来的自己的位置和尺寸，并且调用 <code>onLayout()</code> 来进行实际的内部布局</li></ul><blockquote><ul><li>View：由于没有子 View，所以 <code>View</code> 的 <code>onLayout() </code>什么也不做</li><li>ViewGroup：<code>ViewGroup</code> 在 <code>onLayout() </code>中会调用自己的所有<code>子 View </code>的<code>layout()</code>方法，把它们的尺寸和位置传给它们（layout方法中会有参数，即实际让子View布局的尺寸参数），让它们完成自我的内部布局<br>下面给出示意图：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-5e90050757f139b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View布局过程.png"><br><img src="https://upload-images.jianshu.io/upload_images/17794320-30a25832259b0599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewGroup布局过程.png"></li></ul></blockquote><p>了解上面的测量布局过程之后，我们很容易地想到以下3种自定义布局过程<br>##自定义布局过程</p><ul><li>重写 <code>onMeasure()</code> 来修改已有的 <code>View</code> 的尺寸(先调用<code>super.onMeasure()</code>)</li><li>重写 <code>onMeasure()</code> 来全新定制自定义 <code>View</code> 的尺寸（不用<code>super.onMeasure()</code>）</li><li>重写 <code>onMeasure()</code> 和 <code>onLayout()</code> 来全新定制自定义 <code>ViewGroup</code> 的内部布局<br>######第一种（修改已有尺寸）<br>1.重写 <code>onMeasure() </code>方法，并在里面调用 super.onMeasure()，触发原有的自我测量<br>2.<code>super.onMeasure()</code>的下面用<code>getMeasuredWidth()</code>和 <code>getMeasuredHeight() </code>来获取到之前的测量结果(宽和高)，并加上自己的代码，根据测量结果计算出新的结果</li></ul><blockquote><p><code>getMeasuredWidth()</code> 和 <code>getMeasuredHeight()</code> 是测得的尺寸（即<code>View</code>在<code>onMeasure</code>中调用<code>setMeasureDimension()</code>保存下来的数据）未必与之后<code>父View</code>调用<code>layout()</code>时传递进来的的尺寸参数相等，具体值是由父View决定！</p></blockquote><p>3.使用<code>setMeasureDimension()</code>保存自定义测量的尺寸值</p><p>######第二种（完全自己计算尺寸）<br>1.重写<code>onMeasure()</code>，计算尺寸(自己计算图、文字等等的长宽作加法运算)<br>2.把计算结果用<code>resolveSize()</code>修正一下<br>3.使用<code>setMeasureDimension()</code>保存自定义测量的尺寸值（也可以自己实现方法来满足父View的限制）</p><blockquote><p>在<code>onMeasure()</code>中有两个参数<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>，它们是<code>父View</code>对<code>子View</code>的测量尺寸的限制，来源于<code>xml</code>中以<code>layout_</code>打头的属性参数,这两个属性各自可以被<code>MeasureSpec.getMode</code>和<code>MeasureSpec.getSize</code>拆分为<code>Mode</code>和<code>SIZE</code><br><code>Mode</code>是限制的类型，包含3种：无限制<code>UNSPECIFIED</code>、限制上限<code>AT_MOST</code>、限制固定值<code>EXACTLY</code><br><code>View</code>为我们提供了<code>resolveSize()</code>方法用来便捷地对应这种限制</p><p><img src="https://upload-images.jianshu.io/upload_images/17794320-7547d490758465b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/17794320-9ab7c57672402505.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>######第三种（ViewGroup自定义测量以及布局过程）<br>1.重写<code>onMeasure()</code>来计算内部布局</p><ul><li>调用每个子View的measure, 让<code>子View</code>自我测量</li><li>根据子View给出的尺寸，得到子View的位置，并保存它们的位置和尺寸</li><li>根据子View的位置和尺寸计算出自己的尺寸并用setMeasuredDimension()保存</li></ul></blockquote><p>2.重写<code>onLayout()</code>来摆放<code>子View</code></p><ul><li>在<code>onMeasure()</code>中，需要根据<code>ViewGroup</code>自身的 <strong>可用空间</strong> 结合<code>子View</code>的<code>layout_</code>打头的属性去测量每个<code>子View</code>的尺寸，并且用  <code>MeasureSpec.makeMeasureSpec()</code> 压缩成<code>MeasureSpec(子View的可用空间)</code>并保存</li><li><code>layout_</code>打头的属性：这类属性是<code>子View</code>提供给<code>父View</code>测量时用的，在Java代码中可以通过<code>view.getLayoutParam()</code>获得。全新自定义<code>ViewGroup</code>时只有 <code>layout_width</code>和<code>layout_height</code> ，开发者可以继续自定义这类属性例如<code>layout_gravity</code>，在自定义测量过程时将其考虑进去即可</li><li>可用空间：对于<code>ViewGroup</code>本身来说最初的可用空间是<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>的参数，而在往<code>子View</code>分配可用空间时，我们可以自己制定规则，可以将<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>直接作为第一个<code>子View</code>的 <strong>可用空间</strong>，也可以自己做一些删减。当第一个<code>子View</code>的测量完成,继续测量第二个<code>子View</code>的时候，需要在<code>widthMeasureSpec</code>或者<code>heightMeasureSpec</code>基础上将第一个<code>子View</code>的 <strong>已用空间</strong> 减去,就得到了第二个<code>子View</code>的可用空间，以此类推</li><li>可用空间判断方法(通用方式，有特例)：</li></ul><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-ea767e7316e78492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可用空间判断"><br>首先根据<code>子View</code>在的xml布局声明的<code>layout_width</code>和<code>layout_height</code>(lp.width、lp.height)分两种情况</p></blockquote><ul><li>MATCH_PARENT：<ul><li><code>ViewGroup</code>的限制为<code>EXACTLY</code>或<code>AT_MOST</code>：由于<code>子View</code>依赖<code>父View</code>，<code>父View</code>需要告诉<code>子View</code>其可用宽度，并且<code>ViewGroup</code>本身可用空间可以确定，所以应当给予<code>子View</code>的限制属性是一个具体值，mode为<code>EXACTLY</code>；此处给予 <code>子View</code> 的宽度是可用宽度，不管 父View 是 <code>AT_MOST</code> 还是<code>EXACTLY</code>，两种的原则都是这块空间<code>子View</code>随便用，so <code>子View</code>的可用空间就是当前ViewGroup的初始可用空间（<code>onMeasure()</code>传来的<code>widthMeasureSpec</code>）减去已用空间</li><li><code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>：<code>子View</code>依赖<code>父View</code>，但<code>ViewGroup</code>本身是<code>UNSPECIFIED</code>无限制大小的（这个地方说大小不是很合适，可用空间可能更佳），于是无法计算出<code>子View</code>的可用空间，所以直接将<code>子View</code>的<code>mode</code>也写为<code>UNSPECIFIED</code>,  不限制其可用空间大小。size直接给0，因为在<code>mode</code>为<code>UNSPECIFIED</code>情况下<code>size</code>无意义，实际在高版本Android有意义，这里不做解释</li></ul></li><li>WARP_CONTENT：<ul><li><code>ViewGroup</code>的限制为<code>EXACTLY</code>或<code>AT_MOST</code>：虽然<code>子View</code>是warp_content，子 View自我测量，但却不能直接将<code>UNSPECIFIED</code>给<code>子 View</code>，因为<code>wrap_content</code>有个隐藏条件是不超过<code>父View</code>，so这里给子View的<code>mode</code>是<code>AT_MOST</code>来限制它的最大尺寸；由于<code>ViewGroup</code>的<code>mode</code>为<code>EXACTLY</code>或<code>AT_MOST</code>，我们就可以得到可用空间大小，将其减去已用空间传给<code>子View</code>的可用空间即可(与match_parent时做法类似)</li><li><code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>：同上，<code>子View</code>需要自我测量，隐藏条件不超过<code>父View</code>应当被满足，但由于<code>ViewGroup</code>的限制为<code>UNSPECIFIED</code>，无法给出具体的可用空间大小，于是无法满足开发者在<code>xml</code>中给<code>子View</code>的<code>wrap_content</code>属性，无奈只能传入<code>UNSPECIFIED</code>不对其进行限制，<code>size</code>依旧是0即可</li></ul></li><li>指定值（sp、dp）：直接给<code>子View</code>指定一个值，<code>ViewGroup</code>什么都不用做，直接将值下发给<code>子View</code>的可用空间，<code>mode</code>给<code>EXACTLY</code>即可</li></ul><p>布局过程基本结束，接下来是触摸反馈过程</p><p>#触摸反馈</p><blockquote><p>触摸反馈的本质就是把一系列的<code>触摸事件</code>解读为对应的操作，比如按下、弹起、滑动等等，开发者再根据解读出来的操作进行<code>反馈</code></p></blockquote><p>对于触摸事件，有两点需要注意</p><ul><li><code>触摸事件</code> 不相互独立，它们是成 <code>序列</code> （成组）出现的</li><li>每组事件由 <code>DOWN</code> 开头，由 <code>UP</code> 或 <code>CANCEL</code> 结尾</li></ul><p>大家都知道，自定义触摸反馈只需要重写<code>View</code>的<code>onTouchEvent(MotionEvent event)</code>方法，event中包含了此次触摸事件的<code>事件类型</code>、<code>坐标</code>等其他信息，当触摸事件不断被触发，<code>onTouchEvent()</code>就不断被调用，这是触摸反馈的<code>核心</code>。对于简单的 <strong>自定义触摸反馈</strong>，重写这个方法已经够了，但难免我们会遇上新的问题 —— 滑动冲突，只有当我们了解整个事件分发机制，才能够彻底解决滑动冲突。<br>在Android中，当一个触摸事件产生，<code>MotionEvent</code> 将从 <code>Activity（Window）</code>——&gt;<code>ViewGroup</code>（多个）——&gt; <code>View</code><br> <img src="https://upload-images.jianshu.io/upload_images/17794320-31aa080f30078289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>实际上学习Android的触摸事件分发机制就是学习以下3个组件的事件分发机制</p><ul><li><code>Activity</code>对触摸事件的分发机制</li><li><code>ViewGroup</code>对触摸事件的分发机制</li><li><code>View</code>对触摸事件的分发机制</li></ul><p>在Android的事件分发机制中，传递的核心方法有3个：</p><ul><li><code>dispatchTouchEvent()</code>：分发（传递）点击事件，当点击事件能够传递给当前View，该方法就会被调用</li><li><code>onInterceptTouchEvent()</code>：只存在于<code>ViewGroup</code>中，在<code>dispatchTouchEvent()</code>内部被调用，判断是否拦截了某个事件</li><li><code>onTouchEvent()</code>：处理点击事件，在<code>dispatchTouchEvent()</code>内部调用</li></ul><blockquote><p>这三个方法的解释不严谨，目的只是让大家现在有一个关系概念，而不是将每个细节都全理解，之后在源码中会有细节</p></blockquote><p>先上一个粗略的图，大概对事件分发流程有个印象，方便看源码的时候理解</p><p>##Activity的事件分发机制<br>当一个触摸事件发生时，事件最先传到 <code>Activity</code> 的 <code>dispatchTouchEvent()</code></p><pre><code class="hljs csharp">    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent ev</span>)</span> &#123;        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN)             onUserInteraction();        &#125;    <span class="hljs-comment">//获取Activity的window对象（实现类PhoneWindow）并调用其方法 `superDispatchTouchEvent()`</span>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    <span class="hljs-comment">//当未被处理，直接调用Activity的 `onTouchEvent()` 处理</span>        <span class="hljs-keyword">return</span> onTouchEvent(ev);    &#125;        <span class="hljs-comment">//空方法，当Activity在栈顶，触摸、按Home、back、menu都会触发该方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserInteraction</span>(<span class="hljs-params"></span>)</span> &#123;    &#125;        <span class="hljs-comment">//Window</span>    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>) </span><span class="hljs-function">        <span class="hljs-comment">// mDecor = 顶层View（DecorView）的实例对象</span></span><span class="hljs-function">        <span class="hljs-comment">//DecorView是PhoneWindow的内部类，继承自FrameLayout，所以是一个ViewGroup</span></span><span class="hljs-function">        <span class="hljs-keyword">return</span> mDecor.<span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params"><span class="hljs-keyword">event</span></span>)</span>;    &#125;        <span class="hljs-comment">//DecorView</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">superDispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;        <span class="hljs-comment">// 调用父类的方法 = ViewGroup的dispatchTouchEvent()</span>        <span class="hljs-comment">// 即 将事件传递到ViewGroup去处理，详细看ViewGroup的事件分发机制</span>        <span class="hljs-keyword">return</span> super.dispatchTouchEvent(<span class="hljs-keyword">event</span>);    &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;        <span class="hljs-comment">// 当一个点击事件未被Activity下任何一个View接收 / 处理时</span>        <span class="hljs-comment">// 应用场景：处理发生在Window边界外的触摸事</span>        <span class="hljs-keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;            finish();            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//即只有在点击事件在Window边界外才会返回true，一般情况都返回false</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">shouldCloseOnTouch</span>(<span class="hljs-params">Context context, MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;    <span class="hljs-comment">// 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等</span>    <span class="hljs-keyword">if</span> (mCloseOnTouchOutside &amp;&amp; <span class="hljs-keyword">event</span>.getAction() == MotionEvent.ACTION_DOWN            &amp;&amp; isOutOfBounds(context, <span class="hljs-keyword">event</span>) &amp;&amp; peekDecorView() != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 返回true：说明事件在边界外，即 消费事件</span>    <span class="hljs-comment">// 返回false：未消费（默认）</span>&#125;</code></pre><blockquote><p>流程图 <img src="https://upload-images.jianshu.io/upload_images/17794320-73a1692c3d8e588a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity事件分发流程图"><br>红框中是重点！事件从这里下发到子View/View Group！<br>#ViewGroup事件的分发机制<br>Android 5.0后，ViewGroup.dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同；<br>为了便于理解，采用Android 5.0前的版本</p></blockquote><pre><code class="hljs aspectj">    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;     ... <span class="hljs-comment">// 仅贴出关键代码</span>        <span class="hljs-comment">// ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件</span>            <span class="hljs-keyword">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;              <span class="hljs-comment">// 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent（）修改</span>            <span class="hljs-comment">// 判断值2： !onInterceptTouchEvent(ev) = 对onInterceptTouchEvent()返回值取反</span>                    <span class="hljs-comment">// a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部</span>                    <span class="hljs-comment">// b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断</span>                    <span class="hljs-comment">// c. 关于onInterceptTouchEvent() -&gt;&gt;分析1</span>                ev.setAction(MotionEvent.ACTION_DOWN);                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrolledXInt = (<span class="hljs-keyword">int</span>) scrolledXFloat;                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrolledYInt = (<span class="hljs-keyword">int</span>) scrolledYFloat;                  <span class="hljs-keyword">final</span> View[] children = mChildren;                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mChildrenCount;              <span class="hljs-comment">// 通过for循环，遍历了当前ViewGroup下的所有子View</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                  <span class="hljs-keyword">final</span> View child = children[i];                  <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE                          || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//可见或正在执行动画 </span>                    child.getHitRect(frame);                      <span class="hljs-comment">// 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View</span>                    <span class="hljs-comment">// 若是，则进入条件判断内部</span>                    <span class="hljs-keyword">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> xc = scrolledXFloat - child.mLeft;                          <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> yc = scrolledYFloat - child.mTop;                          ev.setLocation(xc, yc);                          child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;                          <span class="hljs-comment">// 条件判断的内部调用了该View的dispatchTouchEvent()</span>                        <span class="hljs-comment">// 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制）</span>                        <span class="hljs-keyword">if</span> (child.dispatchTouchEvent(ev))  &#123;                         mMotionTarget = child;                          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                         <span class="hljs-comment">// 调用子View的dispatchTouchEvent后是有返回值的</span>                        <span class="hljs-comment">// 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立</span>                        <span class="hljs-comment">// 于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出</span>                        <span class="hljs-comment">// 即把ViewGroup的点击事件拦截掉</span>                                &#125;                              &#125;                          &#125;                      &#125;                  &#125;              &#125;              <span class="hljs-keyword">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||                      (action == MotionEvent.ACTION_CANCEL);              <span class="hljs-keyword">if</span> (isUpOrCancel) &#123;          <span class="hljs-comment">//如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false   </span>        <span class="hljs-comment">//假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true   </span>        <span class="hljs-comment">//当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false   </span>        <span class="hljs-comment">//所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false   </span>                mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;              &#125;              <span class="hljs-keyword">final</span> View <span class="hljs-keyword">target</span> = mMotionTarget;          <span class="hljs-comment">// 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true）</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == <span class="hljs-keyword">null</span>) &#123;              ev.setLocation(xf, yf);              <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != <span class="hljs-number">0</span>) &#123;                  ev.setAction(MotionEvent.ACTION_CANCEL);                  mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;              &#125;                          <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;            <span class="hljs-comment">// 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent()</span>            <span class="hljs-comment">// 因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（））</span>            <span class="hljs-comment">// 此处需与上面区别：子View的dispatchTouchEvent（）</span>        &#125;         ... &#125;  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;        <span class="hljs-comment">//返回true = 拦截，即事件停止往下传递（需手动设置，即复写onInterceptTouchEvent（），从而让其返回true）</span>      <span class="hljs-comment">//返回false = 不拦截（默认）</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;</code></pre><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-5e5ab9fbb8dbfc6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote><p>到这里为止，你会发现没有任何一个地方消费了（使用了）触摸事件，因为目前为止所有的过程都只是在下发（往下传递MotionEvent），而真正要处理事件，是等到View（真的View，不是ViewGroup）在 <code>dispatchTouchEvent()</code> 中去做操作，在这里才会 <strong>真正</strong> 让 <code>dispatchTouchEvent()</code>与 <code>onTouchEvent()</code> 产生交集，接着往下看<br>#View事件的分发机制</p><pre><code class="hljs csharp">  <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">dispatchTouchEvent</span>(<span class="hljs-params">MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;    <span class="hljs-comment">// 只有以下3个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent()</span>  <span class="hljs-comment">//     1. mOnTouchListener != null</span>  <span class="hljs-comment">//     2. (mViewFlags &amp; ENABLED_MASK) == ENABLED</span>  <span class="hljs-comment">//     3. mOnTouchListener.onTouch(this, event)</span>        <span class="hljs-keyword">if</span> (mOnTouchListener != <span class="hljs-literal">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;                  mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>)) &#123;    <span class="hljs-comment">// 假如onTouch返回了true，直接返回True</span>onTouchEvent()处理            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          &#125;   <span class="hljs-comment">// 假如onTouch没返回true，交给此View的</span>        <span class="hljs-keyword">return</span> onTouchEvent(<span class="hljs-keyword">event</span>);    &#125;  <span class="hljs-comment">// 在这里为mOnTouchListener赋值</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOnTouchListener</span>(<span class="hljs-params">OnTouchListener l</span>)</span> &#123;     <span class="hljs-comment">// 即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空）</span>    mOnTouchListener = l;  &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 回调控件注册Touch事件时的onTouch（）；需手动复写设置，具体如下（以按钮Button为例）</span><span class="hljs-comment">  */</span>    button.setOnTouchListener(<span class="hljs-keyword">new</span> OnTouchListener() &#123;          @Override          <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">onTouch</span>(<span class="hljs-params">View v, MotionEvent <span class="hljs-keyword">event</span></span>)</span> &#123;                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;          &#125;      &#125;);</code></pre><blockquote><p><img src="https://upload-images.jianshu.io/upload_images/17794320-6e3cbb62240c4242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android环境下 MQTT+Protocol Buffers实现消息推送</title>
    <link href="/Blog/2020/11/19/Android%E7%8E%AF%E5%A2%83%E4%B8%8B-MQTT-Protocol-Buffers%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    <url>/Blog/2020/11/19/Android%E7%8E%AF%E5%A2%83%E4%B8%8B-MQTT-Protocol-Buffers%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Android环境下-MQTT-Protocol-Buffers实现消息推送"><a href="#Android环境下-MQTT-Protocol-Buffers实现消息推送" class="headerlink" title="Android环境下 MQTT+Protocol Buffers实现消息推送"></a>Android环境下 MQTT+Protocol Buffers实现消息推送</h1><pre><code>曾记否，大学初识Android时，做出一款聊天软件曾是多少少年的梦想。。。（好吧可能只是我的)emm… 怎么写？长连接，那就直接怼socket吧！于是闷起脑壳就开始写。服务端+客户端，一通操作猛如虎，并伴随着各种线程异常之后终于是肝出来一个聊天室，，，好像还阔以，但是随着少年长大，你渐渐明白服务的重要性，这样的连接你可能保持不了几个，想实现消息推送,MQTT了解一下？</code></pre><h2 id="MQTT-消息队列遥测传输"><a href="#MQTT-消息队列遥测传输" class="headerlink" title="MQTT(消息队列遥测传输)"></a>MQTT(<strong>消息队列遥测传输</strong>)</h2><blockquote><p>一个基于客户端-服务器的消息发布/订阅传输协议。优点：<code>轻量</code>、<code>简单</code>、<code>开放</code>、<code>易于实现</code>;由于其<code>低开销</code>、<code>低带宽占用</code>，所以在物联网、小型设备、移动应用等方面有广泛的应用<br>MQTT协议有三种身份： <code>发布者</code>、<code>代理</code>、<code>订阅者</code>，发布者和订阅者都为客户端，代理为服务器，同时消息的发布者也可以是订阅者<br>MQTT传输的消息分为主题（Topic，可理解为消息的类型，订阅者订阅后，就会收到该主题的消息内容<code>payload</code>。<br>运行流程:<img src="https://upload-images.jianshu.io/upload_images/17794320-daee414b823bba2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote><p>特点如下</p><blockquote><p>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序之间的耦合。</p><p>对负载内容屏蔽的消息传输。</p><p>使用 TCP/IP 提供基础网络连接。</p><p>小型传输，开销很小(固定长度的是头部是2个字节)，协议交换最小化，以降低网络流量<br>整体上协议可拆分为：固定头部+可变头部+消息体</p><p>提供一种机制，使得客户端异常中断时，能够使用LastWill和Testament特性通知有关各方<br>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。<br>Testament：遗嘱机制，功能类似于Last Will。</p><p>有三种级别消息发布服务质量：<br>qos为0：“至多一次”，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复，不久会发送第二次。<br>qos为1：“至少一次”，确保消息到达，但消息重复可能会发生。<br>qos为2：“只有一次”，确保消息到达一次。</p></blockquote><pre><code>有了`MQTT`代替`Socket`作为传输协议，但是数据结构呢？你也许会说`json`，但在通讯极其频繁的IM或者推送泛滥的场景中，`Protocol Buffers`更加适用（当然各有各的优缺点，比如`json`易读，`Protocol Buffers`**小**、**快**），当然使用它我们得有后端同学支持</code></pre><blockquote><p>有了协议，我们还需要一个服务来为我们提供消息的订阅发送，我使用的是<code>EMQ</code>，需要后端同学将自己的服务与<code>EMQ</code>服务接入进行通讯</p></blockquote><p>##EMQ</p><blockquote><p>EMQ X Broker 是基于高并发的 Erlang/OTP 语言平台开发，支持百万级连接和分布式集群架构，发布订阅模式的开源 MQTT 消息服务器。<br>EMQ X Broker 在全球物联网市场广泛应用。无论是产品原型设计、物联网创业公司、还是大规模的商业部署，EMQ X Broker 都支持开源免费使用。<br>详情：<a href="https://www.emqx.io/cn/">https://www.emqx.io/cn/</a></p></blockquote><p>##Protocol Buffer</p><blockquote><p><code>Protocol Buffers</code> 是<strong>Google</strong>推出的用于序列化结构化数据的灵活、高效、自动化的机制。它与 <code>XML</code>、<code>JSON</code>一样都是<code>结构数据序列化</code>的工具，但<code>ProtoBuffer</code>更小，更快，更简单。开发者需要定义一次构造数据的方式，然后就可以使用特定代码轻松地在各种语言的各种数据流中写入和读取数据。同样，使用它必须有后端同学的支持<br>详情：<a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a></p></blockquote><p>优点</p><ul><li>性能较xml,json, thirft等好，效率高<br>代码生成机制，数据解析类自动生成</li><li>支持向后兼容和向前兼容</li><li>支持多种编程语言（java，c++，python）</li></ul><p>缺点</p><ul><li><p>二进制格式导致可读性差</p></li><li><p>缺乏自描述</p><p>先上个 <code>Protocol Buffers</code> 与 <code>json</code> 的对比图</p></li></ul><pre><code class="hljs angelscript"><span class="hljs-comment">//json：</span>&#123;    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Fenrir&quot;</span>,    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age1&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age2&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age3&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age4&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age5&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age6&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age7&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age8&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age9&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age10&quot;</span>:<span class="hljs-number">6</span>    <span class="hljs-string">&quot;age11&quot;</span>:<span class="hljs-number">6</span>&#125;<span class="hljs-comment">//Protocol Buffers:</span><span class="hljs-number">10</span> <span class="hljs-number">6</span> <span class="hljs-number">70</span> <span class="hljs-number">101</span> <span class="hljs-number">110</span> <span class="hljs-number">114</span> <span class="hljs-number">105</span> <span class="hljs-number">114</span> <span class="hljs-number">16</span> <span class="hljs-number">34</span> <span class="hljs-number">24</span> <span class="hljs-number">46</span> <span class="hljs-number">32</span> <span class="hljs-number">56</span> <span class="hljs-number">40</span> <span class="hljs-number">16</span> <span class="hljs-number">48</span> <span class="hljs-number">56</span> <span class="hljs-number">56</span> <span class="hljs-number">86</span> <span class="hljs-number">64</span> <span class="hljs-number">66</span> <span class="hljs-number">72</span> <span class="hljs-number">56</span> <span class="hljs-number">80</span> <span class="hljs-number">86</span> <span class="hljs-number">88</span> <span class="hljs-number">54</span> <span class="hljs-number">96</span> <span class="hljs-number">66</span> <span class="hljs-number">104</span> <span class="hljs-number">66</span><span class="hljs-comment">//或者将其Base64，变得下面这样</span>CgZGZW5yaXIQIhguIDgoEDA4OFZAQkg4UFZYNmBCaEI=</code></pre><p>QA：？？？</p><pre><code>`Protocol Buffers`将数据从对象转换成了一个`byte数组`。诚然，由于其可读性差，测试工作会变得困难;    但是使用`Protocol Buffers`不仅能降低数据传输代价，并且无论是在客户端还是服务端，对于数据的`序列化`与`反序列化`速度都将得到不小的提升；所以这并不应该成为使用它的障碍，在真正实装起来时就需要我们给QA们写一个序列化与反序列化的工具。</code></pre><p>##在Android使用Protocol Buffers<br>project gradle中</p><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;    <span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.google.protobuf:protobuf-gradle-plugin:0.8.8&#x27;</span>&#125;</code></pre><p>app gradle中</p><pre><code class="hljs properties"><span class="hljs-attr">apply</span> <span class="hljs-string">plugin: &#x27;com.google.protobuf&#x27; //应用proto插件</span>    <span class="hljs-attr">protobuf</span> <span class="hljs-string">&#123;</span>        <span class="hljs-attr">protoc</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">artifact</span> = <span class="hljs-string">&#x27;com.google.protobuf:protoc:3.0.0&#x27;</span>        <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">plugins</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">javalite</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">artifact</span> = <span class="hljs-string">&#x27;com.google.protobuf:protoc-gen-javalite:3.0.0&#x27;</span>            <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">generateProtoTasks</span> <span class="hljs-string">&#123;</span>            <span class="hljs-meta">all().each</span> <span class="hljs-string">&#123; task -&gt;</span>                <span class="hljs-meta">task.builtins</span> <span class="hljs-string">&#123;</span>                    <span class="hljs-attr">remove</span> <span class="hljs-string">java</span>                <span class="hljs-attr">&#125;</span>                <span class="hljs-meta">task.builtins</span> <span class="hljs-string">&#123;</span>                    <span class="hljs-attr">java</span> <span class="hljs-string">&#123;&#125;</span>                    <span class="hljs-attr">cpp</span> <span class="hljs-string">&#123;&#125;</span>                <span class="hljs-attr">&#125;</span>            <span class="hljs-attr">&#125;</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">sourceSets</span> <span class="hljs-string">&#123;</span>        <span class="hljs-attr">main</span> <span class="hljs-string">&#123;</span>            <span class="hljs-attr">java</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">srcDir</span> <span class="hljs-string">&#x27;src/main/java&#x27;</span>            <span class="hljs-attr">&#125;</span>            <span class="hljs-attr">proto</span> <span class="hljs-string">&#123;</span>                <span class="hljs-attr">srcDir</span> <span class="hljs-string">&#x27;src/main/proto&#x27; //配置proto文件路径</span>            <span class="hljs-attr">&#125;</span>            <span class="hljs-meta">jniLibs.srcDir</span> <span class="hljs-string">&#x27;libs&#x27;</span>            <span class="hljs-meta">jni.srcDirs</span> = <span class="hljs-string">[]    //disable automatic ndk-build</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;</span><span class="hljs-attr">dependencies</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attr">api</span> <span class="hljs-string">&#x27;com.google.protobuf:protobuf-java:3.6.1&#x27;</span>    <span class="hljs-attr">api</span> <span class="hljs-string">&#x27;com.google.protobuf:protoc:3.10.1&#x27;</span>    <span class="hljs-attr">implementation</span> <span class="hljs-string">&#x27;com.squareup.retrofit2:converter-protobuf:2.2.0&#x27;</span><span class="hljs-attr">&#125;</span></code></pre><blockquote><p>这里以构建一个无限发送心跳包的程序为例，这里实现心跳包的目的如下</p></blockquote><ul><li>为服务端提供信息用于判断用户是否下线</li><li>确保与服务端建立的topic的唯一性</li><li>顺便增加一下Android服务的优先级</li></ul><p>使用ProtocolBuffers前需要先编辑<code>.proto</code>文件，语法过多就不写在这里了，请移步至<a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a><br>在src/main下创建文件夹proto并在其目录下创建文件 MqttHeartBeatMessage.proto</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">//protoBuf版本</span><span class="hljs-keyword">package</span> rubbishcommunity; <span class="hljs-comment">//包</span><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.example.xxxxxxx&quot;</span>; <span class="hljs-comment">//包名</span><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;MqttHeartBeatMessageOutClass&quot;</span>; <span class="hljs-comment">//生成的Java Class文件类名</span><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MqttHeartBeatMessage</span></span>&#123;    <span class="hljs-built_in">int64</span> uin = <span class="hljs-number">1</span>;    <span class="hljs-built_in">string</span> linkKey = <span class="hljs-number">2</span>;    <span class="hljs-built_in">int64</span> timestamp = <span class="hljs-number">3</span>;&#125;</code></pre><p><code>.proto</code>文件编辑完成之后 Rebuild 编译一下项目,可以发现在java(generated)下面已经生成了proto编译成的java文件<code>MqttHeartBeatMessageOutClass.java</code>，里面包含了<code>MqttHeartBeatMessage.java</code>并实现了<code>get</code>、<code>set</code>方法；</p><ul><li>到此，Proto部分算是完成了，接下来我们需要使用<code>MQTTService</code>实现无限发送心跳包,但在这之前，你要先了解下面两位</li></ul><p>##Eclipse Paho</p><blockquote><p>Eclipse提供的一个访问MQTT服务器的一种开源客户端库<br><a href="https://www.eclipse.org/paho/clients/android/">https://www.eclipse.org/paho/clients/android/</a></p></blockquote><p>##MqttAndroidClient</p><blockquote><p>简单的说就是对MQTTService的连接、通讯等方法的封装类<br>[<a href="https://www.eclipse.org/paho/files/android-javadoc/org/eclipse/paho/android/service/MqttAndroidClient.html]">https://www.eclipse.org/paho/files/android-javadoc/org/eclipse/paho/android/service/MqttAndroidClient.html]</a></p></blockquote><ul><li>引入MQTT的Service以及对Android相关资源</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">implementation</span> &#x27;org.eclipse.paho:org.eclipse.paho.client.mqttv<span class="hljs-number">3</span>:<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>&#x27;<span class="hljs-attribute">implementation</span> &#x27;org.eclipse.paho:org.eclipse.paho.android.service:<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span>&#x27;</code></pre><ul><li>Manifests中注册<code>MqttService</code>的Service</li></ul><pre><code class="hljs routeros">&lt;service android:<span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;org.eclipse.paho.android.service.MqttService&quot;</span>/&gt;</code></pre><ul><li>在项目中使用<code>MqttAndroidClient</code>进行MQTT连接与通讯<br>理论上应该将<code>MqttAndroidClient</code>的生命周期与<code>Application</code>绑定在一起，在我的毕设项目中我是再写了一个<code>Service</code>，在我的<code>MainActivity</code>打开之后开启，并在Service中轮询发送心跳包；</li></ul><p>初始化代码：</p><pre><code class="hljs kotlin"><span class="hljs-comment">//新建Client,以设备ID作为client ID</span>mqttAndroidClient = MqttAndroidClient(context,MQTT_URL, <span class="hljs-comment">//MQTT服务地址</span>CLIRNT_ID <span class="hljs-comment">//MQTT连接在代理服务处的clientId，一般由后端同学定义</span>)mqttAndroidClient?.setCallback(<span class="hljs-keyword">object</span> : MqttCallbackExtended &#123;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectComplete</span><span class="hljs-params">(reconnect: <span class="hljs-type">Boolean</span>, serverURI: <span class="hljs-type">String</span>)</span></span> &#123;<span class="hljs-comment">//连接成功</span><span class="hljs-keyword">if</span> (reconnect) &#123;<span class="hljs-comment">// 由于clean Session ，我们需要重新订阅</span><span class="hljs-keyword">try</span> &#123;subscribeToTopic()&#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;    ex.printStackTrace()&#125;&#125;&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">connectionLost</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>)</span></span> &#123;<span class="hljs-comment">//连接断开</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">messageArrived</span><span class="hljs-params">(topic: <span class="hljs-type">String</span>, message: <span class="hljs-type">MqttMessage</span>)</span></span> &#123;              <span class="hljs-comment">//接收到订阅的消息</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">deliveryComplete</span><span class="hljs-params">(token: <span class="hljs-type">IMqttDeliveryToken</span>)</span></span> &#123;<span class="hljs-comment">//服务器成功delivery消息</span>&#125;&#125;)<span class="hljs-comment">//新建连接设置</span><span class="hljs-keyword">val</span> mqttConnectOptions = MqttConnectOptions()<span class="hljs-comment">//断开后，是否自动连接</span>mqttConnectOptions.isAutomaticReconnect = <span class="hljs-literal">true</span><span class="hljs-comment">//是否清空客户端的连接记录。若为true，则断开后，broker将自动清除该客户端连接信息</span>mqttConnectOptions.isCleanSession = <span class="hljs-literal">true</span><span class="hljs-comment">//设置Mq连接的userName</span>mqttConnectOptions.userName = getLocalEmail()<span class="hljs-comment">//设置超时时间，单位为秒</span><span class="hljs-comment">//mqttConnectOptions.setConnectionTimeout(2);</span><span class="hljs-comment">//心跳时间，单位为秒。即多长时间确认一次Client端是否在线（此心跳时间非刚才说的心跳时间，这个是MqttService内部的心跳）</span>mqttConnectOptions.keepAliveInterval = <span class="hljs-number">2</span><span class="hljs-comment">//允许同时发送几条消息（未收到broker确认信息）</span>mqttConnectOptions.maxInflight = <span class="hljs-number">2</span><span class="hljs-comment">//选择MQTT版本</span>mqttConnectOptions.mqttVersion = MqttConnectOptions.MQTT_VERSION_3_1_1<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//开始连接</span>mqttAndroidClient?.connect(mqttConnectOptions, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">object</span> : IMqttActionListener &#123;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(asyncActionToken: <span class="hljs-type">IMqttToken</span>)</span></span> &#123;<span class="hljs-keyword">val</span> disconnectedBufferOptions = DisconnectedBufferOptions()disconnectedBufferOptions.isBufferEnabled = <span class="hljs-literal">true</span>disconnectedBufferOptions.bufferSize = <span class="hljs-number">100</span>disconnectedBufferOptions.isPersistBuffer = <span class="hljs-literal">false</span>disconnectedBufferOptions.isDeleteOldestMessages = <span class="hljs-literal">true</span>mqttAndroidClient!!.setBufferOpts(disconnectedBufferOptions)subscribeToTopic()<span class="hljs-comment">//成功连接以后开始订阅</span>&#125;<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(asyncActionToken: <span class="hljs-type">IMqttToken</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;<span class="hljs-comment">//连接失败</span>exception.printStackTrace()&#125;&#125;)&#125; <span class="hljs-keyword">catch</span> (ex: MqttException) &#123;ex.printStackTrace()&#125;</code></pre><p>轮询发送心跳包</p><pre><code class="hljs awk">Observable.interval(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS).doOnNext &#123;mqService <span class="hljs-regexp">//</span>这是我的服务，没有的话直接使用MqAndroidClient就好.publishMessage(Base64.encodeToString(<span class="hljs-regexp">//</span>下面就是构造proto生成的Class的对象了MqttHeartBeatMessageOutClass.MqttHeartBeatMessage.newBuilder().setLinkKey(getLinkKey()) <span class="hljs-regexp">//</span>proto中自定义的属性.setUin(getLocalUin()) <span class="hljs-regexp">//</span>proto中自定义的属性.setTimestamp(System.currentTimeMillis()) <span class="hljs-regexp">//</span>proto中自定义的属性.build() <span class="hljs-regexp">//</span>构造结束                              .toByteArray(),NO_WRAP),DEW_MQTT_HEART_BEAT_TOPIC <span class="hljs-regexp">//</span>心跳包的TOPIC)&#125;.subscribe()</code></pre><p>至此，心跳包发送已经完成了，接下来说说接收<code>Protocol Buffer</code>数据</p><p>在上面代码中应该看见了，在<code>MqttAndroidClient</code>接收的数据在<code>messageArrived(topic: String, message: MqttMessage)</code>方法中，实际上这里并非所有的消息都会是<code>protocol Buffers</code>消息，所以这里我们可以想办法区分，这里就不累述了。要说的是<code>Protocol Buffer</code>的消息在内部也是需要区分的，比如有两种消息过来1⃣️我的朋友圈有人点赞我需要知道是谁点赞2⃣️有人给我发消息我需要知道是什么消息，而这两种消息内部返回的数据结构可能就完全不一样，所以需要用到<code>Protocol Buffers</code>的enum进行区分，那么我们与后端同学一起定义一种<code>协议</code>,也就是接收的<code>ProtocolBuffers</code>消息的数据结构，像下面这样：</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<span class="hljs-keyword">package</span> rubbishcommunity;<span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.example.rubbishcommunity&quot;</span>;<span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;NotifyMessageOutClass&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NotifyType</span></span>&#123;    ERROR_DEFAULT_TYPE = <span class="hljs-number">0</span>; <span class="hljs-comment">//默认</span>    SYNC_NEW_MESSAGE = <span class="hljs-number">1</span>; <span class="hljs-comment">//新消息</span>    SYNC_MOMENTS_COMMENT = <span class="hljs-number">2</span>; <span class="hljs-comment">//有人点赞</span>&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">NotifyMessage</span></span>&#123;    Header header = <span class="hljs-number">1</span>; <span class="hljs-comment">//数据头</span>    <span class="hljs-built_in">string</span> payload = <span class="hljs-number">2</span>; <span class="hljs-comment">//真实数据（虽然是String，实际是后端将Protocol Buffers数据Base64之后的String）</span>&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Header</span></span>&#123;    NotifyType notifyType = <span class="hljs-number">1</span>; <span class="hljs-comment">//消息类型</span>    <span class="hljs-built_in">int64</span> timestamp = <span class="hljs-number">2</span>; <span class="hljs-comment">//时间戳</span>    <span class="hljs-built_in">string</span> notifyUUID = <span class="hljs-number">3</span>; <span class="hljs-comment">//消息UUID</span>&#125;</code></pre><p>之后我们就可以愉快地解析数据啦！举个栗子</p><p>MqttAndroidClient初始化的地方：</p><pre><code class="hljs reasonml">             <span class="hljs-comment">//订阅的消息送达</span>override <span class="hljs-keyword">fun</span> message<span class="hljs-constructor">Arrived(<span class="hljs-params">topic</span>: String, <span class="hljs-params">message</span>: MqttMessage)</span> &#123;<span class="hljs-comment">//先用Base64解码</span><span class="hljs-keyword">val</span> resBytes = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Base64</span>.</span></span>decode(message.payload, Base64.NO_WRAP)<span class="hljs-comment">//得到最外层的NotifyMessage对象</span><span class="hljs-keyword">val</span> notifyMessage = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NotifyMessageOutClass</span>.</span><span class="hljs-module"><span class="hljs-identifier">NotifyMessage</span>.</span></span>parse<span class="hljs-constructor">From(<span class="hljs-params">resBytes</span>)</span><span class="hljs-comment">//发送MQ事件，目前在BasegFragment中有处理事件的方法</span>send<span class="hljs-constructor">MQData(MQNotifyData(<span class="hljs-params">notifyMessage</span>.<span class="hljs-params">header</span>.<span class="hljs-params">notifyType</span>,<span class="hljs-params">notifyMessage</span>.<span class="hljs-params">payload</span>)</span>)&#125;</code></pre><p>BaseFragment中：</p><pre><code class="hljs reasonml"><span class="hljs-comment">//实际&#x27;MQ消息&#x27;处理者</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handle<span class="hljs-constructor">MQNotifyMessage()</span> &#123;notifyDisposable = get<span class="hljs-constructor">MQNotifyObs()</span>.observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>).doOnNext &#123;on<span class="hljs-constructor">MQMessageArrived(<span class="hljs-params">it</span>)</span>&#125;.subscribe(&#123;&#125;, &#123; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Timber</span>.</span></span>e(it) &#125;)&#125;</code></pre><p>实现的Fragment中：</p><pre><code class="hljs kotlin"><span class="hljs-comment">//有MQ消息</span><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMQMessageArrived</span><span class="hljs-params">(mqNotifyData: <span class="hljs-type">MQNotifyData</span>)</span></span> &#123;<span class="hljs-keyword">when</span> (mqNotifyData.mqNotifyType) &#123;NotifyMessageOutClass.NotifyType.SYNC_MOMENTS_FAVORITE -&gt; &#123; <span class="hljs-comment">//有人点赞</span><span class="hljs-comment">//弹个通知并更新列表对应Item</span>&#125;<span class="hljs-keyword">else</span> -&gt; &#123;&#125;&#125;&#125;</code></pre><p>将得到的数据包装成自定义的一个<code>MQNotifyData</code>数据类，数据类中有<code>header</code>和<code>payload</code>，再通过<code>sendMQData()</code>发送到<code>Fragment</code>或者<code>Activity</code>中去，我是在<code>Fragment</code>中一直有一个mq消息的<code>Subject</code>流，当<code>sendMQData()</code>就触发<code>onNext()</code>，其中调用<code>BaseFragment</code>的方法，具体实现在具体需要MQ消息的<code>Fragment</code>中。这是我的方法而已，就是将数据通知到界面，如何实现随意，欢迎大佬来指正～</p><p>MQ中的<code>ProtocolBuffers</code>完成了，还有最后一步就是为我们的正常Http请求的数据也添加支持，啊好像写不完了，各位看官～下次补上吧～！！</p>]]></content>
    
    
    <categories>
      
      <category>网络通讯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中间凹陷的BottomNavigationView（仿百度地图）</title>
    <link href="/Blog/2020/11/19/%E4%B8%AD%E9%97%B4%E5%87%B9%E9%99%B7%E7%9A%84BottomNavigationView%EF%BC%88%E4%BB%BF%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%EF%BC%89/"/>
    <url>/Blog/2020/11/19/%E4%B8%AD%E9%97%B4%E5%87%B9%E9%99%B7%E7%9A%84BottomNavigationView%EF%BC%88%E4%BB%BF%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>##GapBottomNavigtionView</p><p>百度的：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-2ab547998387f2ee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="71529789c6c948803e1075c2c7e00809.jpg"><br>我的：<br><img src="https://upload-images.jianshu.io/upload_images/17794320-faea132de3d4305f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e9347423eb2031228af77ad63d7b01d7.jpg"></p><blockquote><p>项目地址：<a href="https://github.com/ZYF99/UIKit/tree/1.3">https://github.com/ZYF99/UIKit/tree/1.3</a></p></blockquote><p>###使用方式</p><p>在app的build.gradle中</p><pre><code class="hljs gradle"><span class="hljs-keyword">allprojects</span> &#123;<span class="hljs-keyword">repositories</span> &#123;...maven &#123; url <span class="hljs-string">&#x27;https://jitpack.io&#x27;</span> &#125;&#125;&#125;<span class="hljs-keyword">dependencies</span> &#123;        implementation <span class="hljs-string">&#x27;com.github.ZYF99:UIKit:1.3&#x27;</span>&#125;</code></pre><p>在布局文件中直接使用</p><pre><code class="hljs routeros">&lt;com.google.android.material.floatingactionbutton.FloatingActionButton    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/fab_add&quot;</span>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;30dp&quot;</span>    android:<span class="hljs-attribute">backgroundTint</span>=<span class="hljs-string">&quot;#ffffff&quot;</span>    android:<span class="hljs-attribute">elevation</span>=<span class="hljs-string">&quot;6dp&quot;</span>    android:<span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;@android:drawable/ic_input_add&quot;</span>    android:<span class="hljs-attribute">tint</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">borderWidth</span>=<span class="hljs-string">&quot;0dp&quot;</span>    app:<span class="hljs-attribute">fabSize</span>=<span class="hljs-string">&quot;normal&quot;</span>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    app:<span class="hljs-attribute">rippleColor</span>=<span class="hljs-string">&quot;#00FFFFFF&quot;</span>/&gt;&lt;com.zhangyf.gapbottomnavigationview.GapBottomNavigationView    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/bottomnavigation&quot;</span>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>    android:<span class="hljs-attribute">layout_marginStart</span>=<span class="hljs-string">&quot;32dp&quot;</span>    android:<span class="hljs-attribute">layout_marginEnd</span>=<span class="hljs-string">&quot;32dp&quot;</span>    android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;16dp&quot;</span>    android:<span class="hljs-attribute">backgroundTint</span>=<span class="hljs-string">&quot;#ffffff&quot;</span>    android:<span class="hljs-attribute">clickable</span>=<span class="hljs-string">&quot;false&quot;</span>    android:<span class="hljs-attribute">padding</span>=<span class="hljs-string">&quot;8dp&quot;</span>    app:<span class="hljs-attribute">center_radius</span>=<span class="hljs-string">&quot;32dp&quot;</span>    app:<span class="hljs-attribute">corner_radius</span>=<span class="hljs-string">&quot;12dp&quot;</span>    app:<span class="hljs-attribute">elevation</span>=<span class="hljs-string">&quot;5dp&quot;</span>    app:<span class="hljs-attribute">itemBackground</span>=<span class="hljs-string">&quot;@null&quot;</span>    app:<span class="hljs-attribute">itemIconTint</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">itemTextColor</span>=<span class="hljs-string">&quot;#000000&quot;</span>    app:<span class="hljs-attribute">labelVisibilityMode</span>=<span class="hljs-string">&quot;labeled&quot;</span>    app:<span class="hljs-attribute">layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span>    app:<span class="hljs-attribute">menu</span>=<span class="hljs-string">&quot;@menu/navigation&quot;</span>    app:<span class="hljs-attribute">shadow_length</span>=<span class="hljs-string">&quot;4dp&quot;</span>    tools:<span class="hljs-attribute">targetApi</span>=<span class="hljs-string">&quot;lollipop&quot;</span> /&gt;</code></pre><blockquote><p>anchor_fab： 用来指定凹陷下去的 View ，一般都为 FloatingActionButton<br>shadow_length：用来指定高度（阴影大小）<br>cornerRadius：用来指定拐角处的平滑半径大小</p></blockquote><p>##源码<br>attrs中的3个属性</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;GapBottomNavigationView&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;shadow_length&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;corner_radius&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center_radius&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><p>#####导入源码（请直接copy）</p><blockquote><p>源码采用Kotlin，有需要可以直接转为Java，转换方法自行百度</p></blockquote><pre><code class="hljs roboconf">package com.zhangyf.gapbottomnavigationview<span class="hljs-keyword">import</span> android.annotation.SuppressLint<span class="hljs-keyword">import</span> android.content.Context<span class="hljs-keyword">import</span> android.graphics.*<span class="hljs-keyword">import</span> android.graphics.drawable.GradientDrawable<span class="hljs-keyword">import</span> android.os.Build<span class="hljs-keyword">import</span> android.util.AttributeSet<span class="hljs-keyword">import</span> android.util.Log<span class="hljs-keyword">import</span> androidx.annotation.*<span class="hljs-keyword">import</span> com.google.android.material.bottomnavigation.BottomNavigationViewclass GapBottomNavigationView : BottomNavigationView &#123;    <span class="hljs-attribute">private var fabId = 0 //凹陷View的id</span><span class="hljs-attribute">    private var centerRadius</span>: Float = 0<span class="hljs-variable">.toFloat</span>() //中间凹陷的半径    private var cornerRadius = 12f //拐角处的圆滑大小（越大越平滑）    private var shadowLength = 6f //阴影大小    constructor(context: Context) : super(context)    constructor(context: Context, attrs: AttributeSet) : this(context, attrs, 0)    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(        context,        attrs,        defStyleAttr    ) &#123;        background = GradientDrawable()<span class="hljs-variable">.apply</span> &#123; setColor(Color<span class="hljs-variable">.TRANSPARENT</span>) &#125;        val ta = context<span class="hljs-variable">.obtainStyledAttributes</span>(attrs, R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView</span>)        centerRadius = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_center_radius</span>, 0<span class="hljs-variable">.toFloat</span>())        shadowLength = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_shadow_length</span>, 6<span class="hljs-variable">.toFloat</span>())        cornerRadius = ta<span class="hljs-variable">.getDimension</span>(R<span class="hljs-variable">.styleable</span><span class="hljs-variable">.GapBottomNavigationView_corner_radius</span>, 12<span class="hljs-variable">.toFloat</span>())        ta<span class="hljs-variable">.recycle</span>()    &#125;    @SuppressLint(&quot;DrawAllocation&quot;)    @RequiresApi(api = Build<span class="hljs-variable">.VERSION_CODES</span><span class="hljs-variable">.KITKAT</span>)    override fun onDraw(canvas: Canvas) &#123;        super<span class="hljs-variable">.onDraw</span>(canvas)        val paint = Paint()        val path = Path()        //左边的半圆        val rectL = RectF(            shadowLength,            shadowLength,            height<span class="hljs-variable">.toFloat</span>() + shadowLength,            height<span class="hljs-variable">.toFloat</span>() - shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectL, 90<span class="hljs-variable">.toFloat</span>(), 180<span class="hljs-variable">.toFloat</span>(), false)        path<span class="hljs-variable">.lineTo</span>(width / 2 - centerRadius - cornerRadius, shadowLength)        //左边转角处        path<span class="hljs-variable">.quadTo</span>(            width / 2 - centerRadius,            shadowLength,            width / 2 - centerRadius,            cornerRadius + shadowLength        )        //中间凹陷的半圆        val rectCenter = RectF(            width / 2 - centerRadius,            cornerRadius + shadowLength - centerRadius,            width / 2 + centerRadius,            cornerRadius + centerRadius + shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectCenter, 180<span class="hljs-variable">.toFloat</span>(), (-180)<span class="hljs-variable">.toFloat</span>(), false)        //利用贝塞尔曲线画中间凹陷（非半圆）/*path<span class="hljs-variable">.quadTo</span>(width<span class="hljs-variable">.toFloat</span>() / 2,centerRadius<span class="hljs-variable">.toFloat</span>(),width / 2 + centerRadius - cornerRadius - cornerRadius / sqrt(2<span class="hljs-variable">.toFloat</span>()),cornerRadius / sqrt(2<span class="hljs-variable">.toFloat</span>()))*/        //右边转角处        path<span class="hljs-variable">.quadTo</span>(            width / 2 + centerRadius,            shadowLength,            width / 2 + centerRadius + cornerRadius,            shadowLength        )        path<span class="hljs-variable">.lineTo</span>((width - shadowLength - height / 2), shadowLength)        //右边的半圆        val rectR = RectF(            width<span class="hljs-variable">.toFloat</span>() - shadowLength - height,            shadowLength,            width<span class="hljs-variable">.toFloat</span>() - shadowLength,            height<span class="hljs-variable">.toFloat</span>() - shadowLength        )        path<span class="hljs-variable">.arcTo</span>(rectR, 270<span class="hljs-variable">.toFloat</span>(), 180<span class="hljs-variable">.toFloat</span>(), false)        //最后的直线        path<span class="hljs-variable">.moveTo</span>((width - shadowLength - height / 2), height<span class="hljs-variable">.toFloat</span>() - shadowLength)        path<span class="hljs-variable">.lineTo</span>(height / 2<span class="hljs-variable">.toFloat</span>() + shadowLength, height<span class="hljs-variable">.toFloat</span>() - shadowLength)        path<span class="hljs-variable">.close</span>()        Log<span class="hljs-variable">.d</span>(&quot;!!!&quot;, &quot;!!!!!!!!!!!!&quot;)        //按背景色填充背景        paint<span class="hljs-variable">.apply</span> &#123;            style = Paint<span class="hljs-variable">.Style</span><span class="hljs-variable">.FILL</span>            if (Build<span class="hljs-variable">.VERSION</span><span class="hljs-variable">.SDK_INT</span> &gt;= Build<span class="hljs-variable">.VERSION_CODES</span><span class="hljs-variable">.LOLLIPOP</span>) &#123;                color = backgroundTintList?<span class="hljs-variable">.defaultColor</span> ?: Color<span class="hljs-variable">.BLACK</span>            &#125;            maskFilter = null            isAntiAlias = true            //添加阴影            setShadowLayer(shadowLength, 0<span class="hljs-variable">.toFloat</span>(), 0<span class="hljs-variable">.toFloat</span>(), Color<span class="hljs-variable">.LTGRAY</span>)        &#125;        canvas<span class="hljs-variable">.drawPath</span>(path, paint)    &#125;&#125;</code></pre><blockquote><p>建议：结合我的代码并利用 paint（画笔） 随意更改为你想要的形状</p></blockquote><p>我的效果就是这样咯<br><img src="https://upload-images.jianshu.io/upload_images/17794320-fc974949ebf9b9ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="093143d5ebb666338bc164a6bd339da5.jpg"></p><p>喜欢不要忘了点赞关注或者去github点个星星哦～～</p>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
